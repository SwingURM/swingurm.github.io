{"6840":{"title":"6840","links":[],"tags":[],"content":"为什么使用线程\nI/O并发\n使用多核能力\n完成一些定时任务\ndefer关键字\n推迟该表达式的执行到作用域结尾之后\n适用于作用域结束时锁的释放这种，类似raii\nmap是指针\nRPC≠PC\n三种语义\nat least once\nat most once 服务端来确保不重复执行，应用程序处理重复和失败\nexactly once难\n分布式文件系统是一个很重要的组件\n配合 无状态的应用程序\n分片提供高性能\n复制解决容错，带来一致性问题，维护一致性带来性能开销"},"01背包":{"title":"01背包","links":[],"tags":["算法"],"content":"集合：\n在前i件物品中，选择总体积不超过j的物品的所有选择方案\n属性：\n集合中所有选择方案中，价值最大的方案的价值\n状态计算：\n集合划分为：包含了第i件物品f[i - 1, j - v[i]]+w[i]和不包含第i件物品f[i-1,j]\n状态转移方程：\nf[i][j] = max(f[i-1][j], f[i-1][j-v[i]] + w[i])\n结果：f[m][n]\n可以压缩成一维\nfor (int i = 1; i &lt;= m; i++) {\n\tfor (int j = n; j &gt;= w[i]; j--) {\n\t\tf[j] = max(f[j], f[j - w[i]] + v[i]);\n\t}\n}"},"15-445-实验remake记录":{"title":"15-445 实验remake记录","links":[],"tags":["example-tag"],"content":"LRU-K Replacer\n用双向链表+哈希表替换了原有实现\n原有实现是哈希表指向每个frame对应的node，在node里存该frame的所有历史。evict时候需要遍历所有的frame😅\n维护history和buffer两个双向链表，history保存访问次数不足k次的，buffer保存大于等于k次的。规定history中按earliest overall timestamp（就是最早访问最早的最优先出去，理解水平有问题吃了好多苦）当前时间戳的距离降序保存，buffer中按LRU-K降序保存。\n约定链表尾部为最recent的，因此evict时候应该从链表的头部开始找。\n哈希表保存链表的迭代器，cpp对list迭代器失效有不错的保证。\n在修改过程的踩坑点如下：\n\n在调试器watchpoint里放了一些表达式，导致address sanitizer在运行到某行代码时总是报错，但看不出那行代码有什么问题。😅\n对STL list不熟，被博客坑了\nearliest overall timestamp\n\n修改前\n\n修改后，好像Evict的平原少了一点\n\nBuffer Pool Manager\n参考\nTitle Unavailable | Site Unreachable\nCMU 15-445 2023 P1 优化攻略 - 散落的叶子\n首先是一个重要的观察：哪些操作是支持被并发调用的，并且是涉及IO的。这是粗看下来对性能影响最大的部分。\n其实只有并发多个FetchPage（同一个pid或者不同pid），并发多个NewPage。\n在FetchPage中涉及写回脏页和读取磁盘两个步骤，NewPage中涉及写回脏页。\n在本文中frame被用来指代内存中的page，page指磁盘中的page\n参考大佬的说法，我们可以把等待IO完成这件事放在大锁的外面。\n假设处理磁盘读写任务的队列有保证所有提交的请求被按顺序完成，我们只需要保证任务发出的顺序，也就是在大锁持有期间按顺序发出即可。（踩坑：之前没注意这一点，导致偶尔出现插队，难以debug）。举例一个我这的出错情况，两个线程并发fetch，后者fetch了前者驱逐出的页。请求队列应该是写X读Y写Z读X，如果没有在大锁期间发出导致请求被插队成写Z读X写X读Y，就很容易直接触发disk_manager的断言，如page x not exist或者page x not in range。\n牢记下面只需处理并发多个FetchPage（同一个pid或者不同pid），并发多个NewPage。\n为了提高性能，队列中的请求应当被尽量并发执行。容易想到的是，对于内存中不同的frame的请求是可以并行处理的。这里唯一需要注意的一个约束是磁盘操作的全局顺序：对磁盘上page的读请求不应该插队到之前的写同一个page请求之前，正如上文中的那个例子。（而且这样的对同一个page的操作在整个队列里至多只有这样一对，所以编码处理起来不难 😉见后文继续分析）。剩下的情况有些可能只是因为我通过外部设计避免了，如不可能出现有两个对同一个page的写请求（不可能有多个frame存储同一个page，同一个frame多次写回也是可以避免的），不可能同时有多个对同一个page读请求（并发fetch同一个page），先读后写也是不可能的（读说明正在fetch，这时不会发出对这个page的写请求）。\n\n我在bpm中处理对同一个page的并发fetch，加了个标记位，晚到的fetch看到标记位只需等待即可，不会发出磁盘请求。\n至此算是理解了这两点在说什么并且完成了，在这两点上好像没什么文章可做了，除非可以再放宽对请求处理顺序的要求😵‍💫\n1. Parallel I/O operations. Instead of processing one request at a time in your disk scheduler, you can issue multiple requests to the disk manager at the same time. This optimization will be very useful in modern storage devices, where concurrent access to the disk can make better use of the disk bandwidth. You should handle the case that multiple operations to the same page are in the queue and the end result of these requests should be as if they are processed in order. In a single thread, they should have read-after-write consistency.\n2. To achieve true parallelism in disk scheduler, you will also need to allow your buffer pool manager can handle multiple `FetchPage` requests and evicting multiple pages at the same time. You might need to bring in a conditional variable in your buffer pool manager to manage free pages.\n\n2025.4.17 发现代码里埋了个bug，write完忘记通知等待中的reader💦\n原版命中率4.19%，纯get的命中率是12.84%\n对scan，作不加入LRU-K中的处理后，命中率为6.22%，纯get的命中率为12.75%。\n2025.6.21 尝试继续优化无果\n首先我想对之前的一些实现细节作补充。我的DiskScheduler为每个frame提供一个后台线程，后台线程处理请求时只需要特殊考虑上面图中的情况，必须要让读读到最新的写（为什么？因为既然Fetch Y先持有bpm大锁并执行了，其他线程得看到Fetch Y的Write X。这里我反思了Fetch Y后续的R Y被其他请求插队执行似乎是无关紧要的，也即似乎不需要在bpm锁持有期间提交请求）。后台线程依序处理同一个frame的请求时需要考虑RAW的情况，即等待其他线程的对同一个page的写完成再读，或者直接从该线程那里偷读。我的DiskScheduler处理线程能处理同一个frame按序提交多个请求的情况，能按序完成。\n观察了一下DiskManager-模拟磁盘设备的Latency设置，我尝试着拍脑袋优化。Latency设置说，如果你的新请求相比上次请求是sequential的，或者你的新请求和最近某次请求在同一块中，那么延迟不会很大。\n为此我这样构造，bpm是请求的生产者，而且我们有很多这样的生产者，提交到请求队列中。我创建一个中间线程，他会尝试识别队列中在同一块中的请求，将他们打包。我创建了一个固定线程数量的工人池，他们可以消费请求。中间线程会将成批的请求均匀的发送给工人们，从而保证同时提交请求，并能利用磁盘的特性。然而效果不佳。🤣\n我做的时候好像忽略是考虑最近几次请求而不是最近一次请求了。\nQuery\nCMU15-445 23Fall Project 3 优化攻略-CSDN博客\nCMU 15445 Project 3 - xxxl’s Blog\n这部分主要参考了第一位大佬的博客。\n刚拾起来的时候有点痛苦，感觉当初自己完全没看懂里面Schema，Value的细节，只是勉强会用。现在还是这样\n踩坑点：\nbustub中的值包装类型，在我没有确认类型就转换的情况下就进行转换Value.GetAs&lt;int64_t&gt;()。有类似ub一样的感觉，很长时间困扰了我的Optimize1的实施。\n优化规则感觉有不小的工作量和心智负担。（其实bustub对这几条优化的要求不高，只要能覆盖他提供的几条样例sql即可。）经历这件事，我有如下体会：\n多用断言表达你对程序行为的假设。（其实感觉都是jyy在调试理论里讲的）首先这能帮助你最快速地定位一些错误，而不是让程序在偏离你预期之后还一直跑，最后在一个风马牛不相及的地方彻底崩溃，让你一头雾水，然后再经历漫长的调试过程反着定位回来。其次，当我添加一个新功能时，往往需要在多个相关代码模块中为他新增修改提供支持。于我而言，我的脑容量/上下文大小可能是不够那么大的，常常会遗漏某个模块的修改。如果你之前已经在程序中用断言表达了你的假设，那么即使你遗漏了也能很快发现，也就是说我觉得这种做法对变更也是很友好的。你的脑袋里的假设能够落到代码中，尽管你没意识到原有假设已经被打破了，计算机会提醒你这一点。\n其他的没啥好说了，老生常谈♿的模块抽象，不要重复你自己这一块还是得多学习。\n小心C++构造函数期间传出this指针。"},"BST":{"title":"BST","links":[],"tags":[],"content":"如何删除一个具有两个子节点的节点\n选择一个新的节点取代删除节点\n它必须满足：&gt;被删除节点左子树中的所有元素\n&lt;被删除节点右子树的所有元素\n因此可以选择左子树的right-most和右子树的left-most\n这被称为Hibbard deletion\nb树的改进想法\n避免添加叶节点，保持树高\n在叶节点中overstuff，在节点满时move up &amp; split"},"CLRS":{"title":"CLRS","links":[],"tags":[],"content":"分治算法 矩阵乘法的例子\n归纳法 主定理证明\n尝试放宽上界 主定理要求多项式意义下的比较"},"CMU-15-445":{"title":"CMU 15-445","links":[],"tags":[],"content":"data model\n关系，K/V，图等等\nschema\nentity和他们的attribute\nrelational algebra是procedure的\nSQL\nwindows function为每一行计算一个新值？\n可以用来得到行号，排名rank\nmmap\n让OS负责内存和外存的页交换\n不建议\nDBMS管理一系列的page作为存储单元\n找到page的方法可以是链表或者目录式\nheap\npage中如何组织内容\n1.tuple-oriented\nstrawman 谬误做法\n定长记录在block中的组织方式\n在删除时除了将最后的记录移过来填补空位这种做法，还可以保留一个file header，维护free list（空缺位置的链表）\n以链表形式记录可用位置\nslotted page\n在块中组织变长记录\n\n当需要修改时只需要维护slot array中的偏移\n支持可变长\n中间可能会有碎片\n可以在postgres中简单测试检验这一行为\n这种结构规定了（外部？）只能保存指向块头中的指针，而不能保存直接指向记录的指针（大概是因为tuple会移动）\nProblem #1: Fragmentation\n→ Pages are not fully utilized (unusable space, empty slots).\nProblem #2: Useless Disk I/O\n→ DBMS must fetch entire page to update one tuple.\nProblem #3: Random Disk I/O\n→ Worse case scenario when updating multiple tuples is\nthat each tuple is on a separate page.\nWhat if the DBMS cannot overwrite data in\npages and could only create new pages?\n2.log-structed\n每个tuple有一个唯一标记\n写操作时，只追加PUT或DEL到某个tuple的操作日志，不实际执行\n读操作麻烦了\n保留一个指向每个tuple最新的日志的索引（不一定存在最新日志）\n可以压缩日志，压缩之后每个tuple的操作至多出现一次，存储到磁盘上的时候可以放弃时序信息，而是按他们的id排序，便于读取\n压缩方法\nuniversal 归并？\nlevel 层级的？\n有写放大问题\n一次逻辑写变成很多次物理写\n3.index-organized\ntuple中如何组织内容\n防止跨字读取 填充和重排序\n现有数据库如何处理numeric\nNULL标记 推荐方法 bitmap\n大文件的存储\nworkload\n\nNSM\nDSM\n一个block只存一个属性（column store）\nPAX\nrow group\ncolumn chunk\n在row group中column store\n提高I/O效率\ni/o是数据库瓶颈\n通过压缩来提高IO效率\nnaive compression\n使用通用压缩技术，同时意味着DBMS不能理解压缩后的数据\nzstd\n希望不用解压缩就能操作数据，将操作转换为等价的压缩后的表示\ncolumn level\n可以混合使用多种策略\nrun-length encoding\nRLE Triplet\nvalue,offset,length\n把相邻的相同value的值合并\n排序后效果更好\nbit packing\n使用空间比声明所需的空间小（int32，但是数很小）\n丢掉没有使用的位（转为int8）\nmostly encoding\n允许bit packing中出现一些确实使用了很多空间的值的特例\n把他们设置为特殊值（即指示从字典查），单独用字典存储\n\nbitmap encoding\n对一个属性的每个取值，使用一个bit来对应\n适合取值情况极少的\ndelta encoding\n存储前缀和表\ndictionary encoding\n常用\n希望字典的键（压缩表示）有和值（原值）一样的ordering来进行点查询和范围查询 保序\n字典要支持压缩和解压\n解压是常规的，从键得到值\n压缩是为了让我们做到前面说的把操作转换为等价的压缩后表示\nqwq\n去哪里读入（空间局部性）\n什么时候读入/写回\nmultiple bufferpool\n减少锁争用，增加局部性\nprefetch\n不仅是最简单的sequential access可以，index（b+树）的访问也可以\nscan sharing\n合并扫描相同表的指针\ncontinuous scan sharing\n有一个一直循环扫描的指针\n需要时跳上去\nbypass\n不在buffer pool中保存，只是临时自己使用内存page\nLRU和CLOCK不记录频率，只记录了最近访问时间\nsequential flooding\nOLAP中，读过一次的page不会再被读，最近访问的是最适合evict的\n一次顺序读取把LRU记录信息全部变成没有意义的东西的意思\nLRU-K\n可能还有个记录驱逐信息的cache\n两个辅助优化\nlocalization\nquery局部作判断\n防止污染\npriority hints\ndirty page处理\nbackgrounding writing默默处理dirty page\nOS和硬件有一些最大化disk bandwidth的机制会重排IO请求\n但是他们不知道请求优先级（是background writing还是更重要的writing）(linux支持优先级设置？)\n一样的，DBMS会绕过操作系统的IO使用direct io\nfwrite不保证写入到文件，只保证进入了OS的cache\nfsync可以保证\n为什么fsync要设计成fail之后将dirty page设置为clean\n（前提可能是认为fsync fail代表那个设备离开了）1个u盘被拔出了fsync失败，脏的页没必要继续为他继续保留\n\nhash table\n平均时间复杂度 O(1)\n但是在DBMS中常数matter\nhash function\n如何映射\n快速映射和碰撞率的trade-off\nfacebook xxhash3\nhash scheme\n如何解决冲突\n分配大哈希表和增加get/put所需操作之间的trade-off\nstatic hashing scheme\n如果空间不够，重新创建hash table\nlinear probe\n如何处理删除\n#1 tombstone\n#2 move （应该是指把空位填充上）\n如何处理non-unique keys\n#1 seperate linked list 存储一个指针，指向存储所有可能值的列表，而不是存储值本身\n#2 redundant keys 直接一起放重复值（似乎兼容linear probing（？））\ncuckoo\n鸟在别人的窝下蛋\n使用同一个algorithm的不同seed版本的多个hash functions\n如果没有位置，驱逐一个元素给它重新找位置\n缺点 需要做random io\nswiss tables\nrobin hood\nhopscotch\ndynamic hashing scheme\nchained hashing\n每个bucket保存一个链表，线性查找key\n优化 为每个bucket添加一个bloom filter指示某个键是否存在 避免不存在情况下的无效遍历\n\n\n                  \n                  Notes\n                  \n                \n\nbloom filter\n是一种probabilistic数据结构，不会出现false negatives但可能出现false positives\n由bitmap和多个hash function组成\ninsert时将键计算多个hash function，对bitmap长度取模，对应位设置1\nlookup时检查\n不支持delete\n\n\nextendible hashing\n避免chained hashing中的list变得过长\n局部的incremental rehashing\n图中展示了local depth=global depth时的策略，即global depth翻倍\n这里是前缀\n\n\nlinear hashing\n分摊\noverflow时rehash split pointer指向的\n根据当前hash的和split pointer的关系（图中是上下关系）选择应该用哪个hash function\n具体做法可能是先用旧的function试，如果映射到了split pointer上方的框就说明得用新的function\n\nb-tree\n一系列数据结构，通常是指balanced\nb+-tree\ntransaction level correctness\n可能平时纠结了上述意义下的并发正确性，对于数据结构的实现似乎只需要保证下面的正确性（大概是指一个写者或任意多个读者）\ndata structure level correctness\nlatch crabbing/coupling\n乐观锁\n假设大部分情况下不需要merge/split，不需要持有父节点的写锁，使用读锁一路遍历到叶节点再判断\n在一般的b+树中，由于遍历顺序都是自顶向下，不存在死锁\n但是如果在相同层级的节点之间建立横向连接，可能出现死锁，并且（由于thread通信/维护thread在做什么这件事代价很大）假设没有一种中心化的控制，当出现得不到锁的情况，与其等待，我们选择的策略是杀掉自己，撤销自己做的。\n外部排序算法思路\n分治\n如何存储中间结果\nkey/value的pair，其中key是排序基准，value是tuple\nrow store倾向于在中间结果中直接保存tuple本身，因为store的时候就是这样的\ncol store是存储record id\n前者称为early materialization，后者称为late\n\n2-way merge只需要bpm中能存放三个page，两个用于读，一个用于写\nn page需要pass数为1+log2N上取整\nio花费是2n * pass\n更大的内存\n可以直接in memory做，跳过几个run\n可以更多way\n树更胖更矮\ndouble buffering\n重叠io和cpu\n与其增大way数（？），选择留一半的bpm page用来做双缓冲，cpu归并的时候，磁盘可以读到另一半为下一次归并做准备\n能优化响应时间 不太影响吞吐量（？）这点还不太能辨析\n比较优化\n使用hardcode的sort func（c++模板编程技术）而不是传递函数指针给通用排序函数\nsuffix trunctation\n字符串比较先使用一个binary prefix，相等了fallback到正常的完整比较\n使用b-tree加速\nb树的叶子节点存储了record id\nclustered保证了附近叶子的record都在一个page上，从左到右遍历叶节点比外部排序显然更快  unclustered的话还是不要这样遍历的用了，random io太\ngroup by和distinct并不一定需要sorting来做，可以用hashing来做\n这里是先“一分多”，b-1个page用来输出\nPartition：首先使用哈希函数h1将所有tuple按照key放进不同的分区（分区大小能保证能在内存里操作，h1保证了相同哈希的都被聚集在这个分区了）\nReHash：对于每一个分区，使用哈希函数h2在内存中建立哈希表，并维护聚合所需信息（如最小值、总和等）\nearly/late materialization\njoin时创建表格的复制 可预测的io\n这里可预测个人理解是指tuple的数量，位置不确定，对磁盘不友好\njoin时只记录tuple的唯一标识符 不可预测的io\nnaive nested loop join\nblock nested loop join\nRxS 使用B-2个页面缓存R，1个页面读入S，这样同时有更多的页面在内存中，他们一起和读入的S做join\nindex nested loop join\nprocess model\n函数调用，指令缓存不友好\n容易出现pipeline breaker\nmaterialization\nvecterization\n介于前两者之间，可以使用simd优化\naccess model\nseq scan\n遍历table的所有page中的所有tuple\n优化方式 Data skipping\n实现方式 Approximate Queries 和 Zone Maps\nZone map统计了该zone下的一些特征，如平均值\nzone map和zone本身一起保存，不节省io，但是节省cpu\n如果不和zone一起保存，维护更麻烦，但是节省cpu和io\nhalloween problem\n更新操作重复更新一个tuple多次\n解决方法 追踪要修改的record id\nexpression evaluation优化\n常规方法是树的遍历\n更好的方法是即时编译出计算表达式的函数\nindex scan\nquery planning\ncatalog记录了所有表格的统计信息（记录数，page数），索引\n估算每个查询计划的io（读写页次数）\nvectorization(使用管道)避免了执行过程中不必要的materialization，减少io\n得到的查询树需要转为physical plan（这个转化关系也不是11对应）发送给scheduler\nphysical plan描述了access path（管道，scan，b树等）和成本估计\n找到所有等价查询树是np难问题\nrule base\n不需要考虑数据情况\n如predicate pushdown，使用笛卡尔积\ncost base\nlog_debug宏\ntransaction\ncorrection criteria ACID\n其中atomicity和persistency用undo/redo实现，isolation用并发控制，consistency用integrity constraint\natomicity实现\nlogging\nshadowing\n在复制上进行操作，提交时使操作可见\neventual consistency\n保证最终到达一致状态，但可能使不一致状态可见？压力来到应用程序员\nserial execution\nunrepeatable read 同一个事务的连续两次读得到不同值，违背隔离\ndirty write 读到未提交的值\nlost update\n\n从时间更早的指向更晚的，不能有环\n刻画了依赖关系\n串行化调度\n有多种排列顺序，但都被认为是正确的\n两段锁协议2PL\n直觉：从时间图上看，每个transaction获取锁的数量先上升后下降，谁先到达lock point谁先执行，由于依赖图中的边的顶点至少有一个写，两个顶点的事务的锁不兼容，必须等待，保证了依赖/顺序关系\n悲观地打破了依赖图中的边\n仍然会有脏读\n严格2PL\nOCC\np0记录\ndebug还是不太会，不知道gdb里用一个父类指针看一个子类的模板实例的一个模板成员\np1记录\nnewpage和fetchpage的时候record access即可\n但是unpin也传入了access\np2记录\n比较离谱，把锁的获取放在读写guard构造函数外面才行\n然后bpm的新加的获取guard的三个函数乱加锁（指直接使用scope lock，能通过的做法是直接调用原来的外部接口，因为它已经上锁了）也会出问题\n没正确理解要求中合并的前提（以为是两个都为空才能合并）\n写了个边迭代边修改容器的bug\n没过qps test是因为remove的时候没有在已经存在该key时直接return false\np3记录\nseq-scan执行中用到了catalog提供的tableheap中提供的iterator，不知道bpm的操作是谁做的\n良好的practice\n在头文件上方绘制了数据结构在内存中的示意图\n提供了打印每种page信息的函数\nintegrity check\n存储部分的主要目的：hide latency\n如何找到一个page\n每个page都有一个唯一的identifier，常见的组织页面的实现方法是heap\ntuple-based, index-based, log-based  NSM\nOLTP\nN S M : S U M M A R Y\nAdvantages\n→ Fast inserts, updates, and deletes.\n→ Good for queries that need the entire tuple (OLTP).\n→ Can use index-oriented physical storage for clustering.\nDisadvantages\n→ Not good for scanning large portions of the table and/or a subset of the attributes.\n→ Terrible memory locality in access patterns.\n→ Not ideal for compression because of multiple value domains within a single page.\nD E C O M P O S I T I O N S TO R AG E M O D E L ( D S M )\nAdvantages\n→ Reduces the amount wasted I/O per query because the DBMS only reads the data that it needs.\n→ Faster query processing because of increased locality and cached data reuse.\n→ Better data compression (more on this later)\nDisadvantages\n→ Slow for point queries, inserts, updates, and deletes because of tuple splitting/stitching/reorganization.\n为什么mvcc写不阻塞读\nmvcc存在write skew anomaly"},"Daily/2022-10-04":{"title":"2022-10-04","links":[],"tags":[],"content":"STFW (Search The Fuckking Web)向别人求助之前自己先尝试通过正确的方式使用搜索引擎独立寻找解决方案.\nRTFM是STFW的长辈, 在互联网还不是很流行的年代, RTFM是解决问题的一种有效方法. 这是因为手册包含了查找对象的所有信息, 关于查找对象的一切问题都可以在手册中找到答案.\n你或许会觉得翻阅手册太麻烦了, 所以可能会在百度上随便搜一篇博客来尝试寻找解决方案. 但是, 你需要明确以下几点:\n\n你搜到的博客可能也是转载别人的, 有可能有坑\n博主只是分享了他的经历, 有些说法也不一定准确\n搜到了相关内容, 也不一定会有全面的描述\n\n最重要的是, 当你尝试了上述方法而又无法解决问题的时候, 你需要明确”我刚才只是在尝试走捷径, 看来我需要试试RTFM了”."},"Daily/2022-10-09":{"title":"2022-10-09","links":[],"tags":[],"content":"STFW - Search The Fucking Web\n\n只要我用的工具是大众的, 我几乎不可能是世界上第一个遇到问题的人\n网上一定有人遇到过相同/类似问题, 我应该搜一下看看他们怎么解决\n\nRTFM - Read The Fucking Manual\n\n只要我用的工具是大众的, 应该有手册记录这个工具的所有细节\n如果我想了解它的某个问题, 我应该去搜索手册的描述\n\nRTFSC - Read The Fucking Source Code\n\n只要我获得了项目代码, 理论上我就可以知晓它的一切行为\n如果我想了解它具体是如何工作的, 我应该去读一下(关键)代码\n\n如果你在提问时收到了这些回复, 其背后的含义是:\n\n你想要的答案很容易找到, 你很应该自己去获取\n相比于我直接告诉你答案, 你自己获取答案能学到更多\n\nurl: github.com/ryanhanwu/How-To-Ask-Questions-The-Smart-Way/blob/main/README-zh_CN.md#rtfm-%E5%92%8C-stfw%E5%A6%82%E4%BD%95%E7%9F%A5%E9%81%93%E4%BD%A0%E5%B7%B2%E5%AE%8C%E5%85%A8%E6%90%9E%E7%A0%B8%E4%BA%86\ntitle: &quot;How-To-Ask-Questions-The-Smart-Way/README-zh_CN.md at main · ryanhanwu/How-To-Ask-Questions-The-Smart-Way&quot;\ndescription: &quot;本文原文由知名 Hacker Eric S. Raymond 所撰寫，教你如何正確的提出技術問題並獲得你滿意的答案。 - How-To-Ask-Questions-The-Smart-Way/README-zh_CN.md at main · ryanhanwu/How-To-Ask-Questions-The-Smart-Way&quot;\nhost: github.com\nfavicon: github.githubassets.com/favicons/favicon.svg\nimage: repository-images.githubusercontent.com/33041711/b9155c00-e8b9-11ea-9060-9a2a69ad2d6e\nurl: github.com/tangx/Stop-Ask-Questions-The-Stupid-Ways/blob/master/README.md\ntitle: &quot;Stop-Ask-Questions-The-Stupid-Ways/README.md at master · tangx/Stop-Ask-Questions-The-Stupid-Ways&quot;\ndescription: &quot;Stop-To-Ask-Questions-The-Stupid-Ways. Contribute to tangx/Stop-Ask-Questions-The-Stupid-Ways development by creating an account on GitHub.&quot;\nhost: github.com\nfavicon: github.githubassets.com/favicons/favicon.svg\nimage: opengraph.githubassets.com/efb72f7c4694d4f11f9e55392c22d9743d664deb2204d844f5cbae88570432cc/tangx/Stop-Ask-Questions-The-Stupid-Ways"},"Daily/2023-08-19":{"title":"2023-08-19","links":[],"tags":[],"content":"failed to synchronize all databases (unable to lock database)\n解决方法：删除/var/lib/pacman/db.lck\nwsl docker图形化解决方案\nwslg/samples/container/Containers.md at main · microsoft/wslg (github.com)\nmacos x11转发踩坑\nssh - OpenGL rendering with X11 forwarding - Unix &amp; Linux Stack Exchange --- ssh - 使用X11转发的OpenGL渲染 - 智库101 - 一个基于CC版权的问答分享平台"},"Daily/2023-08-22":{"title":"2023-08-22","links":[],"tags":[],"content":"136. 只出现一次的数字 - 力扣（LeetCode）\n异或运算"},"Daily/2023-10-15":{"title":"2023-10-15","links":[],"tags":[],"content":"系统调用不设置返回值时\n以write调用的行为来看，好像是被认为没有输出成功从而会反复尝试重新输出第一个字符，具体真相有待继续研究 存疑"},"Daily/2023-10-23":{"title":"2023-10-23","links":[],"tags":[],"content":"更多CPU\nDMA，设备管理器，总线管理器，显卡\n可以认为是完成一些特定任务的CPU\n否则CPU没法做到在限制指令条数的情况下完成一些任务（如拷贝大量数据到屏幕寄存器上）\n消除简洁左递归的方法的使用要求\n文法中不存在环\nA=^*&gt;A\n文法中不存在ε产生式\nLL(0)文法\n一个字符也不往前看\n可能的语言是 只有一个字符串 或者对于每一个终结符 产生式唯一 不需要作选择\nIPC和频率\n为什么时钟频率不能完全反映性能，因为只是时钟数，还需要看IPC（目前理解）\n上下文相关文法\nL=\\{a^nb^nc^n|n\\ge1\\}\n正则表达式的表达能力\n严格弱于上下文无关文法\n证明方法：先证明所有正则表达式都能用上下文无关文法描述，构造自动机\n再找到一个不能用正则表达式表述的上下文无关文法Pumping lemma\nL=\\{a^nb^n|n\\ge1\\}\n怎么证明他不能用正则表达式表述\n有限状态自动机的状态有限\n前递\n单单从时空图来看，就是允许拿上一个时间写进某个流水级之间的寄存器的值作为输入"},"Daily/2023-10-24":{"title":"2023-10-24","links":[],"tags":[],"content":"设备\n可分为字符设备和块设备\n设备支持read,write,ioctl（读写设备配置）\n字符设备 终端tty\n块设备 磁盘\nLinux Block I/O Layer\n文件系统和磁盘设备之间的层\n一些有趣的设备 /dev/null /dev/0 随机数设备等等\n万物皆文件\n什么是设备驱动\n系统调用遵从设备specification的实现 翻译成设备需要执行的\n简洁的系统调用接口将复杂性扔给了其实现\nlinux中最臭最大的一块 设备驱动\n文件系统的抽象\n文件是一种虚拟磁盘\n文件挂载 回环设备"},"Daily/2023-10-25":{"title":"2023-10-25","links":[],"tags":[],"content":"动态规划\n子问题图刻画了子问题之间的依赖关系，图上的边数点数与运行时间成正比\n钢条切割\nr_n=max(p_n, r_1+r_{n-1}, r_2+r_{n-2},....,r_{n-1}+r_1)\n更简单的求解方式\nr_n=max(p_i,r_{n-i}) (1\\le i \\le n)\n矩阵连乘\n总括号化方案数\n\\left.P(n)=\\left\\{\\begin{matrix}1&amp;n=1\\\\\\sum_{k=1}^{n-1}P(k)P(n-k)&amp;n\\geqslant2\\end{matrix}\\right.\\right.\n为卡特兰数，可能是指数级\n最优子结构\n证明方法 剪贴黏贴技术cut and paste\n无权最长路径不符合 无权最短路径符合\n因为无权最长路径中子问题之间相关，将原问题划分成两个子问题A和B，A中使用了的顶点不能在B中使用（简单路径的要求）\n重叠子问题\n刻画子问题空间 保持子问题空间尽量简单，在钢条切割问题中是子问题空间中的问题是长度为i的钢条的最优切割问题。\n只在必要时扩展它，在矩阵连乘问题中，是起始点为i，终点为j的子问题\n动态规划问题的时间复杂度\n1.子问题总数和每个子问题的选择数 两者的乘积\n2.子问题图\n最长公共子序列问题\nLCS的最优子结构\n\n试图简单阐释一下证明思路 如懂\n1.zk一定是延伸到了X和Y的末尾，否则Z可以更长，与Z是LCS矛盾\n如何证明Zk-1也是LCS，如果存在更长的Xm-1和Yn-1的LCS W，那么Z可以更长\n2和3 首先Z可以是Xm-1和Y的公共子序列…\n什么是文件 vector&lt;char&gt;\n什么是目录 map&lt;string,file-ptr&gt;\nFAT\n面对的情况 文件数少 块数也少 直接使用链表结构\nFAT-16中的16代表”next数组”占用的bit\nnext数组标记了可能存在的该文件的下一块的位置或者坏块等等\n文件是块的链表 但是链表的next数组被同一存放在一个位置利用了局部性，存储了多个备份保证安全\n目录也是文件，目录的实际数据内容是目录项，其中也存放了文件的元信息\nLL文法改造\n消除左递归 提取公因子\n如何消除间接左递归，保证产生式左右两端非终结符的单调性\nll star\n支持二义，不支持间接左递归\n三个大主题\n优先级上升算法 将递归产生循环展开，附加上优先级，通过设置优先级实现左结合右结合和运算优先级。（左结合上升一级，右结合不变）\n异常处理和从异常中恢复\nfollowing集合，一个动态分析的概念\nP=\\{S-&gt;Ac|Ad,A-&gt;aA|b\\}\n(a*b)(c|d)\n面对bc和bd，应该如何展开S呢？这似乎是一个LL(?) 的\nlookahead dfa接受当前输入的整个前缀，告诉要选择哪个产生式\n\n和NFA转DFA的算法类似，维护一个状态集合，（对于该文法）每个状态是一个三元组(当前状态，该状态选择的探索路径，递归调用栈（应当返回的状态）)\n也就是比NFA转DFA算法多了一个调用非终结符\nReorder Buffer/Renaming table\nRenaming table维护寄存器名的映射\n当新的指令被dispatch或者某条指令complete时应当分别被更新成 它在renaming table中的标签 和 实际值\n乱序执行受限于指令的稳定提供-控制冒险\n乱序发射dispatch本身不带来性能提升，因为还是受限于寄存器名称的相关\n区分complete和commit\n微体系\n微体系是体系结构的实现\n差分机\n一个函数的值可以用做差分，最后用加法器填表计算\n"},"Daily/2023-10-26":{"title":"2023-10-26","links":[],"tags":[],"content":"内存/硬盘\n内存层次模型在苦苦支撑一个支持随机访问的大内存模型\n但是硬盘的随机访问就不太行，所以文件系统的设计不能按内存的特性设计"},"Daily/2023-10-30":{"title":"2023-10-30","links":[],"tags":[],"content":"并发\n针对并发带来的问题，我们的解决方式是不要并发。\n一把大锁保平安，只在需要时拆锁，不要over design\n语法制导\n什么是语义？调用某个符号之前有没有声明，表达式类型\n属性文法为上下文无关文法赋予语义 SDD\n实现属性文法 SDT\n在语法分析过程中嵌入语义动作（代码），该动作在左边的所有文法符号处理好后立刻执行\n如何将SDD转为SDT？\n综合属性和继承属性都描述了信息的流动\n在依赖图中，S属性体现为自下而上的流动，继承属性则是从左向右，从上而下的 有序的信息流动\n因此从代码角度，综合属性是返回值，继承属性是调用参数\n语法制导定义\nSDD给每个产生式关联了一组规则，唯一确定了每个非终结符节点的属性值，但没有规定实际执行的顺序，方式\n有点像定义了一个方程组\nS属性定义是一种只有综合属性的SDD\nL属性定义是包含继承属性，但是一系列规则限制不产生环\n综合属性\n只能由该节点本身和子节点的属性来定义\n表达式求值，中缀表达式转后缀表达式可以用综合属性实现\n继承属性\n只能由父节点，本身和兄弟结点的属性来定义\n类型声明文法可以用继承属性实现\n数组类型声明和引用需要使用两种属性\n为什么？int a[2][3]在树上的顺序是int 2 3，但我们需要构造(2,(3,int))\n如何进行语义分析\n定义一些listener，在遍历树的某些时机做适当的事\noffline 再遍历语法树 有开销\nonline 语法制导 在语法分析的同时完成\n更多方式有待学习"},"Daily/2023-10-31":{"title":"2023-10-31","links":[],"tags":[],"content":"primes实验记录\n反复关闭同一个管道口 错误的\np = get a number from left neighbor\nprint p\nloop:\n    n = get a number from left neighbor\n    if (p does not divide n)\n        send n to right neighbor\n\n"},"Daily/2023-11-01":{"title":"2023-11-01","links":[],"tags":[],"content":"\n定理\n存在一种LR语法分析方法，保证句柄总是出现在栈顶\n定理给出了存在性证明，句柄并不一定出现在栈顶，但这可能会给我们的算法带来很多负担，因此我们使用栈顶的这种。\n\nshift移进 reduce规约/回溯 goto\n状态刻画了当前 所有观察到的针对所有产生式的右部的前缀。\n状态是项集。\n点指示了栈顶，左边是栈中内容（路径），右边是期望看到的文法符号串。\nCLOSURE({[E&#039;→.E]})\n\\operatorname{GOTO}(I,X)=\\operatorname{CLOSURE}\\Big(\\Big\\{[A\\to\\alpha X\\cdot\\beta]\\Big|[A\\to\\alpha\\cdot X\\beta]\\in I\\Big\\}\\Big)\n接收状态\nF=\\{I\\in C\\mid\\exists[A\\rightarrow\\alpha\\cdot]\\in I\\}\nGOTO函数被拆分成ACTION表（终结符）和GOTO表（非终结符）\nLR(0)分析表构造\n\\text{GOTO}(I_i,a)=I_j\\wedge a\\in T\\implies\\text{ACTION}[i,a]\\leftarrow sj\n\\text{GOTO}(I_i,A)=I_j\\wedge A\\in N\\implies\\text{ACTION}[i,A]\\leftarrow gj\n[k:A\\to\\alpha\\cdot]\\in I_i\\wedge A\\neq S&#039;\\implies\\forall t\\in T\\cup\\{\\$\\}.\\text{ACTION}[i,t]=rk\n[S^{\\prime}\\to S\\cdot]\\in I_i\\implies\\text{ACTION}[i,\\$]\\leftarrow acc\nLR0分析，自动机是本质，栈是实现\nLR0的0指的是规约时不需要向前看，无脑规约\nSLR(1) simple\n[k:A\\to\\alpha{:}]\\in I_i\\wedge A\\neq S^{\\prime}\\implies\\forall t\\in\\text{Follow}(A).\\text{ACTION}[i,t]=rk\nLR(1) SLR相较于LR(1)可能算是比较静态的\nLR(1)项中新增一个记录当前句柄之后的符号的\n[A\\to\\alpha\\cdot,a]\n只有下一个输入符号为a时，才可以规约\n[A\\to\\alpha\\cdot\\beta,{a}]\\quad(a\\in T\\cup\\{S\\})\n期望剩余输入的开头可以由βa推导出（要写a是因为β可能可以推出ε）\n（只有）闭包规则的修改如下：\n[A\\to\\alpha\\cdot B\\beta,a]\\in I\\quad(a\\in T\\cup\\{\\$\\})\n\\forall b\\in\\text{FIRST}(\\beta a).[B\\to\\cdot\\gamma,b]\\in I\n初始状态为\n\\mathrm{CLOSURE}([S^{\\prime}\\to\\cdot S,{\\$}])\nLR(1)缺点是产生的状态数太多了（相当于将每个LR0项又细分开）\nLALR(1)将具有相同LR(0)项的状态合并（合并方法：先从没有出边的开始）\n得到状态数和SLR(1)相当的自动机，能力介于SLR(1)和LR(1)之间\n可以证明LALR(1)的改造不会引进规约/移入冲突\n存在方法可以直接构造LALR(1)而不是从LR(1)改造"},"Daily/2023-11-06":{"title":"2023-11-06","links":[],"tags":[],"content":"柯里化\n构造g(x)(y)=f(x,y)\n&gt;&gt;&gt; def curry2(f):\n        &quot;&quot;&quot;返回给定的双参数函数的柯里化版本&quot;&quot;&quot;\n        def g(x):\n            def h(y):\n                return f(x, y)\n            return h\n        return g\n&gt;&gt;&gt; def uncurry2(g):\n        &quot;&quot;&quot;返回给定的柯里化函数的双参数版本&quot;&quot;&quot;\n        def f(x, y):\n            return g(x)(y)\n        return f\n&gt;&gt;&gt; pow_curried = curry2(pow)\n&gt;&gt;&gt; pow_curried(2)(5)\n32\npython中函数在调用时可以使用其定义时所在frame上的信息\n分数维\n对于一个“长度”为L的n维图形\n“长度”缩放s倍，相当于“质量”缩放s^n倍\n对于二维，正方形被切成四个小正方形\n对于sierpinski三角形，二分之一的“长度”的图形“质量”变成三分之一，由此可以推导出维度"},"Daily/2023-11-08":{"title":"2023-11-08","links":[],"tags":[],"content":"页表保存在内存中，有一个寄存器SATP(riscv)指示页表的地址，进而MMU去该位置获取页表\n地址空间\n地址空间的概念使得一个进程完全不具备引用另一个进程（不属于他自己）的内存地址\n强隔离性\n页表是地址空间的一种实现方式，页表硬件上通过MMU实现"},"Daily/2023-11-13":{"title":"2023-11-13","links":[],"tags":[],"content":"Bezier曲线，递归方法de Casteljau\n展开式"},"Daily/2023-11-14":{"title":"2023-11-14","links":[],"tags":[],"content":"局部状态\ndef creator():\n    state = 0\n    def action():\n        nonlocal state    #没有这行会报错\n        state = state + 1 #出现在左边的state表示要为当前frame绑定state，那右边的state怎么办，当前frame没有state\n        print(state)\n    return action\n一个叫约束连接的有趣例子\n\n将等式用图的形式表达，实现时，“用一个个组件拼接起来”\npython中的面向对象"},"Daily/2023-11-19":{"title":"2023-11-19","links":[],"tags":[],"content":"控制流语句翻译方案\n大致上分为两种 一种是教科书上的在布尔表达式中处理跳转，另一种是不在布尔表达式中（在布尔表达式所处的结构中）处理\n在布尔表达式处理中又介绍了两种做法，一种是类似java字节码（？），没有跳转符号，直接使用地址，另一种是使用符号\n为了实现使用符号的，在布尔表达式内部处理的，控制流语句翻译，需要在父节点中设计和摆放符号，传递给子节点。\n如果是使用地址的，那么需要在子节点中挖坑，并向父节点传递欠填的坑的集合，在有足够信息的父节点处填坑。(backpatch)\n读写文件\n已有常规做法是通过系统调用read,write\n可能更好的做法是通过内存映射文件，直接将虚拟地址对应到文件内容，少了很多系统调用的开销\nriscv中ecall做了三件事情\n\n切换模式\n保存pc到sepc\n跳转到stvec所指向的指令 xv6中跳转到trampoline\n其余的事情都没有做，提供了设计灵活性\n"},"Daily/2023-11-27":{"title":"2023-11-27","links":[],"tags":[],"content":"曾经使用过的网络方案\nn2n\n现在在使用zerotier\n可能可以尝试rathole\n几种利用page fault的性能优化机制\n应该都可以归类为lazy allocation\ndemand page 快速加载程序（的text和data）exec\nzero fill demand 快速分配空白页\ncopy on write 快速fork\ndynamic analysis\n只能抓出在特定输入上出现的problematic behavior\n工具valgrind\n替换malloc为它的实现，并在读写内存时添加一些记录检查代码，可以检查是否读写了超出堆空间的内存\n优点是泛用性很强，因为不需要拿到源码\n缺点是二进制文件中信息量太少（比如栈上具体怎么将内存划给变量）\nllvm sanitizer\n更进了一步，从源码分析\n可以做到变量级，如数组出界\n提供了很多sanitizer\nfuzzing\n模糊测试，构造大量测试用例，变异\n\nstatic analysis\nlint\n一种编码规范，不等同于程序broke\ndataflow analysis\n追踪所有程序执行路径上数据的变化，可以做到检查是否正确释放资源等\n可能会错误警示一些不可能走到的路径\n适合单文件，多文件可能会unwieldy\nCool let’s sanitize/tidy all the code!🔨💯"},"Daily/2023-11-28":{"title":"2023-11-28","links":[],"tags":[],"content":"xv6设计\n一个进程只有三种状态，在用户空间运行，或者在内核空间运行，或者不运行（可以理解为两个线程？）\nspinlock要处理两个事\n一个是cpu与cpu之间的并行\n一个是1个cpu上内核（这里特指中断程序）和用户之间的并行，关中断\n设备驱动分为两块\ntop部分 read/write接口\nbottom部分 中断处理程序\n这两个部分可以并行，需要锁来保护"},"Daily/2023-12-01":{"title":"2023-12-01","links":[],"tags":[],"content":"cs110l学习记录\n列举了c语言使用的一些常见问题，反复释放，悬空指针，内存泄漏，use-after-free\n展示了一些c语言项目的做法\n通过注释的形式约定谁负责管理内存，维护pre/postcondition\nc语言表达能力/类型系统太弱，不能表达所有者\n然后是rust语言能在语言层面提供这种所有权的支持\n变量名是主人，等式右侧是内存对象\n一个主人持有一个对象的语义是要对该对象的内存管理负责\n一个值有且只有一个主人，主人销毁值销毁\nrust中的两种trait\ncopy trait 复制堆上的内容\n对于int32这种只在栈上的数据，浅拷贝相当于深拷贝\ndrop trait 转移持有者\n如果有copy trait就不允许使用drop trait\nrust中所有变量默认immutable（包括下述的引用类型）\n引用类型\n变量只能同时有多个不可变引用类型或者一个可变引用类型\n因此：\n当存在一个可变引用类型时，原变量暂时不可用\n当只有不可变引用类型时，原变量暂时不可变\nfn main() { \n\tlet mut v = vec![1, 2, 3]; \n\t/* This for loop borrows the vector above to do its work. */ \n\tfor i in &amp;mut v { \n\t\tprintln!(&quot;{}&quot;, i); \n\t\tv.push(34); /* can cause resize -&gt; moving in memory! */ \n\t} \n}\n分别在for循环和push处两次可变引用\nC语言错误处理的两个问题\n太容易miss错误\n错误处理代码太verbose，如传播错误\nrust使用enum+match保证对错误必须处理，?简化错误传播\nCS 245, CS 244B, CS149"},"Daily/2023-12-05":{"title":"2023-12-05","links":[],"tags":[],"content":"xv6中编译后还额外提供了.d文件\n作用是描述一个c代码的头文件依赖情况\n只需要给gcc添加一个编译选项\n因为在makefile里没法追踪一个c代码文件中头文件的改动，为此打的一个小补丁"},"Daily/2023-12-19":{"title":"2023-12-19","links":[],"tags":[],"content":"读写锁\n对于读者的访问，需要保证没有写者存在，保证的方式是第一个读者进入时取得写锁，最后一个读者退出时交还写锁\n对于读者数的计数，需要另一个锁来保证互斥访问\nGAMES101 光线追踪\n和光栅化部分的区别？\n光栅化部分缺少全局光照信息，还需要做深度测试\n光线追踪的基本idea\n相机是一个点，面对着一个屏幕，相机对屏幕上每个点发射一条观察光线，沿着方向打到最近的物体上，再从物体上的碰撞点连线光源，判断光照\n因此，也就有了我们需要关心的一个话题，如何用光线和隐式曲面，显式曲面求交，如何高效求交（空间划分，物体划分）"},"Daily/2023-12-20":{"title":"2023-12-20","links":[],"tags":[],"content":"有一种硬拖成两天的笔记记的美\n辐射度量学\n首先要对这几个物理量在生活中可能的对应有个概念\n\nirradience 不带方向的\n渲染方程\nL_{o}(p,\\omega_{o})=L_{e}(p,\\omega_{o})+\\int_{\\Omega^{+}}L_{i}(p,\\omega_{i})f_{r}(p,\\omega_{i},\\omega_{o})(n\\cdot\\omega_{i})\\mathrm{d}\\omega_{i}\n其中积分域限制了只求解半球面（从内部射入的光线不应该被考虑）\nLe刻画了物体自己发光的radience\nf_r是双向分布函数brdf\n刻画了能量在不同方向上的分布\n从radience到irradience\nwhitted style的几个缺陷\n只有镜面反射，没有全局光照（color bleeding现象）"},"Daily/2023-12-23":{"title":"2023-12-23","links":[],"tags":[],"content":"什么是可执行文件\n一个数据结构，描述了状态机初始状态和迁移\n\n\n                  \n                  动手 \n                  \n                \n\n试着使用strace观察（可执行）文件的执行\nexecve在以下各种情况的返回值（在文档中均有描述）\n1.没有执行权限的文件\n2.非可执行文件\n3.设备\n\n\nexecve的interpreter script\nshebang的语法是#!\n个人猜测可能类似vim中!的用途\n通过编写一个打印所有参数的程序，可以验证shebang的行为似乎就是替换execve参数实现\n\n\n                  \n                  Warning\n                  \n                \n\n./a.out arg1 arg2\narg数组长度为3\nshell脚本中@长度不包括参数0脚本文件名，但是0为文件名。python中arg数组从文件名开始\n\n\nbinutils\n数据结构的查看/操作工具\n什么是编译器\n将C状态（语句 stackframe）\n翻译成机器视角（指令 内存 寄存器）以及debug info\ndebug info用来做反向的过程，可以从机器的某个运行状态回推当前对应的代码，但是并不太好做\nstack unwinding\n似乎说的就是打印某个时刻函数调用栈的信息\n在xv6中做过，通过栈上的返回地址不断回跳\njyy这里做的更巧妙，使用了链表来描述这个过程\n增加了O2优化之后，这个方法就不行了，但是gdb仍然一定程度上能做到 👍\n重定位（Relocation）\n完成那些之前不能确定的（即引用外部的？）符号的引用处的地址的填写\n需要满足assertion\n0xa hello(); // callq 5个字节\n0xf 某个语句;\nassert( (char *)hello == \n\t\t(char *)main + 0xf + // call hello 的 next PC \n\t\t*(int32_t *)((uintptr_t)main + 0xb) // call 指令中的 offset );\n应该是因为x86指令集的跳转约定是跳到下条指令加上offset的地址，offset是我们要填的东西\n理解了这段就可以理解elf中的约定\nOffset       Type           Sym. Name + Addend \n00000000000b R_X86_64_PLT32 hello - 4\n将S+A-P填入\nP是要填入的起始位置（main+0xb）\nS是调用的函数\nA是-4，应该是要填入的位置的末尾到开头的偏移？\nP17的其他内容\n进程初始化时候内存设置的spec\nrsp指向存放arg的内存位置…\n两个loader的实现简述\n动态链接\n将应用程序打散\n主要是运用了这个机制\ncall *func(%rip)\n目前的合理理解是func是符号，func这个位置存放了所需的函数的绝对地址\n在export的func中存放了func相对于dl文件头的偏移，加上实际加载到内存空间后的首地址就得到了func函数的实际地址\nfunc(%rip)计算func这个标志的位置相对于rip的偏移量，反正call能跳转到func标志中指向的函数\nvoid Tsum() {\n  for (int i = 0; i &lt; N; i++) {\n    int t = load(sum);\n    t += 1; \n    store(sum, t);\n  }\n}\n假设每行语句原子\n对于多个线程执行该程序的最小可能sum结果为2\n我的目前理解是\n一个线程读到t=sum=0，t++，然后让另一个线程执行到最后一轮，再让前一个线程保存sum=1，让另一个线程读t=sum=1，t++，然后直到所有线程结束再写回，得到2\np15的其他内容\nvsc，np complete问题，3sat\n文件描述符fork和dup时共享偏移量，并且操作是原子的\nxv6中做过的cow\n\n\n                  \n                  fork的几个用处 \n                  \n                \n\n并行搜索\n快速回溯 也可以backtrack的时候一下子往回跳到某个状态而不是一步步\n状态复用 fork一份完成了初始化的系统（nemu，android）\n容错试错 如果某个错误只有极小概率触发呢？\n\n\na fork in the road\n随着系统加入更多东西，fork越来越复杂"},"Daily/2023-12-28":{"title":"2023-12-28","links":[],"tags":[],"content":"direct initialization\n自动进行窄化，不会类型检查\nuniform initialization\n大括号，进行类型检查 安全\n各种类型都可以用这种语法\nstd::optional\nnullopt"},"Daily/2024-01-06":{"title":"2024-01-06","links":[],"tags":[],"content":"lec6 lec7\nrust是和c/c++一样的explicit memory management的语言\n讲了GC\n讲了rust实现链表\nbox\n类似c++中的uniqueptr\nlec8\ntrait 用来实现rust的面向对象（？）\n可插入现有结构的代码段（其中可以含有对self的引用）\n不需要完全定义（可以像java接口）\n避免了像c++那样完全地从父类继承，形成一个复杂的依赖层次结构，一发动全身\n几种需要知道的trait\ncopy 实现了之后赋值时不再转移所有权 而是复制一份\nclone\ndrop 如何释放内存，抵达作用域末尾时调用\ndisplay println!时的样式\ndebug 同display 用于debug\neq equality for two objects of the same type\npartialord instances比大小"},"Daily/2024-01-07":{"title":"2024-01-07","links":[],"tags":[],"content":"讲了一种同时使用线程和进程时的bug\nfork时在新进程中只会含有执行fork的那一个线程\n想象这样一个场景，一个进程中有一个线程准备fork，另一个线程持有了malloc锁，fork之后新进程中再也拿不到malloc锁\n我们可以确保自己写的代码中没有任何多的线程，但是库函数怎么办\n因此实战中我们不应该混合使用多进程和线程（除非是立马exec的）\n为了多进程，应该分到多个可执行文件中，使用exec（可以重置虚存）\nfork和exec的组合机制带来了很多flexibility，但是带来了更多出错机会\n考虑将我们的常用场景封装起来（高级语言已经这么做了 ）"},"Daily/2024-01-09":{"title":"2024-01-09","links":[],"tags":[],"content":"线程这种计算模型抛弃了可预测性，可理解性和确定性，程序员要做的事情是修剪不确定性\n一台四核的机器上可以有四个硬件线程（同时执行）\n但可以有100个软件线程（从其中选到硬件线程上去）"},"Daily/2024-01-18":{"title":"2024-01-20","links":[],"tags":[],"content":"减少dependencies\n// breaks when adding a register\n#define NREG 5 // 隐藏假设 max{RA, RB, ... PC} == (NREG - 1)\n// breaks when changing register size\n#define NREG (sizeof(R) / sizeof(u8)) // 隐藏假设寄存器是 8-bit\n// never breaks\n#define NREG (sizeof(R) / sizeof(R[0])) // 但需要 R 的定义\n// even better (why?)\nenum { RA, ... , PC, NREG }\n预处理显示\ngcc -E test.c | indent - | vim "},"Daily/2024-01-20":{"title":"2024-01-20","links":[],"tags":[],"content":"git\n其中两个重要概念 对象和引用\n文件blob，文件夹tree，和提交commit都是对象\n对象使用哈希引用 可能imply了对象是不可变的\n引用是映射到哈希的可读名字\n引用是可变的\n常见的引用有master 主分支的最新commit\nhead当前观察的commit\ngit diff将当前目录的内容和head作比较\ngit branch -f\n强制将一个分支移动到指定位置\ngit merge\n在当前分支创建一个新节点，它同时指向指定分支和当前分支的节点\n推进当前分支\ngit rebase\n将当前分支移动到指定分支的后继\ngit checkout\nhead一般是和当前分支的最新提交指在一起的\n通过checkout某次提交可以改变head\ngit reset和git revert后跟提交\nvendorig\n限制死项目的依赖使用的版本\nCI(continuous integration)\ngithub action\n在收到pull request时自动进行测试\n提交时进行语法检查\ngithub仓库上可以看到的小徽章\ngithub pages自动构建博客\ntestsuite\n所有测试的集合\nunit test\n测试功能模块\nintegration test\n测试功能模块组合能否正确工作\nregression test\n测试过去的错误\nmocking\n忽略一部分不需要关注的部分\n替换成虚拟实现"},"Daily/2024-02-08":{"title":"2024-02-08","links":[],"tags":["example-tag"],"content":"阻碍编译器优化的因素\n内存别名\n无法确定指针是否是指向同一个内存地址的\n函数调用\n无法确认函数是不是有副作用的\n感觉是建议多写一些中间变量\n直接上O3\n秦九韶算法未必比常规多项式计算方法快\n问题在于其关键路径更长\n这里的关键路径还没怎么理解"},"Daily/2024-02-10":{"title":"2024-02-10","links":["Daily/2023-12-23"],"tags":["C"],"content":"GCC\n注意区分gnu c和ansi/iso c\ngcc使用时需要指定头文件搜索路径，链接库的搜索路径和库名\n运行得到的可执行文件时，通过LD_LIBRARY_PATH搜索动态库文件\nldconfig负责从/etc/ld.so.conf.d/*.conf更新库搜索路径\n为了使用自己的动态库，要么修改环境变量，要么（在可选地编辑conf后）需要运行ldconfig\nELF格式承载了两个用途\n可执行文件和可重定位文件\n在可执行文件中，注重程序段（程序段应该是从节“组成”出来的）的概念\n在可重定位文件中，注重节的概念\n.bss这种节（存放了已声明未初始化的全局变量）中的变量不需要初始化，因此会出现程序段的段大小memsz大于filesz的情况\n\n\n这里03段包含08段，重定位修改后，08段权限会变，因此出现进程地址空间中段数目和elf中load类型段数目不同的情况\n所有节名都存放在shstrtab中，每个节中只存放其节名在shstrtab中的索引\nnot stripped符号表未抽离\n需要在节中记录的有两个\n代码\n全局变量（分为有定义和没有定义的）（也包含static局部变量）\n对于本模块内的符号，只需要重定位\n对于模块外定义的符号，需要先进行跨模块的符号解析再重定位\n重定位表\n或者说是重定位段\n对每个需要重定位的段都有一个对应的重定位表\n如.text对应.rela.text\n重定位表中每个entry代表一个符号的引用，记录了该引用（相对于它所在的段的）偏移，类型和在符号表中的对应。\n符号表\n.symtab节\n符号的定义\n其中每个符号的名字存储的是.strtab节的下标\n其中UND类型是未解析，即需要寻找定义的\nnm工具也可以用来看符号表\n静态链接\n（如果不存在外部符号）可重定位文件缺少操作系统提供的初始化代码和返回到系统的代码，并且每个节都欠重定位（每个节都从0开始）。仍然是不能“用”的\n一般地，链接=布局+符号解析+重定位\n布局\n综合所有目标文件的节加上启动和结束代码的节，合并相同属性的节\n得到代码和数据的地址\n符号解析\n处理UND符号\n重定位\n静态库是目标文件的集合（不再是ELF了？），静态链接时抽取其中必要的目标文件\n动态链接\n链接时需要动态库，但不会将动态库的代码和数据包含进可执行文件\n运行时需要动态库，这时载入动态库代码和数据到进程空间，并进行重定位\n延迟了重定位操作到装入阶段\n动态库中已经形成了“布局”\nPIC position independent code\n~~动态库中所有数据地址和跳转地址都是PC相对的  ~~\n数据的相对跳转的实现是通过GOT表这个中介间接访问\n需要为动态库中的全局变量在可执行文件的.bss中分配空间，因为动态库的全局变量不跨进程共享，在动态库的.data和.bss中存了初值\n函数的相对跳转是先转移到函数的plt版本（称为trampoline）动态，根据got表中内容\n重定位前（由于got表这么规定，只是跳转到了下一行）是push plt下标到栈里，然后跳转到公共入口\n重定位后能根据got表直接跳转到那个函数\n.rela.dyn是数据动态重定位表，.rel.plt函数\n.got是数据GOT表，.got.plt函数\n动态链接和静态链接下，数据重定位表的区别是前者存放GOT表项地址，后者存放引用的指令地址\n加载器加载动态链接的可执行文件\n可执行文件中.interp节指定了动态链接器的路径，由它来操作\n表达式的“值类别”（value category）和“值类型”（value type）\n前者指的是左值、右值，后者则是与引用类型（reference type）相对而言，表明一个变量是代表实际数值，还是引用另外一个数值。在C++里，所有的原生类型、枚举、结构、联合、类都代表值类型，只有引用和指针才是引用类型。在 Java 里，数字等原生类型是值类型，类则属于引用类型。在Python 里，一切类型都是引用类型。\n\n赋值函数重载\n支持左/右值\n支持a=a\n“拷贝并交换”惯常做法\nsmart_ptr&amp;\noperator=(smart_ptr rhs) noexcept\n{\nrhs.swap(*this);\nreturn *this;\n}\n引用折叠\n对于template &lt;typename T&gt; foo(T&amp;&amp;) 这样的代码\n如果传递过去的参数是左值，T 的推导结果是左值引用；如果传递过去的参数是右值，T 的推导结果是参数的类型本身。\n如果 T 是左值引用，那 T&amp;&amp; 的结果仍然是左值引用——即 type&amp; &amp;&amp; 坍缩成了type&amp;。\n如果 T 是一个实际类型，那 T&amp;&amp; 的结果自然就是一个右值引用。\nT&amp;&amp;保持了值类型，万能引用/转发引用\n为了保持值类型不变，可以使用std::forward\n使用auto推断类型需要自己决定使用值类型还是引用类型\ndecltype(auto)可以直接转发？"},"Daily/2024-02-12":{"title":"2024-02-12","links":[],"tags":[],"content":"coredump\ncore文件也是elf格式\n记录了崩溃进程的影像\n打桩方法\n源码级\n静态链接替换\n需要目标文件\n运行加载时替换\nLD_PRELOAD替换动态库实现\nLINUX GNU C程序观察这本书给出了一个篡改hadoop hdfs对zlib库调用的例子\n很多编程语言都遵守c的abi\n使用checkinstall而不是make install"},"Daily/2024-02-13":{"title":"2024-02-13","links":[],"tags":[],"content":"react\n组件（一块块html）式的\n组件的状态和状态更新通过useState声明，状态更新导致重新绘制组件，但不会再应用useState的初始值。\n\n\n                  \n                  Notes\n                  \n                \n\nReact的一个最佳做法是在组件层次结构中将状态提升。\n通常，几个组件需要反映相同的变化数据。我们建议将共享状态提升到它们最接近的共同祖先。\n这样更新父节点的时候自动更新子节点。\n\n\n坏消息是好像像输入框这种元素的值都得自己创建一个状态来维护\nreact中的jsx（？）的编写时是函数式的，经常涉及不可变的？"},"Daily/2024-02-15":{"title":"2024-02-15","links":[],"tags":[],"content":"感觉15-445的实验贯彻了这样一件事\n在p0中将不支持并发的trie包装成支持并发的trie\n在p2中将需要手动unpin的bpm包装成自动管理的"},"Daily/2024-02-26":{"title":"2024-02-26","links":[],"tags":[],"content":"值类别\n左值\n右值\n亡值 有身份 可被移动（如static cast的返回值，声明为返回右值引用的函数的返回值）\n主要看有没有身份吧\n引用所表达的语义和指针不同的在于，不存在空引用，引用不能更改绑定\n引用是对象的别名，必然是左值\n在c++11之前，只有non-cast rvalue reference无法被捕获，无法实现move语义\n故引入右值引用\n左值不能匹配到右值引用参数，否则左值资源会被偷走\n右值可以匹配常左值引用参数\n右值引用只能由右值初始化\n引用拓宽了生命期\n值类型\n值，引用（引用，指针）"},"Daily/2024-03-21":{"title":"2024-03-21","links":[],"tags":[],"content":"子网内部一跳可达\n转发表\n目标子网ip，子网掩码，下一跳（具体跳到的路由器/主机的ip），端口\ndhcp第二次握手时确认（可能同时存在多个dhcp server）\nnat穿透\n解决外部不能主动和内网设备通信\n中间服务器\nupnp\n链路状态算法和距离矢量算法比较\n健壮性\n收敛速度\n信息传递量"},"Daily/2024-07-24":{"title":"2024-07-24","links":[],"tags":["example-tag"],"content":"debug &amp; release\nAdd -ggdb to the command line when debugging and -O2 -DNDEBUG for release builds. Use the former for now.\nwarning levels\nAdd the following flags to your command line: -Wall -Weffc++ -Wextra -Wconversion -Wsign-conversion\nwarning2error\nAdd the following flag to your command line: -Werror\ncompile vs interpret\ncompilation - Difference between compiled and interpreted languages? - Stack Overflow\n常量表达式由编译期常量和可编译期计算的函数组成，不属于常量表达式的就是运行时表达式\n编译期常量有\n\nLiterals (e.g. ‘5’, ‘1.2’)\nConstexpr variables (we discuss these shortly in lesson 5.5 — Constexpr variables)\nConst integral variables with a constant expression initializer (e.g. const int x { 5 };). This is a historical exception — in modern C++, constexpr variables are preferred.\nNon-type template parameters (see 11.10 — Non-type template parameters).\nEnumerators (see 13.2 — Unscoped enumerations).\n\n不属于编译期常量的常量是运行期常量\n通过const声明编译期常量的两个缺点\n\n不能直观判断是哪种常量\n不支持非整型\n因此需要使用constexpr，它要求用常量表达式来初始化（否则引发编译错误），保证是编译期常量\n对于std::string和std::vector声明constexpr，需要对应改为支持constexpr的std::stringview和std::array\n对于普通的函数，不能声明constexpr参数，const参数被视作运行时常量\n\nIn modern C++, the term inline has evolved to mean “multiple definitions are allowed”. Thus, an inline function is one that is allowed to be defined in multiple translation units (without violating the ODR).\n但是编译器要求必须在每个使用该声明的单元给出实现且实现必须相同\n建议在头文件实现inline函数\ninline variables\nA constant expression (which may contain constexpr function calls) is only required to evaluate at compile-time in contexts where a constant expression is required.\nAlways test your constexpr functions in a context that requires a constant expression, as the constexpr function may work when evaluated at runtime but fail when evaluated at compile-time.\nconstexpr函数的参数不是constexpr的，constexpr函数暗示inline，而constexpr变量并不默认暗示inline\nRule\nThe compiler must be able to see the full definition of a constexpr (or consteval) function, not just a forward declaration.\nBest practice\nConstexpr/consteval functions used in a single source file (.cpp) can be defined in the source file above where they are used.\nConstexpr/consteval functions used in multiple source files should be defined in a header file so they can be included into each source file.\n转换stringview到string，有一定开销\nstatic_cast\n对于const string&amp;，只有传入string时开销较小，传入stringview和字符串字面量时都有一定开销\n而stringview开销始终不大\nPrefer passing strings using std::string_view (by value) instead of const std::string&amp;, unless your function calls other functions that require C-style strings or std::string parameters.\n使用viewer的条件，viewer期间不修改或者销毁观察对象（未定义行为，或者可以理解为观察对象的修改和销毁会使得相关view无效），view不能修改观察对象\n小心不要用string字面量(&quot;&quot;s)来初始化stringview，因为stringview只是viewer，不能保持这个临时对象的存活\n可以安全返回stringview的两种情况\n1.使用c字符串，生存周期为整个程序\n2.来自stringview参数（又有需要注意的是，谨慎使用临时对象构造stringview\nThere is one important subtlety here. If the argument is a temporary object (that will be destroyed at the end of the full expression containing the function call), the std::string_view return value must be used in the same expression. After that point, the temporary is destroyed and the std::string_view is left dangling.）\nstringview视图自身可以修改\nz = (a, b); // evaluate (a, b) first to get result of b, then assign that value to variable z.\nz = a, b; // evaluates as &quot;(z = a), b&quot;, so z gets assigned the value of a, and b is evaluated and discarded.\ninternal linkage\n可见性为编译单元内，同名标识符独立，不违反ODR\nstatic int g_x{}; // non-constant globals have external linkage by default, but can be given internal linkage via the static keyword\n// same for functions\n \nconst int g_y{ 1 }; // const globals have internal linkage by default\nconstexpr int g_z{ 2 }; // constexpr globals have internal linkage by default\ninline变量是external linkage\nscope，duration和lifetime，linkage\nduration和lifetime有点难区分\nstatic\n全局变量，static函数/类变量\nautomatic\n块作用域\ndynamic\nthread\n线程创建到退出\n生命周期\n开始when the storage with proper alignment and size is allocated and the object is initialized\n结束when it’s detroyed, or the dtor is called, or its storage is released or reused by non-nested object\nplacement new+手动析构函数\n用相同类型placement new后，原来的name，指针和引用仍然有效\n注意const对象\ntrivial dtor\na class has a trivial dtor if\n\ndtor implicitly declared(就是没写？) or =default\nnon-virtual dtor and 所有非静态成员有trivial dtor\n\n通过lifetime，可以做指针相关优化strict aliasing\nscope针对标识符，指的是可见和可用\nduration针对变量，指的是创建和销毁时间\nlinkage决定同名标识符是否指向相同的对象 linkage 是控制链接时候符号可见性的\nlocal变量是no linkage的，意味着和其他同名的标识符独立\n如static local变量具有static duration和block scope\nStatic local variables that are zero initialized or have a constexpr initializer can be initialized at program start.\nStatic local variables that have no initializer or a non-constexpr initializer are zero-initialized at program start. Static local variables with a non-constexpr initializer are reinitialized the first time the variable definition is encountered.之后不再初始化\nanything declared inside an inline namespace is considered part of the parent namespace. However, unlike unnamed namespaces, inline namespaces don’t affect linkage.\nstd::exit()\nstd::exit is called implicitly when main() returns.\n使得一个程序正常退出，可以设置非0状态码\nstd::exit不会清理任何local变量，如果程序行为依赖local变量析构会导致问题（如文件句柄泄漏）\natexit可以注册清理函数\n模版是odr的特例，模版生成的函数是implictly inline的，所以也不违反odr\n模版参数推断不会进行类型转换，只有解析函数重载时会进行\n\nLvalue expressions are those that evaluate to variables or other identifiable objects that persist beyond the end of the expression.\nRvalue expressions are those that evaluate to literals or values returned by functions/operators that are discarded at the end of the expression.\n左值又可分为是否可修改的，影响是否能左值引用\nWhen a const lvalue reference is directly bound to a temporary object, the lifetime of the temporary object is extended to match the lifetime of the reference.\n"},"Daily/2024-07-25":{"title":"2024-07-25","links":[],"tags":["example-tag"],"content":"type deduction\n先去除引用，再去除此时可能存在的top-level const\n#include &lt;string&gt;\nconst std::string&amp; getConstRef(); // some function that returns a const reference\n \nint main()\n{\n    auto ref1{ getConstRef() };        // std::string (reference and top-level const dropped)\n    const auto ref2{ getConstRef() };  // const std::string (reference dropped, const reapplied)\n \n    auto&amp; ref3{ getConstRef() };       // const std::string&amp; (reference reapplied, low-level const not dropped)\n    const auto&amp; ref4{ getConstRef() }; // const std::string&amp; (reference reapplied, low-level const not dropped)\n \n    return 0;\n}"},"Daily/2024-07-26":{"title":"2024-07-26","links":[],"tags":["example-tag"],"content":"std::optional语法上和指针类似\n但是std::optional是值语义，指针是引用语义\nc++目前不能对引用包装std::optional，所以需要考虑值语义的复制开销或者使用reference_wrapper\nenum的underlying type\n默认实现定义，但也可以自己指定\nas of C++17, if an unscoped enumeration has an explicitly specified base, then the compiler will allow you to list initialize an unscoped enumeration using an integral value\nunscoped enumeration会污染命名空间，不同enumeration可能会被隐式转换成underlying type来进行比较，这语义上不太合理，也没有简单办法避免\nscoped enumeration不会被隐式转换成underlying type"},"Daily/2024-07-30":{"title":"2024-07-30","links":[],"tags":["example-tag"],"content":"argument 实参\nCTAD 类模版实参推导\nvoid print(std::pair p) // compile error, CTAD can&#039;t be used here\nparameter 形参\nfunction parameter 函数形参"},"Daily/2024-07-31":{"title":"2024-07-31","links":[],"tags":["example-tag"],"content":"成员初始化\n优先初始化器列表，其次默认初始化器，最后默认初始化（对于原始类型就是未初始化）\n构造函数体在初始化器列表之后执行\n如果没有任何用户声明的构造函数，会生成默认构造函数，它可以被视作是无参数，无初始化器列表，体内为空。但生成的默认构造函数和手动编写的空构造函数仍然有细微区别：\n\nC++20之前explicit默认构造函数不会使得类变成non-aggregate，C++20之后会了\n\nint a;         // no initializer (default initialization)\nint b = 5;     // initializer after equals sign (copy initialization)\nint c( 6 );    // initializer in parentheses (direct initialization)\n \n// List initialization methods (C++11)\nint d { 7 };   // initializer in braces (direct list initialization)\nint e = { 8 }; // initializer in braces after equals sign (copy list initialization)\nint f {};      // initializer is empty braces (value initialization)\n \n// Calls Foo() default constructor\nFoo f1;           // default initialization\nFoo f2{};         // value initialization (preferred)\n \n// Calls foo(int) normal constructor\nFoo f3 = 3;       // copy initialization (non-explicit constructors only)\nFoo f4(4);        // direct initialization\nFoo f5{ 5 };      // direct list initialization (preferred)\nFoo f6 = { 6 };   // copy list initialization (non-explicit constructors only)\n \n// Calls foo(const Foo&amp;) copy constructor\nFoo f7 = f3;      // copy initialization\nFoo f8(f3);       // direct initialization\nFoo f9{ f3 };     // direct list initialization (preferred)\nFoo f10 = { f3 }; // copy list initialization\nThere are three key differences between the initialization forms:\n\nList initialization disallows narrowing conversions.\nCopy initialization only considers non-explicit constructors/conversion functions.\nList initialization prioritizes matching list constructors over other matching constructors.\n\ncopy elision\nas-if豁免，故复制构造函数不应当有副作用\nOnly one user-defined conversion may be applied\nprintEmployee(&quot;Joe&quot;); // we&#039;re supplying an string literal argument\n其中该函数接受Employee对象，Employee对象只能通过stringview初始化，该代码无法编译通过"},"Daily/2024-08-02":{"title":"2024-08-02","links":[],"tags":["example-tag"],"content":"右值对象返回引用较危险\n解决方法：ref-qualified\nconst std::string&amp; getName() const &amp;  { return m_name; } //  &amp; qualifier overloads function to match only lvalue implicit objects, returns by reference\nstd::string        getName() const &amp;&amp; { return m_name; } // &amp;&amp; qualifier overloads function to match only rvalue implicit objects, returns by value\n似乎如果只有const &amp;存在的情况下，左右值对象都会被匹配\n这一特性不推荐使用\nshared_ptr\nint main()\n{\n\tResource* res { new Resource };\n\tstd::shared_ptr&lt;Resource&gt; ptr1 { res };\n\t{\n\t\tstd::shared_ptr&lt;Resource&gt; ptr2 { res }; // create ptr2 directly from res (instead of ptr1)\n \n\t\tstd::cout &lt;&lt; &quot;Killing one shared pointer\\n&quot;;\n\t} // ptr2 goes out of scope here, and the allocated Resource is destroyed\n \n\tstd::cout &lt;&lt; &quot;Killing another shared pointer\\n&quot;;\n \n\treturn 0;\n} // ptr1 goes out of scope here, and the allocated Resource is destroyed again\nmake_shared相比手动构造，可以把对象的所需内存和控制块的内存一起分配，更高效异常安全？\nweak_ptr不参与shared_ptr的引用计数（observer），但是能访问到控制块计数，因此相比裸指针，weak_ptr有能力判断对象是否存在\n控制块中似乎也有weak计数，不然我感觉shared全部销毁之后，控制块也会销毁，weak_ptr没法判断控制块的存活"},"Daily/2024-08-12":{"title":"2024-08-12","links":[],"tags":[],"content":"地址无关\n解决绝对地址的重定位问题\nseparate code from data;\ngenerate code that doesn’t depend on where  it is loaded\n代码部分\n模块内引用函数\n相对跳转\n模块内引用数据\n和函数跳转不同（函数跳转天然相对当前pc）\n通过一个特殊的函数读取当前pc，加上偏移量来模仿相对寻址\ncall指令会将返回地址压到栈顶，esp指向栈顶，ecx是返回值\n00000494 &lt;__i686.get_pc_thunk.cx&gt;:\n 494: 8b 0c 24              mov    (%esp),%ecx\n 497: c3                    ret\n模块外部，查表，间接跳转\n表的位置是固定的\nlazybinding使用plt解决模块外部函数引用问题\n数据部分还存在绝对地址引用，比如指针变量。"},"Daily/2024-08-14":{"title":"2024-08-14","links":[],"tags":["example-tag"],"content":"何时使用protected\n使用protected使得子类可以直接访问父类成员，意味着如果你对protected成员作修改，你可能要修改父类和所有子类\n使用private意味着对实现细节的封装\n一般只需要使用public inherit\n在子类redefine函数时，access modifier只取决于子类中这个函数的modifier，与父类中的无关\nOverload resolution\nclass Base\n{\npublic:\n    void print(int)    { std::cout &lt;&lt; &quot;Base::print(int)\\n&quot;; }\n    void print(double) { std::cout &lt;&lt; &quot;Base::print(double)\\n&quot;; }\n};\n \nclass Derived: public Base\n{\npublic:\n    void print(double) { std::cout &lt;&lt; &quot;Derived::print(double)&quot;; } // this function added\n};\nderived.print(1)会匹配到derive中的print，为了改变这一行为，推荐在derive中使用using引入base的print(int)\nusing还会根据他自己在哪个access modifier修饰下，改变引入函数的modifier，并且不难认为using会将所有该函数的重载的modifier都修改\nAccess controls are not enforced at runtime.\nclass A{\npublic: virtual void fun()\n};\n \nclass B : public A{\nprivate: virtual void fun()\n};\n \nint main()\n{\n    B b {};\n    b.fun();                  // compile error: not allowed as B::fun() is private\n    static_cast&lt;A&amp;&gt;(b).fun(); // okay: A::fun() is public, resolves to private B::fun() at runtime\n}\nmixin\nmixin是用来被继承，在继承它的类中增加一些属性的。mixin的名字表达了他不应该instantiated on its own\nmixin通常不使用虚函数而使用模版\nCuriously Recurring Template Pattern\n一个类继承一个模版类，使用他自己作为模版参数\ntemplate&lt;class Z&gt;\nclass Y {};\nclass X : public Y&lt;X&gt; {};\nDiamond Problem\n菱形继承\n虚函数\n使得函数总是解析到最derived版本\n使得基类指针和引用调用派生类函数\nIf a function is virtual, all matching overrides in derived classes are implicitly virtual.\nbecause the override specifier implies virtual, there’s no need to tag functions using the override specifier with the virtual keyword\n在基类中使用virtual，在子类中使用override即可\n编译期多态\n函数重载解析和模版解析\nearly binding/static binding\n编译期解析\n运行期多态\nlate binding/dynamic dispatch\n函数指针\n虚函数解析\ncovariant return types\n允许虚函数的返回指针/引用类型不同，是所override函数的子类\nvptr是最base的类的成员，是一个指向虚函数表的指针，它实际占用类的内存（和this不同）。\n纯虚函数也可以有定义，这仍然会对子类的定义有要求。这个定义可以被子类使用\n析构函数可以是纯虚的，但必须有定义\nvirtual base class\n使得菱形继承时共用基类且基类只被构造一次\nvirtual base class会先于所有non virtual的构造\nFrankenobject\nint main()\n{\n    Derived d1{ 5 };\n    Derived d2{ 6 };\n    Base&amp; b{ d2 };\n    b = d1; // this line is problematic\n    return 0;\n}\n由于拷贝构造函数不是虚函数，只复制了d1的base部分\nlinux堆空间分配系统调用brk和mmap\n运行库管理堆空间分配，避免频繁系统调用\nmalloc对小对象会在现有空间中直接寻找可分配的块，对大对象直接使用mmap\nWhich book is best for system programming (APUE vs TLPI)? : r/kernel (reddit.com)"},"Daily/2024-08-15":{"title":"2024-08-15","links":[],"tags":[],"content":"do {} while(0)宏\n通用的双向链表组件\nlinux虚拟的mmu管理单元\n三级页表\n如果具体架构只支持二级页表，也把它视作三级页表，保持页表相关代码的复用性（读取诸如pgd，pmd，pte字段的宏是架构定义的，但遍历整个页表的逻辑是可以复用的）\n没有用简单的整数类型表示pte这种，而是用结构体包装了一层，提供了一定的类型检查，能稍微防止你直接把pgd当pte用这种操作\n页表中存放的都是物理地址，不管是每一级页表都需要存放的是所谓下一级的页面地址，这个页面地址应该是页对齐的，但是低位也被拿来用了，保存属性。\nLinux分页机制之分页机制的实现详解—Linux内存管理(八) - yooooooo - 博客园 (cnblogs.com)\n对段式内存映射的架空\n通过配置段描述符，将虚拟地址保持不变映射为线性地址，线性地址再进行页式映射\n每个进程都有自己的页面目录PGD，mm_struct中保存了这个目录的指针"},"Daily/2024-08-16":{"title":"2024-08-16","links":[],"tags":["example-tag"],"content":"硬链接不允许对目录进行，因为可能会导致环（为某个文件夹的父文件夹 创建 一个名为 该文件夹的子文件夹的别名💥）"},"Daily/2024-09-09":{"title":"2024-09-09","links":[],"tags":["example-tag"],"content":"static_cast\n要求有conversion operator或者有转换构造函数\n通常prefer转换构造函数\n除非 转换到无法定义转换构造函数的类型\ndynamic_cast\n指针类型和引用类型downcast\ncoroutine&amp;thread\nmultithreading - Is there a difference between fibers, coroutines and green threads and if that is so what is it? - Software Engineering Stack Exchange\n\nA Fiber is a lightweight thread that uses cooperative multitasking instead of preemptive multitasking. A running fiber must explicitly “yield” to allow another fiber to run, which makes their implementation much easier than kernel or user threads.\nA Coroutine is a component that generalizes a subroutine to allow multiple entry points for suspending and resuming execution at certain locations. Unlike subroutines, coroutines can exit by calling other coroutines, which may later return to the point where they were invoked in the original coroutine.\nA Green Thread is a thread that is scheduled by a virtual machine (VM) instead of natively by the underlying operating system. Green threads emulate multithreaded environments without relying on any native OS capabilities, and they are managed in user space instead of kernel space, enabling them to work in environments that do not have native thread support.\nFibers and green threads both rely on a separate scheduler to select the next fiber or thread, but a fiber must explicitly cede control (yield) to its scheduler. A green thread will run until interrupted (“preempted”) by its scheduler.\nFibers and coroutines both involve “yielding” in which the fiber/coroutine decides when to relinquish control - this is cooperative multitasking. Whereas the fiber always yields to its scheduler, a coroutine decides for itself who to yield to.\nCoroutines can be used to implement fibers by always yielding to a scheduler coroutine. Fibers can be used to implement coroutines by allowing each fiber to communicate to the scheduler which fiber should be run when it yields.\n\narchitecture - Difference between a “coroutine” and a “thread”? - Stack Overflow\n\n\n                  \n                  tldr \n                  \n                \n\n在某些语境下，coroutine指代有栈的function，generator指代无栈的函数。\ncoroutine是并发的，不可能是并行的。\n\n"},"Daily/2024-09-11":{"title":"2024-09-11","links":[],"tags":["example-tag"],"content":"linux文件系统布局\n/bin 存放了必要的基本工具，如ls，cat。不依赖/usr的挂载\n/sbin 需要root的工具，如iptables\n/lib /bin和/sbin依赖的库\n/usr unix system resources\n/usr/local/bin 本地编译的程序\n/usr/lib /usr下的程序依赖的库 LD_LIBRARY_PATH\n/etc 配置\n/home /root 数据\n/var 日志和缓存\n/run socket/lock file"},"Daily/2024-09-13":{"title":"2024-09-13","links":[],"tags":["example-tag"],"content":"自制智能指针\n实现自动隐式转换\ntemplate &lt;typename U&gt;\nsmart_ptr(smart_ptr&lt;U&gt;&amp;&amp; other)\n{\n\tptr = other.release();\n}\n注意这个构造函数不被编译器视作移动构造函数，不触发删除拷贝构造函数\nshared_ptr需要维护一个计数块的指针\n调用了构造函数还是复制构造函数\n回归到它们的参数，那个引用上去\n右值引用绑定到右值，常左值引用绑定到左值\nstd::move表达式的值类别为xvalue，后续资料还没查到（只查到了prvalue绑定的preference），猜测是会被prefer绑定到右值引用版本\nprvalue绑定到引用上，有延长生命周期，但是xvalue没有\nresult&amp;&amp; r = std::move(return_rval()); //💥\n线程id只在所属的进程中有意义\n进程时间\n时钟时间\nwall clock time 真实世界的总运行时间，受系统中所有因素的影响\n用户时间 执行用户指令\n系统时间 执行系统服务\n用户时间+系统时间=CPU时间&lt;时钟时间\n进程控制系统调用（fork、exec 和 wait）通常由用户应用程序直接调用（请回忆图 1-7中的基本 shell）。但是为了简化某些常见的情况，UNIX 系统也提供了一些库函数，如 system和popen。\nmalloc不一样，是对sbrk的复杂封装\nO_SYNC 使每次write等待物理I/O操作完成，包括由该write操作引起的文件属性（如修改时间）更新所需的I/O。\nO_RSYNC 使每一个以文件描述符作为参数进行的read操作等待，直至所有对文件同一部分挂起的写操作都完成。\n由open和openat函数返回的文件描述符一定是最小的未用描述符数值。\nopenat函数是POSIX.1最新版本中新增的一类函数之一，希望解决两个问题。\n第一，让线程可以使用相对路径名打开目录中的文件，而不再只能打开当前工作目录。在第 11 章我们会看到，同一进程中的所有线程共享相同的当前工作目录，因此很难让同一进程的多个不同线程在同一时间工作在不同的目录中。\n第二，可以避免time-of-check-to-time-of-use（TOCTTOU）错误。\n\n\n                  \n                   at 系列函数的逻辑可以简化为：\n                  \n                \n\n\n如果路径是绝对路径，直接使用该路径。\n如果路径是相对路径：\n\n如果 dirfd 是 AT_FDCWD，则使用当前工作目录。\n否则，使用 dirfd 所指向的目录作为基准。\n\n\n\n\n\n原子操作\nopen O_EXCL | O_CREAT\n测试并打开，确保调用open的进程就是创建文件的进程\npread pwrite\n定位并读写\ndup和fcntl\n打开任一类型的文件时，对路径名中包含的每一个目录，包括它可能隐含的当前工作目录都应具有执行权限。这就是为什么对于目录其执行权限位常被称为搜索位的原因。\n在某个目录创建/删除文件时，都需要对目录有写和执行权限。\n标准IO库\n提供了流的抽象，配置了缓冲来减少read/write的调用。\n流可分为单字节和多字节的，可通过fwide查看，一旦设置完成除了freopen无法更改。\n流的缓冲形式\n1.全缓冲 磁盘文件\n2.行缓冲 终端\n3.不带缓冲 stderr\n可以在打开一个流，并在对他进行其他操作之前，使用setbuf系列函数重新设置缓冲类型。\nfgetc/fputc保证是一个函数，getc/putc可能是宏\n允许回送字符到缓冲区中，读入顺序与压回顺序相反\nc语言字符数组是在栈上的，字符串指针指向的字符串字符串常量是在只读区的。\nmkstemp会尝试修改字符串内容，如果使用的是字符串常量会segment fault。\n内存流\n没有底层文件\n匿名文件流 字符串流\nmalloc 初始值不确定\ncalloc 批量申请内存，保证全0\nrealloc 调整分配内存大小\nalloca可以在栈上申请内存，通过改变栈指针实现\n不要在函数参数列表中使用alloca\n不需要手动释放（栈空间的性质）"},"Daily/2024-09-23":{"title":"2024-09-23","links":[],"tags":["example-tag"],"content":"外壳函数和系统调用\n\n__GLIBC__``__GLIBC_MINOR__可以确认编译时的glibc版本\n函数gnu_get_libc_version()可以确认运行时的glibc版本\nopen中的flag参数分为三组\n文件访问模式（三选一）：读，写，读写\n状态标志：如O_SYNC\nioctl用来进行通用IO操作之外的特定操作\nfnctl 控制fd\n获取/设置某个fd的访问模式和状态标志\n复制fd\n\n这里vnode中的inode是磁盘上inode的内存镜像\n\n\n                  \n                  思考 \n                  \n                \n\n何时同一个进程内会有两个fd指向同一个open file，何时在不同进程中会这样\n何时两个open file指向同一个vnode\n\n\n进程级的fd表\nopen file descriptor\n只有close-on-exec是进程私有的标志，存在进程级fd表中\n其他标志（如O_APPEND）为系统级\n系统级的打开文件表\nopen file description\n存放打开文件句柄\n其中记录偏移，标志等\n文件系统级的inode表\n重定向语法2&gt;&amp;1使得标准错误（文件描述符2）重定向到标准输出（文件描述符1），文件描述符1和2共享打开文件句柄\n进程专有的/dev/fd/n（n是fd编号）目录\n打开这种文件相当于复制（dup）fd\nargv和environ及它们指向的字符串，生命周期长\n可通过/proc/PID/cmdline和/proc/PID/environ访问\n进程可以通过/proc/self访问自己\nlongjump一般用来从调用栈的深处，直接跳转回浅层，这之间的所有栈被剥离stack unwinding\n不能反向，跳转回一个已经返回了的函数\nsetjmp只保存了有限的信息，如栈指针和程序计数器等"},"Daily/2024-10-08":{"title":"2024-10-08","links":[],"tags":["example-tag"],"content":"进程终止\n_exit是unix系统调用\nexit是_exit的c语言封装，它进行\n\n调用退出处理程序\n刷新stdio缓冲区\n调用_exit\n从main函数返回一般即exit\n\n解释器文件\n\nShell内建命令\n将某一 shell 命令实现为内建命令，不外乎如下两个目的：效率以及会对 shell 产生副作用（side effect）。\n一些频繁使用的命令（如pwd、echo和test）逻辑都很简单，放在shell内部实现效率会更高。\n将其他命令内置于 shell实现，则是希望命令对shell本身能产生副作用：更改shell所存储的信息，修改shell进程的属性，亦或是影响shell进程的运行。例如，cd命令必须改变shell自身的工作目录，故而不应在一个独立进程中执行。产生副作用的内建命令还包括exec、exit、read、set、source、ulimit、umask、wait以及shell的作业控制（job-control）命令（jobs、fg和bg）。想了解shell支持的全套内建命令，可参考shell手册页（manual page）文档。\nexec时fd会被保持\nclose-on-exec\n内核调度实体\nKSE\n进程和线程都是KSE，它们的区别只在于共享资源的形式\n多进程 vs 多线程\n多线程无隔离性\n\n注意线程安全，使用线程安全版本的函数或者以线程安全的方式调用函数\n恶意线程可以占用大量资源，修改其他线程的内存空间\n\n多线程易于数据共享，上下文切换开销小，创建快\npthread_join\n线程之间平等peer，没有进程的父子关系\n只能等待某一个特定的线程，不能像进程的wait一样模糊匹配\n条件变量总是结合互斥量使用。条件变量就共享变量的状态改变发出通知，而互斥量则提供对该共享变量访问的互斥（mutual exclusion）。\n为什么条件变量的惯常写法使用while而不是if\n\n通知发送到唤醒并不是原子的。换言之，中间可能发生了改变条件状态的事\n设计时设置“宽松的”判断条件或许更为简单。有时，用条件变量来表征可能性而非确定性，在设计应用程序时会更为简单。换言之，就条件变量发送信号意味着“可能有些事情”需要接收信号的线程去响应，而不是“一定有一些事情”要做。\n虚假唤醒\n\npthread_once\n确保多线程中只进行一次初始化\n库函数TSD改造\npthread_key_create为该库函数添加一个键，绑定该库函数的deconstructor。使用pthread_once保证这个注册过程只进行一次\n每次库函数的调用中，首先pthread_getspecific查询是否已经为本线程创建缓冲空间，如果没有就创建并使用pthread_setspecific来记录\n线程安全\n可供多个线程安全调用\n可重入（避免全局和静态）是线程安全的\n线程特有数据TSD 静态局部\n线程局部存储TLS 全局\n在线程中fork exec是可以的，但需要注意fork到exec期间的异步安全（信号安全）\n非异步安全函数依赖全局状态，如malloc是线程安全的，但它不是可重入的\n异步安全\nevent driven\n比如使用信号算是一种\nmore than non-blocking, non-blocking还是需要spin wait的\nProblems with threads\n\n\nSynchronization bugs (data races, deadlock, etc.)\n\n\nLimits concurrency to number of threads\n\n\nStacks are expensive\n\n\nPossible interleaving of threads is hard to reason about\nProblems with events\n\n\nState across events can’t be stored on stack (“stack ripping”)\ncoroutine\n\n\nPossible interleaving of events is hard to reason about\n\n\nSequential execution is lost, has to be manually traced across code\n\n\nBlocking I/O with threads is simple to write but doesn’t scale well\n\nNumber of outstanding operations ⇐ number of threads\n\n\n\nAsynchronous I/O allows a thread to have many I/O operations in parallel\n\nAsynchronous because code handles completion at some later time, such that it is not synchronized with the start of the request\n\n\n\nAsynchronous I/O leads to event-driven programming\n\n\nEvent-driven programming complicates sequential code\n\nA linear series of I/O calls is spread across multiple functions, which a programmer must manually string together in their head\n\n\n\nCoroutines are the standard C++ middle ground: looks like threads, but many coroutines can execute on a single thread\n\n\nOther languages have different approaches\n\n\nThe tension between simplicity and performance has been an open challenge in systems code for the past 25 years\n\n\nScale out, not up"},"Daily/2024-10-13":{"title":"2024-10-13","links":[],"tags":["example-tag"],"content":"并发控制\n互斥 原子性控制\n多处理器系统上的正确互斥实现\nvoid lock() { \nretry: \n\tint got = atomic_xchg(&amp;status, ❌);\n\tif (got != ✅) { goto retry; }\n}\n操作系统内核中的互斥锁\n应用程序中的互斥锁\n同步 线程执行顺序控制 多个线程的执行达到某种指定的一致状态\n互斥锁实现同步\n注：linux似乎不允许一个线程获取锁，在另一个线程释放锁\n获取锁=等待token 释放锁=发出token"},"Daily/2024-10-19":{"title":"2024-10-19","links":[],"tags":["example-tag"],"content":"指针理解fd\nfd操作=指针操作 dup等\nshell\n将命令转换为系统调用序列 工具的组合\n普通函数的语义\ncall\n创建一个新的activation frame，将传递的参数等放在frame中，暂挂调用方的执行并且将执行权转移给被调用方\n暂挂执行imply了保存当前的内存状态\nreturn\n返回值给调用方，摧毁activation frame并且恢复调用方的运行，具体位置是调用位置之后\nactivation frame\n存放了参数，局部变量\n以及返回地址和调用方的activation frame地址，用来完成执行的切换\n严格的嵌套生命周期，使得可以使用栈这种数据结构来管理frame，高效内存分配\nCoroutine语义\nsuspend允许了不删除frame的情况下切换执行流，这破坏了严格嵌套生命周期\n现在activation frame可以视为分成两部分，一部分是不需要持久存储的stack frame，一部分是需要持久存储的coroutine frame\nsuspend会返回控制本coroutine的handle，用于resume或destroy\ndestroy不会将执行流还回给上次suspend处，而是执行析构，将suspend处存活的局部变量清理，然后释放coroutine frame\n线程取消\n是否响应取消\n如果不响应，则取消请求会等到设置为响应时再被处理\n可响应时机\n可异步取消 随时可取消 异步取消安全\nftok\n组合文件系统设备号，inode号，和proj参数，试图生成一个唯一的key"},"Daily/2024-11-12":{"title":"2024-11-12","links":[],"tags":["example-tag"],"content":"引用\n四种引用类型各自能绑定的值类别\n注意避免发生悬垂引用\n避免间接引用临时对象，这样不会再有延长生命周期的作用，导致引用悬垂\n临时对象的声明周期到所在整个表达式的结尾，如果有初始化器，会存活到初始化器结束\nT&amp;&amp; ref = std::move(T{})\nresult&amp;&amp; s1 = std::move(process(1));\nmove的形参是引用，返回的临时对象绑定到move的形参上，生命周期与该引用一样长\n#include &lt;iostream&gt;\n \nconst int&amp; returnByConstReference()\n{\n    return 5; // returns const reference to temporary object\n}\n \nint main()\n{\n    const int&amp; ref { returnByConstReference() };\n \n    std::cout &lt;&lt; ref; // undefined behavior\n \n    return 0;\n}\n按值接受以下代码中的case2是可以的，但是按值接受上述代码仍然是错的\n按引用返回的对象的必须在函数返回后依然存活\n#include &lt;iostream&gt;\n \nconst int&amp; returnByConstReference(const int&amp; ref)\n{\n    return ref;\n}\n \nint main()\n{\n    // case 1: direct binding\n    const int&amp; ref1 { 5 }; // extends lifetime\n    std::cout &lt;&lt; ref1 &lt;&lt; &#039;\\n&#039;; // okay\n \n    // case 2: indirect binding\n    const int&amp; ref2 { returnByConstReference(5) }; // binds to dangling reference\n    std::cout &lt;&lt; ref2 &lt;&lt; &#039;\\n&#039;; // undefined behavior\n \n    return 0;\n}\n返回引用时，如果直接将作为引用传入的参数返回一般是ok的\nhard drive\nsector-addressable\nsector是硬件的概念\npartition\n分区\na range of sectors\n将一个物理磁盘划分为多个逻辑部分的过程，每个分区可以独立管理和使用\nblock\n块\n一般有至少1个sector大\n文件系统管理存储的逻辑单元"},"Daily/2024-11-13":{"title":"2024-11-13","links":[],"tags":["example-tag"],"content":"信号\n由内核向进程发出，或者由其他进程发出等\n异步的操作系统机制\n除零会触发exception，也会使得内核发出SIGFPE这个信号\n多个同时发出的信号可能只会触发一次处理程序，处理程序需要考虑这种情况\ndefer\nsigprocmask()允许进程忽视信号，即暂时屏蔽信号的处理，并不会忽略或丢弃信号\n通过阻止异步事件的处理，创建了一个临界区，保证了临界区和信号处理程序不会形成竞争\n等待\n// simplesh-all-better.c\n// wait之前已保证屏蔽了SIGCHILD\nstatic void waitForForegroundProcess(pid_t pid) {\n  fgpid = pid;\n  sigset_t empty;\n  sigemptyset(&amp;empty);\n  while (fgpid == pid) {\n    sigsuspend(&amp;empty);\n  }\n  unblockSIGCHLD();\n}\nSIGCHLD信号在子进程结束时发出，我们希望程序在检查fgpid（foreground pid，shell需要等待前台进程完成）时不发生数据竞争\nsigsuspend()会使进程休眠，并设置新的屏蔽mask，在捕捉到信号后处理信号，并恢复原来的屏蔽mask，然后return\n类似于条件变量提供了原子地解锁并等待\n在这里休眠后才开始接收SIGCHILD信号，return后又屏蔽SIGCHILD信号\n信号处理语义\n信号不是function call\n信号处理不会立刻执行，可以有delay。多次信号只会有一次处理\n异步\n信号如何实现\n栈处理，sigreturn\nlinux规定信号处理程序运行期间信号会被block\nstatic const size_t kNumChildren = 5;\nstatic size_t numDone = 0;\n \nint main(int argc, char *argv[]) {\n  printf(&quot;Let my five children play while I take a nap.\\n&quot;);\n  signal(SIGCHLD, reapChild);\n  for (size_t kid = 1; kid &lt;= 5; kid++) {\n    if (fork() == 0) {\n      sleep(3 * kid); // sleep emulates &quot;play&quot; time\n      printf(&quot;Child #%zu tired... returns to dad.\\n&quot;, kid);\n      return 0;\n    }\n  }\n \n  while (numDone &lt; kNumChildren) {\n    printf(&quot;At least one child still playing, so dad nods off.\\n&quot;);\n    sleep(5);\n    printf(&quot;Dad wakes up! &quot;);\n  }\n  printf(&quot;All children accounted for.  Good job, dad!\\n&quot;);\n  return 0;\n}\n \nstatic void reapChild(int unused) {\n  while (true) {\n    pid_t pid = waitpid(-1, NULL, WNOHANG);\n    if (pid &lt;= 0) break; // note the &lt; is now a &lt;=\n    numDone++;\n  }\n}\n异步信号安全\n可以在异步的信号处理程序中安全调用的\nprintf不是重入安全的，但是是线程安全的\nCPU机制\ninterrupt\n外部，异步\nexception\n处理器内部，同步\nrelaxed\n保证了单个变量的一致性\n保证了只会观察到一个统一的修改顺序\n释放获取"},"Daily/2024-11-24":{"title":"2024-11-24","links":[],"tags":["example-tag"],"content":"rust中比起C，将更多语法作为表达式处理，如if\nunit type\n一种只包含一个实例的类型\nrust中用来表示返回值为void\nempty type\n无实例的类型\nrust中用来表示不返回\n变长类型\n这里的变长的理解应该是编译期不能确定，运行期确定后不能改变\n如[T]和str 不定长u8串，UTF-8编码\n一般以引用形式出现\n因为他们的长度编译期不可知，&amp;[T]和&amp;str由指向数组地址和长度两部分组成\n同时检查多个文件描述符，看它们是否准备好了执行 I/O 操作（准确地说，是看 I/O系统调用是否可以非阻塞地执行）\n也即文件描述符就绪\n笨办法（？）:非阻塞IO轮询，多进（线）程\nIO多路复用，信号驱动\nCS110 TODO\nLec9 并发程序输出\n线程同步\nIPC\n通信\n同步\n信号\nfast system call\n时间都花在代码执行上，不需要等待外部资源\n本地文件读取被认为是fast的\nslow system call\n花费indefinite时间在等待上\nwaitpid,accept,read(socket)\n使slow变成fast\nnon-blocking模式\nCS110总结\n抽象\n实现和行为分离\nclean易用接口，不需要你了解底层\n模块化与分层\n文件系统分层\n编译器pipeline\n网络协议栈\n命名和名称解析\n给系统资源human-readable名字\n文件inode号和文件名\nip和域名\nurl,pid,fd\n缓存\n虚拟化\nmake many resources look like one\nraid\nafs\nload balancer\nmake one resource look like many\n虚拟内存映射\n线程（这里说的是进程的栈被瓜分以便多线程使用）\n虚拟机\n并发\n多进程在1处理器，多线程在1进程\n信号和中断\nC-S请求和应答\n责任的清晰划分\nsystem call\nHTTP,IMAP,DNS\nNFS,AFS\n理解信号量\n一种事件"},"Daily/2024-12-06":{"title":"2024-12-06","links":[],"tags":["example-tag"],"content":"/proc/partitons\n系统中的所有块设备/分区\n包括文件loopback模拟的块设备\ndevfs只代表硬件设备\n裸设备\n“绕过文件系统”\n直接操作devfs下的设备文件\n怎样理解阻塞非阻塞与同步异步的区别？ - 萧萧的回答 - 知乎\nwww.zhihu.com/question/19732473/answer/241673170\n以下使用wikipedia上的术语\nkernel thread\n内核调度的轻量级单位\nLWP\n有时指用户线程\n有时指将用户线程调度到内核线程的内核机制\napplication(-level) thread\nkernel(-level scheduled) entity\n这两者的对应关系，线程模型分为三类\n内核级线程kernel level threading\n1:1\nlinux nptl的pthread\n用户级线程user level threading\nM:1\n用户空间中调度，这些线程无法真正同时运行\n需要注意阻塞系统调用\n混合线程hybrid threading\nM:N\nkernel level threads\nuser level threads\n纤程\n依赖非阻塞IO系统调用来实现\n对于内核来说叫LWP，对于用户叫线程"},"Daily/2024-12-10":{"title":"2024-12-10","links":[],"tags":["example-tag"],"content":"-stdlib=libc++后include头文件报错\n-stdlib会影响编译器的很多行为，其中包括头文件搜索路径。\nbits/stdc++.h是libstdc++实现特定的头文件，并非标准。"},"Daily/2024-12-21":{"title":"2024-12-21","links":[],"tags":["example-tag"],"content":"research.swtch.com/hwmm\n顺序一致性\n要求遵守这一一致性的处理器的 任意一种实际执行 都满足等价于 所有处理器按照一个全局顺序执行，并且每个处理器中的操作按照其程序指定的顺序出现在该序列\n\n共享内存可以一次服务一个线程的读取或写入请求\nLitmus Test\n测试模型是否允许特定的执行。结果只有两种，可能或不可能\n很难做出完全通用的陈述来比较不同的内存模型。相反，专注于特定的测试案例，如果两个内存模型对给定的测试允许不同的行为，这证明它们是不同的\n\nLitmus Test: Message Passing\nCan this program see r1 = 1, r2 = 0?\n\n// Thread 1           // Thread 2\nx = 1                 r1 = y\ny = 1                 r2 = x\n\nOn sequentially consistent hardware: no.\nOn x86 (or other TSO): no.\n\n\nLitmus Test: Write Queue (also called Store Buffer)\nCan this program see r1 = 0, r2 = 0?\n\n// Thread 1           // Thread 2\nx = 1                 y = 1\nr1 = y                r2 = x\n\nOn sequentially consistent hardware: no.\nOn x86 (or other TSO):yes!\n\n为了修复这一点，可以使用内存屏障，保证在读取之前将本地（？）写入刷新到共享内存\n\nLitmus Test: Independent Reads of Independent Writes (IRIW)\nCan this program see r1 = 1, r2 = 0, r3 = 1, r4 = 0?\n(Can Threads 3 and 4 see x and y change in different orders?)\n\n// Thread 1    // Thread 2    // Thread 3    // Thread 4\nx = 1          y = 1          r1 = x         r3 = y\nr2 = y         r4 = x\n\nOn sequentially consistent hardware: no.\nOn x86 (or other TSO): no.\n\n\nLitmus Test: Coherence\nCan this program see r1 = 1, r2 = 2, r3 = 2, r4 = 1?\n(Can Thread 3 see x = 1 before x = 2 while Thread 4 sees the reverse?)\n\n// Thread 1    // Thread 2    // Thread 3    // Thread 4\nx = 1          x = 2          r1 = x         r3 = x\nr2 = x         r4 = x\n\nOn sequentially consistent hardware: no.\nOn x86 (or other TSO): no.\nOn ARM/POWER: no.\nIn any modern compiled language using ordinary variables: yes!\n\nx86 TSO\n\n处理器将写入加入到本地写队列，然后继续执行新指令\n处理器读时会先考虑本地写队列，再考虑共享内存。其他处理器的写队列不可见\n所有处理器都同意 写入到达共享内存的（总）顺序\nRelaxed Memory Model\n\n系统中的线程必须就写入单个内存位置的总顺序达成一致\nWeak Ordering and Data-Race-Free Sequential Consistency\n硬件的这些内存模型细节太复杂了，我们更喜欢一些简单的规则，通过遵守这些规则来保证顺序一致\nweak order\n用 同步模型 来约束内存访问\nis weakly ordered by DRF\n同步操作\n结果：如果软件避免了数据竞争，那么硬件就好像它是顺序一致的一样\nresearch.swtch.com/plmm\n编程语言的内存模型回答了并行程序可以依赖哪些行为来共享线程之间的内存\n原子操作，同步原子\n利用同步指令创建happens-before关系\n现代语言采用DRF-SC\n编译器允许重排序，只要这种重排序不会改变单线程代码的执行被观察的结果，这导致了编译程序的内存模型可以被认为比relaxed更弱（如连贯性测试 yes）\njava内存模型\n所有锁、解锁和 volatile 变量访问的行为有全局顺序，这个全局顺序定义了subsequent的含义\n同步操作\n线程的创建发生在线程的第一个动作之前。\n互斥量 m 的解锁发生在任何subsequent锁定 m 之前。\n一个对易失性变量 v 的写操作发生在任何subsequent读操作 v 之前。\n也就是说，subsequent进一步定义了happens-before关系。通过检查happens-before，我们可以进一步确定有没有数据竞争\n竞态程序的语义\njava内存模型仍有一些疑点（？）"},"Daily/2024-12-23":{"title":"2024-12-23","links":[],"tags":["example-tag"],"content":"std::uint8_t一般是unsigned char的别名，打印std::uint8_t*时会以C字符串(char*)的方式打印，unexpected\n&lt;bit&gt;提供了对unsigned的位运算支持。\nHacker’s Delight\nfloat加减法，只在数值倍数相差不超过1.6e7时有效\nC字符串在cpp中类型是const char[]\n在构造函数体内“初始化”成员，实际上成员已经被默认初始化过了，我们进行的是operator=\n默认构造\nT a/new T\n如果有默认构造函数，调用它\n如果没有，内存是随机值\nint没有默认构造函数\n值初始化\nT a()/T a{}/new T()/new T{}\n相较于默认初始化，对其他情况进行零初始化\n直接初始化\nT a(...)/T(...)/new T(...)/T a{xx} non-class type\n复制初始化\nT a = xx/T a[] = {}\nnon-explicit\n直接列表初始化\nT a{...}/T{...}/new T{...}\n复制列表初始化\nT a = {...}/func({...})/return {...}/[{...}]\nnon-explicit\nauto和initializer list\nprivate继承表示has-a，不如组合\n非静态成员函数中使用lambda，使用this引用捕获所有成员变量，使用*this复制捕获\nfolly认为gcc的扩容系数2是对cache不友好的\n设想当我们不断扩容时，扩容系数2是无法重用之前释放的空间的，需求永远大于之前所有释放空间之和\n\\left(1+2+\\cdots+2^{k-1}\\right)&lt;2^{k+1}\n但1.5允许\n\\left(1.5+1.5^{2}+\\cdots+1.5^{k-1}\\right)=2*(1.5^{k}-1.5)&gt;1.5^{k+1}\nconst std::span&lt;T&gt;不能传播const，内部元素可变。\n原因是这没有意义，你可以轻易将复制出一个不带const的std::span&lt;T&gt;，这个新span观察同一段元素。\n对span使用不可变元素应当使用std::span&lt;const T&gt;\n应当像理解指针的const修饰一样理解std::span\nstackoverflow.com/questions/56886440/does-span-propagate-const"},"Daily/2024-12-29":{"title":"2024-12-29","links":[],"tags":["example-tag"],"content":"CPU指令的原子性\nAtomic vs. Non-Atomic Operations\n首先需要注意有些指令是宏，并不是真正的单条指令\n单条指令并不都是原子的\narmv7提供了一条指令将两个32位寄存器组成64位，存储到内存中去，这条指令有torn write的风险\nx86 纯读写指令只有在不跨cache line情况下才能保证原子\nc++ - Is incrementing an int effectively atomic in specific cases? - Stack Overflow\nx86指令add DWORD PTR [rbp - 4] 1 具有CISC风格\n可以被归类为Read Modify Write\n这条指令设计多个uop\n在这条指令中，涉及了两次总线的获取和释放，中间存在可以插入acquire的机会\nAGENT 1          AGENT 2\n\nload X              \ninc C\n                 load X\n                 inc C\n                 store X\nstore X\n\nlock前缀使得这条指令变成原子的，此外还有内存屏障功能\ncache locking+缓存一致性\n\n\n                  \n                  TODO \n                  \n                \n\n跨cache line的情况，以及失败的原子指令 原子指令对一致性的性能影响\nc++ - Atomicity of loads and stores on x86 - Stack Overflow\n\n\n单处理器系统只需提防中断，并行IO设备，DMA\n赋值和构造的开销不一定差不多\n对于字符串和容器类这些容器，赋值时可以考虑直接重用已分配的空间，而构造一定会开辟新空间。\n因此这些类如果对性能有需求，不应在赋值函数使用copy-and-swap idiom\nString&amp; operator=(String&amp;&amp; rhs) noexcept{ \n\tString(std::move(rhs)).swap(*this);  //这里构造临时对象个人理解是防止自赋值\n\treturn *this; \n}"},"Daily/2025-01-10":{"title":"2025-01-10","links":[],"tags":["example-tag"],"content":"编译工具链\nAssembling a Complete Toolchain — Clang 20.0.0git documentation\nLLVM每日谈之四十一 组装一个完整的工具链 从这个翻译摘录了一些内容\n语法/语义分析的产物pch/preamble/pcm\n-precompile但是实际上好像得是--precompile\n生成中间代码 -emit-llvm\nclang -emit-llvm -S hello.c\n//-S表示人类易读格式\nfarzon’s blog: Cross-Compiling a Series - Part 1\n这系列博客介绍了如何链接musl，如何编译到wasm和arm\nclang会默认使用gnu linker，也就是ld\n可以使用lld替代\nclang会默认寻找gnu c runtime（我觉得这人表述有点容易误解，说的应该是编译器运行时），也就是glibc\n可以使用compiler-rt替代\n为了使用musl libc需要\n手动设置将crt1.o,crti.o,crtn.o参与编译时，好像是因为这几个文件名不以lib开头，不能用-l选项来指定。而libc.a可以\n三元组\ncpu架构，操作系统，标准库（gnu,musl）\n深入理解网络 IO 模型 | 编程沉思录\n一个cpp链表实现\nInterview question that became a meme - twdev.blog\n9 most common pitfalls every C++ programmer eventually falls into - twdev.blog\ncmake官方教程\n没教第三方库咋用\n教了如何支持本地安装（--install），如何打包（cpack），如何生成/修改文件来用于加入编译过程\nCS100 笔记\n常见的运算符中，其运算对象的求值顺序确定的只有四个： &amp;&amp; , || , ?: , ,\n出现了奇数次的数\n另一种想法：考虑那个出现了奇数次的数\n如果 的第i位是 1 ，意味着所有的数中，第i位一共有奇数个 1 。\n如果 的第i位是 0 ，意味着所有的数中，第i位一共有偶数个 1 。\n所以我们需要一种神奇的操作，让偶数个 1 变成 0 ，让奇数个 1 变成 1 。\n或者说，这是二进制意义下的不进位加法。——这就是异或！\nC语言ub\nUndefined behavior - cppreference.com\nvoid*\nC中允许指针隐式地转为/转出void*\n因此，在 C 中，接受 malloc 的返回值时不需要显式转换。\n底层const\nconst T*\n顶层const\nT *const\n更一般的，顶层const可以表示任意的对象是常量，这一点对任何数据类型都适用，如算术类型、类、指针等。底层const则与指针和引用等复合类型的基本类型部分有关。\n成员初始化的方式\n从特殊到一般：\n\n如果这个成员在当前构造函数的初始值列表中出现了，则遵循初始值列表中给它的\n初始化器。\n否则，如果这个成员具有类内初始值，则使用类内初始值。\n否则，如果它能默认初始化，则默认初始化。\n否则，这个成员在当前构造函数中无法被初始化。\n如果这是用户自己写的构造函数，则产生编译错误。\n如果是编译器合成的构造函数，这个构造函数就是 deleted 的。\n\n值初始化对于类类型几乎就是默认构造函数\n对于基本类型就是各种0\n默认初始化对于基本类型就是未定义值\nconst重载的例子\nclass Dynarray {\npublic:\nconst int &amp;at(std::size_t n) const {\n\tif (n &gt;= m_length)\n\t\tthrow std::out_of_range{&quot;Dynarray subscript out of range.&quot;};\n\tlog_access();\n\tverify_integrity();\n\treturn m_storage[n];\n}\nint &amp;at(std::size_t n) {\n\treturn const_cast&lt;int &amp;&gt;(static_cast&lt;const Dynarray *&gt;(this)-&gt;at(n)); //先添加底层const，再删除。安全的，合理的\n\t//如果是用non-const函数实现const，那就是先移除底层const，再添加。不安全的\n}\n};"},"Daily/2025-01-23":{"title":"2025-01-23","links":[],"tags":["example-tag"],"content":"基本数据类型\n算术类型，void\n为了支持分离式编译，C++语言将声明和定义区分开来。声明（declaration）使得名字为程序所知，一个文件如果想使用别处定义的名字则必须包含对那个名字的声明。而定义（definition）负责创建与名字关联的实体。\n变量声明规定了变量的类型和名字，在这一点上定义与之相同。但是除此之外，定义还申请存储空间，也可能会为变量赋一个初始值。\n变量声明\nextern int i; //声明\nint j; //声明并定义\nextern double pi = 3.14; //定义\n如前所述，变量的定义包括一个基本数据类型（base type）和一组声明符。在同一条定义语句中，虽然基本数据类型只有一个，但是声明符的形式却可以不同。也就是说，一条定义语句可能定义出不同类型的变量\nint i = 1024, *p = &amp;i, &amp;r = i;\nconst默认internal linkage，可以添加extern变成external linkage\n常引用\ndouble dval = 3.14\nconst int&amp; r = dval;\n//等价于\nconst int temp = dval;\nconst int&amp; r = temp;\n左值引用不允许绑定表达式。因为从上述等价表示可以看出建立的引用没有改变真正字面上看上去绑定对象（这里是dval）的能力。\nconst expression\n一个对象（或表达式）是不是常量表达式由它的数据类型和初始值共同决定\n使用constexpr修饰可以要求检查是不是常量表达式\nauto\n一般忽略顶层const。对于auto引用，初始值中的顶层常量属性仍然保留。\nconst int ci = 1;\nauto &amp;m = ci, *p = &amp;ci; //const int&amp;, const int*\n要使用范围for语句处理多维数组，除了最内层的循环外，其他所有循环的控制变量都应该是引用类型。\nint ia[][];\nfor (auto row : ia)\n\tfor (auto col : row)//💥auto会将row退化成指针\n运算对象的求值顺序与优先级和结合律无关\n隐式类型转换\n\n条件（语境？）中向bool转换\n这里涉及到一个平时没思考的问题。标准保证了尽管cin向bool的转换是explicit的，某些语境下仍然可以自动隐式转换为bool\n算术运算\n初始化和赋值，函数调用\n数组向指针，void*, nullptr, 底层const\n类类型定义的转换\n\n显式转换\n任何具有明确定义的类型转换，只要不包含底层const，都可以使用static_cast。\n如不在乎精度损失的算术类型转换，将void*转回具体指针类型\nconst_cast常常用于有函数重载的上下文中\nC++语言中的大多数语句都以分号结束，一个表达式末尾加上分号就变成了表达式语句（expression statement）。表达式语句的作用是执行表达式并丢弃掉求值结果\n名字的作用域是程序文本的一部分，名字在其中可见\n对象的生命周期是程序执行过程中该对象存在的一段时间\n顶层const可以表示任意对象是常量\nconst int ci = 42;\n底层const只会在指针和引用的语境下出现。\n当执行对象的拷贝操作时，拷入和拷出的对象必须具有相同的底层const资格，或者两个对象的数据类型必须能够转换，即非常量可以转换成常量，反之则不行\n函数的返回类型决定函数调用是否是左值。调用一个返回引用的函数得到左值，其他返回类型得到右值。\n合成的默认构造函数 默认初始化\n名称查找规则\nfriend只影响权限，不能作为声明\niostream是stringstream和fstream的基类\nstd::unitbuf可以将一个流设置为每次写都flush，std::nounitbuf恢复为默认策略\n当一个输入流被关联到一个输出流时，任何试图从输入流读取数据的操作都会先刷新关联的输出流。标准库将cout和cin关联在一起\ntie\n每个流同时最多关联到一个流，但多个流可以同时关联到同一个ostream。\n除array外，swap不对任何元素进行拷贝、删除或插入操作，因此可以保证在常数时间内完成\n除string外，swap不会使迭代器失效，只是指向新容器\n默认情况下，bind的那些不是占位符的参数被拷贝到bind返回的可调用对象中。但是，与lambda类似，有时对有些绑定的参数我们希望以引用方式传递，或是要绑定参数的类型无法拷贝。\n可以使用ref，构造一个对象，包含引用，可以拷贝\n不能\nexplicit构造函数只能用于直接初始化\nstd::shared_ptr&lt;int&gt; ptr = new int;"},"Daily/2025-01-27":{"title":"2025-01-27","links":[],"tags":["example-tag"],"content":"Mine of Information - Beginner’s Guide to Installing from Source\n5.4. Multithreading Problems\nFalse Sharing\n没有正确性问题，归根结底还是因为访问了不同的内存地址吧\nint sum1;\nint sum2;\n \nvoid thread1(int v[], int v_count) {\n    sum1 = 0;\n    for (int i = 0; i &lt; v_count; i++)\n        sum1 += v[i];\n}\n \nvoid thread2(int v[], int v_count) {\n    sum2 = 0;\n    for (int i = 0; i &lt; v_count; i++)\n        sum2 += v[i];\n}\n1.首先, thread1 将 sum1 读入其缓存。由于该行不存在于其他任何缓存中, thread1 处于独占状态:\n2.thread2 现在读取 sum2 。由于 thread1 的缓存行已经在独占状态，这会导致 thread1 的缓存行降级，并且缓存行现在在两个缓存中都处于共享状态：\n3.thread1 现在将其更新后的总和写入 sum1 。由于它只在共享状态下拥有该行，因此必须升级该行并在 thread2 的缓存中无效该行：\n4.thread2 现在将其更新后的总和写入到 sum2 中。由于 thread1 已在其缓存中失效了该缓存行，因此发生了一致性缺失，并且必须在 thread1 的缓存中失效该行，从而迫使 thread1 执行一致性写回：\n5.下一次循环迭代现在开始， thread1 再次读取 sum1 。由于 thread2 刚刚在 thread1 的缓存中失效了缓存行，它会遇到一致性缺失。它还必须在 thread2 的缓存中降级该行，迫使 thread2 执行一致性写回操作：\n6.thread2 最终读取了 sum2 。由于它有共享状态的缓存行，因此可以无需一致性活动就进行读取，我们又回到了步骤 2 结束时的情况\n3到6昂贵的升级、一致性缺失和一致性写回\nlecture-10.1.pdf\nExecution vs interpretation\ndeepseek生成\n传统硬件执行：\n经典的CPU通过硬连线路（Hardwired Logic）直接实现取指-解码-执行周期。每条指令的每个步骤（如加法、跳转）都由专用电路处理。这种方式高效但灵活性低，修改指令集需重新设计硬件。\n通过微码解释器，硬件专注于高效执行μops，而非直接处理复杂指令。这使得设计更模块化，例如现代CPU可复用相同的ALU（算术逻辑单元）处理多种指令。\n软件解释器：\n通过软件（如微码，即Microcode）实现指令的解释。复杂指令被分解为更小的微操作（μops），这些μops由底层硬件执行。微码存储在CPU内部的固件中，充当“解释器”，将复杂指令翻译为硬件可直接执行的原子操作。\n示例：\nx86处理器的复杂指令（如字符串操作）会被微码分解为多个μops（如加载、计算、存储），硬件仅需实现这些基础操作。\n向后兼容性：\n微码允许通过更新固件（而非修改硬件）支持旧指令集。例如，新x86 CPU通过微码升级兼容几十年前的软件，无需重新设计电路。\n\n\n历史背景（CISC架构）：\n20世纪70-80年代，CISC（复杂指令集计算机，如x86）采用微码实现庞大指令集。指令集包含高度抽象的指令（如单条指令完成复杂操作），通过微码解释适配硬件，但牺牲了一定的效率。后来RISC（精简指令集）通过简化指令集和硬连线逻辑提高了性能，但现代CPU（如Intel/AMD）融合了两者：硬件直接执行常见指令，复杂指令仍依赖微码。\n\n\n执行（硬连线）：高效但缺乏灵活性，适合固定指令集。\n\n\n解释（微码）：灵活且简化硬件设计，支持复杂指令集和向后兼容。\n\n\ncache可能会导致写放大\ncpu是byte-addressable，而cacheline granularity更大\n\nweak memory order\n在strong中 8发生在5之后是不被允许的，观察到写的顺序得一致\n锁需要维护状态16-40bytes\n获取锁需要系统调用，耗时\ncoarse-grained locking\n高争用下degrade\n获取锁的延迟明显增加，即使是共享锁\n乐观锁\n试图优化读为大多数的情况\n由于上述原因，共享锁没有用\n• Associate a version with the shared resource\n• Writers still have to acquire an exclusive lock of some sort\n• This ensures that only one writer at a time has access to the resource\n• At the end of its critical section, a writer atomically increases the version\n• Readers only have to read the version\n• At the begin of its critical section, a reader atomically reads the current version\n• At the end of its critical section, a reader validates that the version did not change\n• Otherwise, a concurrent write occurred and the critical section is restarted\nwriter(optLock) { \n\tlockExclusive(optLock.mutex) // begin critical section \n\t// modify the shared resource \n\tstoreAtomic(optLock.version, optLock.version + 1)\n\tunlockExclusive(optLock.mutex) // end critical section \n}\nreader(optLock) { \n\twhile(true) { current = loadAtomic(optLock.version); // begin critical section \n\t// read the shared resource \n\tif (current == loadAtomic(optLock.version)) // validate \n\treturn; // end critical section \n\t} \n}\n读者只需要两个原子load，比共享锁便宜\n但是注意，共享资源在我们访问时可能被修改，不能做出consistent state的假设\n更复杂的读操作需要更多中间检查\nnon-blocking\n不依赖锁的，使用原子操作\n一般是lock-free的同义词，表示至少能有一个线程能make progress\nlost update和A-B-A问题\nCAS没有公平性，不保证某个线程最终能获得锁"},"Daily/2025-02-07":{"title":"2025-02-07","links":[],"tags":["example-tag"],"content":"gpg抑制在gui中输入密码\nUsing Command-Line Passphrase Input for GPG with Git (for Windows) | by beta | Medium\n在这个目录下创建 gpg.conf 和 gpg-agent.conf：\n\nC:\\Users&lt;user&gt;\\AppData\\Roaming\\gnupg\\\n\n两个文件都应该包含这一行：\n\npinentry-mode loopback\n\nCS231n Convolutional Neural Networks for Visual Recognition\n线性回归\nf(xi,W,b)=Wxi+b\n几何解释：超平面\n模版匹配解释：每行代表一个类的模版，内积视角\nhinge loss\nmax(0,-)\n正则化是仅针对于权重的函数\n惩罚大的权重往往会提高泛化能力，因为这意味着没有输入维度可以独自对得分产生非常大的影响。\nAside: Optimization in primal. If you’re coming to this class with previous knowledge of SVMs, you may have also heard of kernels, duals, the SMO algorithm, etc. In this class (as is the case with Neural Networks in general) we will always work with the optimization objectives in their unconstrained primal form. Many of these objectives are technically not differentiable (e.g. the max(x,y) function isn’t because it has a kink when x=y), but in practice this is not a problem and it is common to use a subgradient.\n计算梯度有两条途径：一种是缓慢但近似且容易的方法（数值梯度），另一种是快速但更易出错且需要使用微积分的方法（解析梯度）\n梯度告诉我们函数增加最陡的方向，但并不告诉我们沿这个方向应该走多远。\n加法操作将梯度等分配给所有输入。最大操作将梯度路由到较高的输入。乘法门取输入激活值，交换它们，并乘以梯度。\n在线性分类器中，权重与输入进行点乘 （乘法），这表明数据的尺度会影响权重梯度的大小。例如，如果你在预处理时将所有输入数据示例 xi 乘以 1000，那么权重的梯度将会大 1000 倍，你需要将学习率降低这个倍数来补偿。这就是为什么预处理非常重要，有时是以微妙的方式！而对梯度如何流动有直观的理解可以帮助你调试一些这些问题。"},"Daily/2025-02-18":{"title":"2025-02-18","links":[],"tags":["example-tag"],"content":"libc6提供了c库实现的功能，libc6-dev提供了用于构建使用c库的软件所需的额外文件A\nbuild-time/runtime\npackage management - what’s the difference between installing libudev and libudev-dev - Unix &amp; Linux Stack Exchange\nTitle Unavailable | Site Unreachable\n[Bug] Pip upgrade failed · Issue #5090 · ScoopInstaller/Main · GitHub\nwindows terminal便携版不支持\nWindows 终端分发类型 | Microsoft Learn\n如何清理windowsapp和windows/installer?\n不知道，但是windows/installer中似乎是一些软件的卸载程序所在地\n恢复win10/win11桌面图标默认间距的办法 - 哔哩哔哩\nHKEY_CURRENT_USER/Control Panel/Desktop/WindowMetrics\n找到lconSpacing和IconVerticalSpacing，并将它们设置为-1125"},"Daily/2025-02-27":{"title":"2025-02-27","links":[],"tags":["example-tag"],"content":"cppnow_presentations_2023/cppnow_slides/Under_the_Hood.pdf at main · boostcon/cppnow_presentations_2023 · GitHub\nvdso\namd和intel使用了不同的指令来优化系统调用（int 80?）\n为了统一，在linux上使用vdso这个中间层\n此外，vdso能优化那些看上去没必要陷入内核的调用，如时间\nauxv\n在linux的进程初始化之后的栈上，在env之后还有一系列变量\n调用约定\ncaller-stored\n调用者caller保存，在函数调用之前由caller入栈保存\n可以被callee直接自由使用\ncallee-stored\n被调用者callee在使用这些寄存器之前入栈保存\n数组到指针的隐式转换\nint[]可以隐式转换成int*，即数组名自动转换为指向数组第一个元素的指针，除此以外的事不会发生，如以下：\nint[a][b]可以隐式转换成int(*)[b]，但不能int**\nint**和int[a][b]的内存布局是完全不同的"},"Daily/2025-03-08":{"title":"2025-03-08","links":[],"tags":["example-tag"],"content":"微软魅力时刻\n正在重定向\n正在重定向\n数据的机器级表述\n位运算就是我们接触的最早的“simd”\n每个bit就是一个data\n整数也可视作一个bitset，进而引出问题：如何进行集合操作（如成员归属判断，交集等）\n遍历集合元素可以借助lowbit实现\n一种高效的求二进制中有多少1的实现\n这里是求|S|\nint bitset_size1(uint32_t S) { // SIMD\n\tS = (S &amp; 0x55555555) + ((S &gt;&gt; 1) &amp; 0x55555555);\n\tS = (S &amp; 0x33333333) + ((S &gt;&gt; 2) &amp; 0x33333333);\n\tS = (S &amp; 0x0F0F0F0F) + ((S &gt;&gt; 4) &amp; 0x0F0F0F0F);\n\tS = (S &amp; 0x00FF00FF) + ((S &gt;&gt; 8) &amp; 0x00FF00FF);\n\tS = (S &amp; 0x0000FFFF) + ((S &gt;&gt; 16) &amp; 0x0000FFFF);\n\treturn S;\n}\n\n对相邻位进行归并\n求log2(x)下取整\n即找出最高位的1\n二分查找\nclz()求出最高位的1前有多少0，31-clz(x)即为所求\nint clz(uint32_t x) { \n\tint n = 0;\n\tif (x &lt;= 0x0000ffff) n += 16, x &lt;&lt;= 16;\n\tif (x &lt;= 0x00ffffff) n += 8, x &lt;&lt;= 8;\n\tif (x &lt;= 0x0fffffff) n += 4, x &lt;&lt;= 4;\n\tif (x &lt;= 0x3fffffff) n += 2, x &lt;&lt;= 2;\n\tif (x &lt;= 0x7fffffff) n ++; \n\treturn n; \n}\n1+1/2+1/3+…+1/n\n从较小数开始累加，和从1开始加相比有较大差异"},"Daily/2025-03-20":{"title":"2025-03-20","links":[],"tags":["example-tag"],"content":"SOP风格教程\nSOP（Standard Operating Procedure）即标准操作流程，意味着将复杂任务拆解为明确的步骤\n硬件视角的计算机\nC视角下程序内部的状态：全局变量，stack frame们（注意每个栈帧有自己的pc）\n状态迁移：执行指令，响应中断，输入输出\n执行指令（纯计算的）可以改变程序内部的状态，发出系统调用（中断）才能改变外部的状态\n有用的prompt\n我现在在[]，如果你是一个专业人士，你有什么更好的方法和建议吗，尽可能全面\nBIOS\nbasic i/o system\n启动后常驻系统，提供输入输出服务\n严格来说是firmware（cpu reset后执行的第一个软件）\nbooting\n引导\nbootstrapping的简写，“通过自力更生出人头地”\n描述了从firmware开始，直到拉起操作系统的初始化过程\nunix\nUnix操作系统=unix内核+工具\nGNU/Linux=linux内核+GNU项目的工具\nfork\n创建一个新的状态机，程序内部状态完全复制，外部状态（即操作系统维护的状态）各自处理\nexec\n复位内部状态，外部状态不变\nC库在启动时初始化FILE* stdin, stdout, stderr，很显然\neverything is a file对高速设备不够友好\nshift，CR&amp;LF，tab&amp;backspace和打字机的渊源\npty\nteletypewriter是双向的，有一个键盘可以输入，有一个屏幕可以输出\n一对虚拟设备，或者说应该像管道那样理解，但是双向\nmaster由终端模拟器使用，写口的用户输入指令通向slave的读口，读口接受来自slave的输出用来打印给用户\nslave由shell使用，一般见到的/dev/pts/0，/dev/pty就是它\n终端属性控制\nCanonical Mode按行处理\nNon-canonical Mode: 按字符处理，如vim的交互式程序\n回显、信号处理、特殊字符等\n?这里的终端可能指的是pty的master以及可能的其他的\nctrl c这种会被操作系统处理\nstty -a\n观察按键绑定\n进程组是一组相关的进程，可以一次性向它们发送信号\nshell中运行程序会为程序创建新进程组（这样可以确定前台进程到底是哪些），而fork默认不创建新进程组\nctrl+c，ctrl+z向前台进程组\nsession，controling terminal\nSIGHUP和nohup\n不同shell对命令的处理可能不同\n所以需要写shebang\nsystemcall是abi，而libc是api\napt代理\nraspbian - How can i configure a http proxy for apt-get? - Stack Overflow\n/etc/apt/apt.conf.d/10proxy\nAcquire::http::Proxy &quot;http://yourproxyaddress:proxyport/&quot;;\n"},"Daily/2025-04-02":{"title":"2025-04-02","links":[],"tags":["example-tag"],"content":"编译链接观察\n数据\n#include &lt;unistd.h&gt;\nint a = 0; // Case 1\n// extern int a; //Case 2\nint main() {\n    int x = a;\n    return 0;\n \n}\nx86似乎不允许一条mov的源和目的都是内存地址\nCase 1\nmov    0x0(%rip),%eax //加载 a 到 %eax\nmov    %eax,-0x4(%rbp) //读取 a 到 x\nCase 2\nmov    0x0(%rip),%rax   // 加载 optind 的地址到 %rax\nmov    (%rax),%eax      // 读取 optind 的值到 %eax\nmov    %eax,-0x4(%rbp)  // 存储到局部变量 x（栈位置 -0x4）\n可以发现对于外部变量，会先加载地址再读取\n函数\n永远是call &lt;?&gt;\n强制关闭位置无关代码后，唯一的变化就是函数调用变成绝对地址跳转\n以上这些是编译器做好的，链接器之后能做的就是在空位上填值\njyy dlbox阅读\n实现了call *sym(%rip)。动态链接库中的函数\ncall *sym(%rip)中sym这个位置存放的地址，被解读成真正的跳转地址\n在每个（需要使用外部动态链接库）可执行文件中预留好一个区域，这个区域存放一系列“记录”，在这里添加sym:这个标记使得编译器能知道怎么编译call *sym(%rip)，但是真正的跳转地址还得在加载的时候填入\n加载器的职责就是在记录的位置填上运行时的真正地址\njyy的设计中记录分为三类：IMPORT，EXPORT和LOAD。IMPORT就是上面说的和sym:有关的，这些符号应当已经被EXPORT，从加载器全局维护的表里查到，填入sym位置就完成了。EXPORT暴露本地的函数（本地函数偏移量已确定 只需加上运行时的偏移）给加载器全局维护的符号列表，LOAD只是用来发起对依赖的动态库的递归解析\n动态链接节约了内存，动态链接库的代码段和常量数据段都不需要被复制了。使用动态链接库的exe只需要多维护一个plt表和got表\n启动\ninitramfs\n文件树的打包\n启动时加载initramfs并执行其中的init程序，以及init程序需要的文件描述符/dev/console\ninit程序可以使用mknode来创建一些对象，最终可以通过switch_root"},"Daily/2025-04-05":{"title":"2025-04-05","links":["tags/Python"],"tags":["example-tag","Python"],"content":"python - What are the differences between Conda and Anaconda? - Stack Overflow\npython - Anaconda vs. miniconda - Stack Overflow\npython - What is the difference between pip and conda? - Stack Overflow\nAnaconda | Understanding Conda and Pip\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ncondapip管理二进制文件wheel或源代码可能需要编译器不是的包类型任何仅 Python创建环境是的，内置的不，需要 virtualenv 或 venv依赖检查是不包来源Anaconda 仓库和云服务PyPIConda: Myths and Misconceptions | Pythonic PerambulationsImproving interoperability with pip — conda 25.3.1 documentation\nconda config --set pip_interop_enabled True\npython - Running quicker for Numpy and Pandas( installed via conda) than via pip? - Stack Overflow\npython - What to do when pip &amp; conda overlap? - Stack Overflow\n建议优先使用conda安装python包，2018年\nconda install vs pip install Python - Qiita\n\nconda\n虚拟环境，包管理器\nconda 是一个基于python编写的命令行工具\nconda处理预编译二进制.conda（或者源码？）\nmamba是conda的替换\nManaging environments — conda 25.3.1.dev10 documentation\n建议在conda之后使用pip\n使用默认策略--upgrade-strategy only-if-needed\n避免--user为全局用户（all users？）安装\npip\npython包管理器\npip使用预编译二进制wheel或者源码\n当从源代码安装时，pip 会自动构建该包\nanaconda\nMiniconda = conda+最小依赖环境（Python等）\nAnaconda = Miniconda + 一个元包 anaconda =  Miniconda + conda install anaconda\n元包 anaconda = 大约 160 个其他用于数据科学日常使用的 Python 包\nnvidia和conda-forge仓库的cuda-toolkit在windows上测试是带工具链的"},"IAD":{"title":"IAD","links":[],"tags":[],"content":"无监督方法\n训练集都是正常样本，测试集含有异常样本\n检测 out of distribution\n两种方法feature embedding和reconstructed based\nfeature embedding中用到的方法好像比较多是teacher student\n还不太懂"},"IO缓冲":{"title":"IO缓冲","links":[],"tags":["OS","C"],"content":"一图流\n\nread()和write()系统调用在用户空间缓冲区与内核缓冲区高速缓存（kernel buffer cache）之间复制数据。\n这其中暗示了write一般会在用户空间到内核缓冲的复制完成之后，不保证实际磁盘写入，直接返回。\nC封装\n会根据实际对象选择缓冲方式\n行缓冲 终端\nfully buffer 其他 如管道重定向\nunbuffered\n内核到磁盘\nSynchronized I/O data integrity completion\n对写，保证data和必要的元信息（如文件大小）落盘\n对读，保证影响该次读的写都落盘（？）\nfdatasync\nO_DSYNC\nSynchronized I/O file integrity completion\n保证data和所有元信息落盘\nfsync\nO_SYNC\nO_RSYNC和O_SYNC/O_DSYNC结合，保证读之前的写入完成\nsync在linux实现上把所有内核缓冲落盘\n直接I/O\n绕过内核缓冲区，直接将用户空间缓冲区写入设备\nO_DIRECT\n对用户缓冲区有边界/大小要求\n数据库系统"},"Obsidian":{"title":"Obsidian","links":["动态规划","简历"],"tags":["学习"],"content":"别名\nTransclude of 简历#^9092da\nTransclude of 动态规划#二维费用背包\n\n\n                  \n                  啦啦啦 \n                  \n                \n\n如果\n其实\n\n"},"Parallel":{"title":"Parrallel","links":[],"tags":["example-tag"],"content":"CPUs: Instruction-level parallelism ▪ Implicit ▪ Fine-grain\nGPUs: Thread- &amp; data-level parallelism ▪ Explicit ▪ Coarse-grain\nDataflow increases parallelism by eliminating unnecessary dependences\n\n\nlatency(critical path) bound\nLongest path across iterations in dataflow graph\n3 cycles/iter\nOoO试图以dataflow的顺序执行程序\n\n顺序取指，提交，乱序执行\nnaive使用OoO，会发现并没有什么提速效果\nthroughput bounded\n\n需要更多的取指单元，执行单元，提交单元并行地做，一般情况下可以认为取指单元和提交单元是over provision的\n这样我们只会被latency bound\nOoO对代码质量更不敏感（相对于顺序执行cpu）\nthroughput bound的计算方法\n对于每种执行单元，计算所有该类指令个数 / issue rate\n取最大值\nILP这件事情并不便于scale\n关键可能和如何判定指令是否可以issue有关\n也就是需要检查指令是否独立，对于issue宽度为W的处理器，检查需要W\n流水线深度和issue宽度一起决定了能同时被执行的指令个数\n流水线加深？\n程序本身是否有ILP？\n硬件多线程技术\n硬件（core）能管理线程（维护多个execution context），通过切换线程执行隐藏内存访问延迟，提高吞吐量\n对带宽提出高要求，因为多个线程共用cache，可能会导致更多内存访问，但是能隐藏内存访问延迟\n\nEmploy multiple processing cores\n\nSimpler cores (embrace thread-level parallelism over instruction-level parallelism)\nAmortize instruction stream processing over many ALUs (SIMD)\nIncrease compute capability with little extra cost\nUse multi-threading to make more efficient use of processing resources (hide latencies, fll all available resources)\n"},"bsdiff":{"title":"bsdiff","links":[],"tags":[],"content":"daemonology.net/papers/thesis.pdf\n2.3 Matching\n两种差异\nfirst-order 失配(的新内容)\nsecond-order 与原内容有一定匹配度\nexecutable中匹配区域的特点是区域数少，区域大\nsuffix array\n将整个字符串中的所有后缀按照字典序正序排列\n\n可以用来找一个pattern的所有出现"},"c":{"title":"c","links":[],"tags":["编程语言"],"content":"表达式\n表达式语句是表达式后加;\n如hour * 60 + minute;\n表达式有值和类型两个基本属性\n等号运算符的计算结果是左边的值。多个等号从右到左计算。\n如果一个操作数左右两侧各有一个相同优先级的运算符，这个操作数的结合取决于运算符的结合性，相同优先级的运算符的结合性相同。\na=b=c 合法 而(a=b)=c (a=b)不是左值 不合法\n函数调用是一种表达式，()运算符是后缀运算符，函数名是操作数，()及其中参数是操作数的后缀\n使用math.h加-lm\necho $?可以查看上一条命令的退出状态(return 0)\n调用未声明的函数，编译器猜测类型，猜测返回值为int\n调用函数时若参数列表为空，且缺乏函数原型，则编译器认为参数类型是void\n声明函数时若参数列表为空，属于Old Style C，编译器认为参数类型和个数没有明确指定\n//不允许嵌套定义函数\n声明也是以;号结尾，这一点和语句类似，但是在语法上声明和语句是有区别的\nswitch坑\ncase 1: int i = 10;\n \nswitch(n) {\n\tint i = 10;//i未初始化\n\tcase 1:\n\t//...\n}\nmemberwise initialization\n多维数组 或者结构体数组嵌套同理\nstruct complex z1 = {.y = 4.0};//z1.x=0.0 z1.y=4.0\nint count[4]= {[2] = 3};\n枚举类型的成员名和变量名在同一空间，而结构体不在。\n数组不能相互赋值，也就不能用作函数参数或返回值，但数组类型作右值时，会自动转换成指向数组首元素的指针。\n字符串字面量的字符可以用下标访问但不能修改，字符串字面量作右值使用时也自动转换成指针\nchar c = &quot;Hello, world&quot;[1];\nc语言存储数组，一行一行拼成一串，row major\nint a[3][2] = {1,2,3,4,5};\n-g选项生成文件才可以调试\ngcc -g main.c -o main\ngdb main\n \nlist //查看源代码\nstart //开始\nnext //一句句执行\nstep //进入\nbacktrace //查看栈帧\ninfo local //查看变量\nframe //选择栈帧\nprint 表达式//打印表达式的值\nfinish //运行到返回\nset var 变量=xxx //\ndisplay //跟踪显示变量\nbreak //设置断点\ncontinue //运行到断点为止\ninfo breakpoints\n \nbreak 9 if sum != 0\nrun\n异或应用\n从异或的真值表可以看出，不管是0还是1，和0做异或保持原值不变，和1做异或得到原值的相反值。可以利用这个特性配合掩码实现某些位的翻转\n如果a 1 ^a 2 ^a 3 ^…^a n 的结果是1，则表示a 1 、a 2 、a 3 …a n 之中1的个数为奇数个，否则为偶数个。可用于奇偶校验\n由于x^x=0 x^x^y=y 可用于交换变量\n//不适用于a=b\n*a = *a ^ *b;\n*b = *b ^ *a;\n*a = *a ^ *b;\nsizeof\nsizeof是一个很特殊的运算符，它有两种形式：“sizeof 表达式”和“sizeof(类型名)”。\n“sizeof 表达式”中的表达式不求值，只推断类型。编译时就能得到\nint a[12];\nprintf(&quot;%u\\n&quot;, sizeof a/sizeof a[0]); //48/4\n返回值类型为size_t，定义在stddef.h头文件中，是一种无符号整型\ntypedef\ntypedef char array_t[10];\narray_t a;"},"cpp":{"title":"cpp","links":["tags/define","tags/if","tags/endif删除代码块","tags/undef取消定义"],"tags":["编程语言","define","if","endif删除代码块","undef取消定义"],"content":"stream\ncin buffer不为空时 跳过开始的空白符号\nFail/EOF/Good/Bad\ncin fail导致后续所有操作都fail\ngetline(cin,string,‘\\n’)不跳过开始的空白符号,读到\\n，不将其读入并且之后的读入跳过他\n解决方法cin.ignore()忽略一个buffer中的字符\nint getInteger(const string&amp; prompt,const string&amp; reprompt){\n\twhile (true){\n\t\tcout &lt;&lt; prompt;\n\t\tstring line;\n\t\tif(!getline(cin, line)) throw domain_error(&quot;..&quot;);\n\t\tistringstream iss(line);\n\t\tint val;char remain;\n\t\tif(iss &gt;&gt; val&amp;&amp;!(iss &gt;&gt; remain)) return val;\n        //not fail&amp;&amp;EOF\n\t\tcout&lt;&lt;reprompt&lt;&lt;endl;\n\t}\n\treturn 0;\n}\n将cin的异常状态和剩余内容清除\ncin.clear()\ncin.ignore(numeric_limits&lt;streamsize&gt;::max(),‘\\n’);\nwhile(true){\n\tint x;\n    double y;\n    input&gt;&gt;x&gt;&gt;y;\n    if(input.fail()) break;\n    //处理数据\n}\n \nwhile(input&gt;&gt;x&gt;&gt;y)\n//同理getline\nwhile(getline(cin,str))\n \nwhile(!input.fail())//不好 会多处理一组垃圾数据\nscanf ：读取非char时跳过开始空白符，空白符留在缓冲区\ngets：可接受回车键之前输入的所有字符，回车键不会留在输入缓冲区中\nstream manipulators endl setw() setfill()\nstream随机访问 seekg tellg seekp tellp\n多文件编译 预处理\n预处理 编译 链接\n预处理涉及#include 特殊标记 define 宏\n编译 语法错误（分号 未定义变量 参数传入错误）\n链接 建立原型但没有定义的函数\n\n顶部抽象问题依赖于三个子问题，子问题又依赖于更多子问题，顶部不需要知道网络模块如何工作，只需要知道如何使用它\n建立file.h时通常 File_Included命名无实际意义\n#ifndef File_Included\n#define File_Included\n//程序的原型\n#endif\n对应的cpp文件#include “file.h”\ndefine 通过第一个空白字符的位置决定替换内容 添加括号保证表达式出现优先级问题\n#if #elif #else #endif只能使用常量 整数值和对应的逻辑算术表达式\ndefined(MY_CONSTANT)与#ifdef相同\nif 0 endif删除代码块\nmacro\n#define macroname(parameter1, parameter2, ..., parameterN) macro-body \n与C++函数不同，预处理器宏没有返回值，宏的 “返回值 “是它所创建的表达式的结果\ninline functions效率比正常的函数要高 无需处理调用\n可以将函数标记为inline来建议编译器inline它们\n__DATE__ __TIME__ __LINE__ __FILE__\n预处理器的字符串化操作符#\n#define PRINTOUT(n) cout &lt;&lt; #n &lt;&lt; &quot; has value &quot; &lt;&lt; (n) &lt;&lt; endl\nint x = 137;\nPRINTOUT(x * 42);\n//等价于\ncout&lt;&lt;&quot;x * 42&quot;&lt;&lt;&quot; has value &quot;&lt;&lt;(x * 42)&lt;&lt;endl;\n保留变量名 可用于编写诊断函数\n字符串连接操作符##\n#define DECLARE_MY_VAR(type) type my_##type\nDECLARE_MY_VAR(int);\n//等价于\nint my_int;\nundef取消定义\nX Macro技巧\n//color.h\nDEFINE_COLOR(Red, Cyan)\nDEFINE_COLOR(Cyan, Red)\nDEFINE_COLOR(Green, Magenta)\nDEFINE_COLOR(Magenta, Green)\nDEFINE_COLOR(Blue, Yellow)\nDEFINE_COLOR(Yellow, Blue)\nenum Color {\n    #define DEFINE_COLOR(color, opposite) color, \n    #include &quot;color.h&quot;\n    #undef DEFINE_COLOR\n};\nstring ColorToString(Color c) {\n    switch(c) {\n        #define DEFINE_COLOR(color, opposite) case color: return #color;\n        #include &quot;color.h&quot;\n        #undef DEFINE_COLOR\n        default: return &quot;&lt;unknown&gt;&quot;;\n    }\n}\nColor GetOppositeColor(Color c) {\n    switch(c) {\n        #define DEFINE_COLOR(color, opposite) case color: return opposite;\n        #include &quot;color.h&quot;\n        #undef DEFINE_COLOR\n        default: return c;\n    }\n}\n在.h保存所有信息，用宏按需要提取\nSTL\n\nsize_t非负\ndeque适合开头结尾插入删除元素\nmap/set基于大小比较\nunordered基于哈希\niterator container.begin()/end()\nmap的iterator指向pair 其中键为const\nmap.insert返回pair&lt;iterator,bool&gt;,iterator指向插入的键值对或者阻止插入的键值对\nmultiset同一个值的多个副本\nmultimap一个键多个值\nequal_range返回等于某值的跨度pair&lt;iter,iter&gt;\nSTL算法\naccumulate(iter,iter,初始值)求和\n_if后缀表明要求传入一个函数如count_if(iter,iter,IsEven)\n_copy后缀表明复制到额外一个迭代器的位置\n_n执行n次\nbidirectional-random access(指针)\ninput *myItr = value和++(cin)\noutput value = *myItr(cout)\nforward *myItr = value 和 value = *myItr 和++myItr (链表)\nbirectional forward所有和—(map,set)\nrandom access +和+=(指针，向量，deque)\n\n要求随机访问：\nsort(iter,iter)\nsort(iter,iter,比较函数)\nrandom_shuffle(iter,iter)\nrotate(iter,iter,iter)顺序是开始，旋转中心，结束\nfind(iter,iter,value)\n容器类有同名成员函数时，优先使用成员函数效率更高，stl算法保证通用性，优化不能最好\nbinary_search(iter,iter,value)\niterator adaptors\n（当运行一个产生数据范围的算法时，你必须确保存在足够的空间来容纳结果。然而，在某些情况下，在你实际运行算法之前，你无法知道将产生多少数据。也就是说，确定你需要多少空间的唯一方法是运行该算法，这可能会导致未定义的行为，因为你没有分配足够的空间。）\n不指向容器中的实际元素\nostream_iterator&lt;int&gt; myItr(cout,” ”)\nback_insert_iterator&lt;container&gt;等价于back_inserter(container)\nset_union set_intersection set_difference要求有序(?)\ninserter(container,container.begin())\nistream_iterator&lt;int&gt;(istream)和istream_iterator&lt;int&gt;()\n移除算法\nremove并不会删除 只会覆盖，返回不在修改范围的第一个元素的迭代器\nmyVector.erase(remove(myVector.begin(),myVector.end(),137),myVector.end())删除所有137\nremove_if(iter,iter,比较函数)\nremove_copy将没有被移除的元素复制到另一个容器\ntransform(iter,iter,iter,函数)两个迭代器划定范围，一个迭代器指定目的地\nswap()\nmin_element max_element\nreverse_iterator反向遍历\nequal(iter,iter,iter)两个迭代器划定范围，一个迭代器指定第二个范围的开始\n抽象和类\n构造函数\n当不定义任何构造函数时且所有成员都有无参构造函数时，c++自动提供无参构造函数，会调用每个成员的无参构造函数\n但是int，float等基础类型，指针类型以及组成的类都不会被初始化（成0）这些类型被称为POD\n可以在类内初始化变量\n同理可以在类成员定义中加上{0}\nint x{};\nvoid *p{};\n//等价于\nint x{0};\nvoid *p{nullptr};\n可以通过下列定义恢复该构造函数\nPig pig() = default;\n（C++11）当（和他的基类）不定义任何构造函数，会自动生成一个参数个数和成员一样的初始化列表构造函数 。只能通过{}或={}来调用。\n这个函数也可以指定部分成员初始化，其余的保持默认。（需要防止未指定的未初始化）\n默认生成拷贝构造函数和=重载\n复制所有成员\n可以通过下列定义禁止\nPig(Pig const &amp;) = delete;//禁止拷贝构造函数\n三五法则\n不允许调用构造函数，但构造函数可以调用私有函数，简化代码\ntemplate &lt;typename FirstType, typename SecondType&gt; struct MyPair {\n    FirstType first;\n    SecondType second;\n};\n \ntemplate &lt;typename FirstType, typename SecondType&gt; class MyPair {\n    public:\n        FirstType getFirst();\n        void setFirst(FirstType newValue);\n        SecondType getSecond();\n        void setSecond(SecondType newValue);\n    \tvoid swap(MyPair&amp; other);//不需要&lt;&gt;\n    private:\n        FirstType first;\n        SecondType second;\n};\n \ntemplate &lt;typename FirstType, typename SecondType&gt;\n\tFirstType MyPair&lt;FirstType,SecondType&gt;::getFirst() {\n    return first;\n}\n模板类通常将定义也放在.h中\ntemplate &lt;typename T&gt; class Stack {\n    public:\n        void push(T value);\n        T pop();\n        size_t size();\n        bool empty();\n        typename deque&lt;T&gt;::iterator begin(); //模板类的迭代器\n        typename deque&lt;T&gt;::iterator end(); \n    private:\n        deque&lt;T&gt; elems;\n};\n类的成员函数后加入const关键字\n常量引用\n指向常量的指针const Type* ptr/const Type* ptr\n常量指针Type* const ptr\nconst_iterator(容器实现中有const overloading 有const和非const的迭代器)\n通常从const函数返回指向常量的指针，防止通过指针修改\n语义上和bitwise上的const\n设计了get函数仅当需要时读入更多的数据来返回，因而不再是const函数，内部实现改变了接口，语义上const但不是bitwise const为了解决这个问题，引入mutable标记数据成员，可以在const函数中修改\nconst-correctness\n从不按值传递，不改变状态的成员函数被标记为const，反之相同，从不被修改的变量标记为const\n初始化器列表\nC++创建对象时先开辟内存，再将调用所有变量的默认构造函数（原始类型保持不变），再调用构造函数，非原始类型被构造了两次，使用初始化器列表代替默认值来初始化\nSimpleClass::SimpleClass():myInt(5),myString(&quot;C++!&quot;),myVector(10){\n//空构造函数\n}\nRationalNumber::RationalNumber(int numerator, int denominator):numerator(numerator),denominator(denominator)\n{\n// 空构造函数\n}\n只在函数原型中指定缺省参数，必须都设定或者都不设定\n可以在构造函数初始化器列表修改常量\n静态数据成员\n与整个类相关的数据成员 使用static关键字声明 再(在相关的.cpp中)定义\n静态成员函数\n如传递给STL算法的比较函数期望两个参数，而一般的成员函数多了一个隐含的this参数\n静态函数只能对参数和他的类的静态数据成员操作\n同样的 只在声明时加上static关键字\n两种调用方式\nwindows1.getRemainingInstances()\nWindow::getRemainingInstances()\nconst函数可以修改静态数据 静态成员函数不能被声明为const\n静态常量\n构造函数\nRationalNumber(int numerator = 0, int denominator = 1);\n \nRationalNumber myNumber = 137;\n//被解释为\nRationalNumber myNumber(137, 1);\n单参数构造函数被解释为转换构造函数，加上explicit关键字防止隐式转换\n操作符重载\nclass RationalNumber {\n    public:\n    \tconst RationalNumber operator- (const RationalNumber&amp; rhs) const;\n};\nconst RationalNumber operator- (const RationalNumber&amp; arg);\n返回左值和右值，左值([])应返回非const引用，右值应返回const引用\nchar&amp; operator [] (size_t position);\nconst char&amp; operator [] (size_t position) const;\n \n//复合赋值运算符号都应该返回左值\nVector3D&amp; operator+= (const Vector3D&amp; other);\n注意表达式顺序（+这种运算符通常在类外定义）\n++x返回l值,x++返回r值\nclass MyClass {\n    public:\n        MyClass&amp; operator ++(); // Prefix\n        const MyClass operator ++(int dummy); // Postfix\n};\n//前缀++用+=1实现，后缀++用前缀++实现\nMyClass&amp; MyClass::operator ++() {\n    *this += 1;\n    return *this;\n}\nconst MyClass MyClass::operator ++(int dummy) {\n    MyClass oldValue = *this;\n    ++*this;\n    return oldValue;\n}\n//参数名可省略\n重载关系运算符注意trichotomy和transitivity,a和b之间的关系一定是三个中的一个，且大小关系有传递性\nA &lt; B ⇔ A &lt; B\\\\\nA &lt;= B ⇔ !(B &lt; A)\\\\\nA == B ⇔ !(A &lt; B || B &lt; A)\\\\\nA != B ⇔ A &lt; B || B &lt; A\\\\\nA &gt;= B ⇔ !(A &lt; B)\\\\\nA &gt; B ⇔ B &lt; A\nbool operator &lt; (const MyClass&amp; other) const;\nfriend关键字\n//和模板一起使用时\ntemplate &lt;typename T&gt; class PQueue {\n    public:\n    \ttemplate &lt;typename T&gt; friend PQueueFriend(const PQueue&lt;T&gt;&amp; pq);\n};\nostream&amp; operator &lt;&lt; (ostream&amp; stream, const MyClass&amp; mc) {\n    return stream;\n}\n//还没有完全适配，如setw\nT&amp; operator *() const;\n→是单目运算符\nCustomStringPointer myCustomPointer;\ncout &lt;&lt; myCustomPointer-&gt;length() &lt;&lt; endl;\n//等同于\ncout &lt;&lt; (myCustomPointer.operator -&gt;())-&gt;length() &lt;&lt; endl;\ntypedef typename vector&lt;T&gt;::iterator iterator;\ntypedef typename vector&lt;T&gt;::const_iterator const_iterator;\n \ntypedef ElemType* iterator;\ntypedef const ElemType* const_iterator;\n//多重[]实现\ntemplate &lt;typename T&gt; class grid {\n    public:\n        class MutableReference {\n        \tpublic:\n                friend class grid;//grid可以调用私有构造函数\n                T&amp; operator[] (size_t col);\n            private:\n                MutableReference(grid* owner, size_t row);\n                grid* const owner;\n                const size_t row;\n\t\t};\n        class ImmutableReference {\n            public:\n                friend class grid;\n                const T&amp; operator[] (size_t col) const;\n            private:\n                ImmutableReference(const grid* owner, size_t row);\n                const grid* const owner;\n                const size_t row;\n        };\n        ImmutableReference operator[] (size_t row) const;\t\n        MutableReference operator[] (int row);\n};\ntemplate &lt;typename T&gt; grid&lt;T&gt;::MutableReference::MutableReference(grid* owner, int row):owner(owner), row(row) {\n}\ntemplate &lt;typename T&gt; T&amp; grid&lt;T&gt;::MutableReference::operator[] (int col) {\n\treturn owner-&gt;getAt(row, col);\n}\ntemplate &lt;typename T&gt; typename grid&lt;T&gt;::MutableReference grid&lt;T&gt;::operator[] (int row) {\n\treturn MutableReference(this, row);\n}\n资源管理\n以下三种情况是初始化\n1.初始化变量\nMyClass one;\nMyClass two = one;//等同于\nMyClass two(one);\n2.函数传值\n3.函数返回值\n初始化只是拷贝，赋值涉及到清理现有资源再拷贝\nMyClass(const MyClass&amp; other); //复制构造函数\nMyClass&amp; operator = (const MyClass&amp; other); // 赋值运算符\n类可以访问同一个类的实例的私有数据\n赋值运算符要防止自己赋值给自己的情况\nMyClass::MyClass() : /* Fill in initializer list. */ {\n\t/* Default initialization here. */\n}\nMyClass::MyClass(const MyClass&amp; other) {\n\tcopyOther(other);\n}\nMyClass&amp; MyClass::operator =(const MyClass&amp; other) {\n    if(this != &amp;other) {\n        clear();\n        copyOther(other);\n\t}\n    return *this;\n}\nMyClass::~MyClass() {\n    clear();\n}\nstd:move\nreturn会触发移动\nFunctor\n类 重载()运算符\ninclude &quot;&quot;优先在当前目录寻找\nuniform initialization大括号\nconst double kWaitTime = 0.1; // 帧之间暂停0.1秒 \n \nvoid Pause() {\n    clock_t startTime = clock();\n    while(static_cast&lt;double&gt;(clock() - startTime)/ CLOCKS_PER_SEC &lt; kWaitTime）\n}\nsrand()随机数种子设定\nsrand(static_cast&lt;unsigned int&gt;(time(NULL)))\n//给出probability概率的真值 rand()∈[0,RAND_MAX]\nbool RandomChance(double probability) {\n\treturn (rand() / (RAND_MAX + 1.0)) &lt; probability;\n}\nauto和decltype()\ntemplate &lt;typename T&gt;\nauto MyFunction(const T&amp; val) -&gt; decltype(val.doSomething()) {\n\treturn val.doSomething();\n}\n复制语义和移动语义\n复制会复制数据，移动不会产生拷贝\nrvalue引用 Type &amp;&amp;\n//移动构造函数\ntemplate &lt;typename T&gt; vector&lt;T&gt;::vector(vector&amp;&amp; other) {\n    elems = other.elems;\n    len = other.len;\n    other.elems = nullptr;\n    other.len = 0;\n}\ntemplate &lt;typename T&gt; vector&lt;T&gt;&amp; vector&lt;T&gt;::operator= (vector&amp;&amp; other) {\n    if(this != &amp;other) {\n        delete [] elems;\n        elems = other.elems;\n        len = other.len;\n        other.elems = nullptr;\n        other.len = 0;\n    }\n    return *this;\n}\nlamda函数\nauto func = [capture-clause](parameters)-&gt;return-value{\n\t//body\n};\ncapture-clause中的参数可以被lamada访问\n(1)[]:没有任何函数参数对象\n(2)[=]:以值传递方式捕获Lambda所在范围内的所有局部变量。\n(3)[&amp;]:以引用传递方法捕获Lambda所在范围内的所有局部变量。\n(4)this:函数体可以使用Lambda所在类的成员变量。\n(5)[x,&amp;y]:x以值传递捕获，y以引用形式捕获。\n(6)[=,&amp;z]:z以引用形式捕获，其他变量以值传递捕获。\n(7)[&amp;,x]:x以值传递形式捕获，其他变量以引用形式捕获。\n括号内加逗号的表达式规则是从左往右执行语句，返回最后一个语句的结果。\n继承\nC++接口\nvirtual grid&lt;pixelT&gt; convertToPixelArray() const = 0;\n包含纯虚拟函数的类称为抽象类，不可实例化\n没有被标记virtual的函数不会被取代\n将基类的析构器标记为纯虚拟，但仍需要提供一个什么都不做的实现 先调用派生类的析构器再调用基类的析构器\n完全限定名称的方法\n可以使用初始化器列表（？）来指定派生类调用直接基类的构造函数\n构造函数内的虚函数不会被多态地调用防止访问未初始化的派生类数据\n/* Copy constructor. */\nDerived::Derived(const Derived &amp;other) : Base(other) // Correct\n{\n\tcopyOther(other);\n}\n \n/* Assignment operator. */\nDerived&amp; Derived::operator= (const Derived &amp;other)\n{\n    if(this != &amp;other)\n    {\n        clear();\n        Base::operator= (other); // Invoke the assignment operator from Base.\n        copyOther(other);\n    }\n    return *this;\n}\n私有继承class Derived:private Base将所有公共函数成为私有的，且不能用基类的指针指向它\n安全转换 （隐式）不安全转换（窄化转换）\nC++11引入初始化避免窄化转换 ()圆括号不能防止窄化\ndouble x {2.7};\nint y {x};//错误\n尽可能使用constexpr而不是字面常量（戏称为magic number）\n编译时未知但在初始化后不改变的值用const\nswitch只能使用整型，字符型或枚举类型 case只能是常量表达式 不能重复 可以一个case使用多个常量 在每个case后加break防止无条件执行所有匹配之后的\n!cin catch(…)\n类声明结束要有分号\nC标准库\nc中标准库文件在c++中仍然存在，有以下两个版本\n1.推荐使用 无.h后缀 有c前缀 都在命名空间std下 如cstdio\n2.有.h后缀 不使用命名空间\n嵌套命名空间\nnamespace MyLibraries::Networking::FTP{}\n \nnamespace MyLibraries{\n\tnamespace Networking{...}\n}\n命名空间别名\nnamespace MyFTP = MyLibraries::Networking::FTP\n零初始化\n{0}或{}\n新式的枚举\nenum class PieceType { King, Queen, Rook, Pawn};\nPieceType piece { PieceType::King };\n可以使用using来避免写全名\n和旧式的命名空间不同\nif/switch语句初始化器\nif (&lt;initializer&gt;; &lt;conditional_expression&gt;)\nswitch (&lt;initializer&gt;; &lt;conditional_expression&gt;)\ninitializer的变量只在整个很大的if/switch内有效\n__func__当前函数名称\n双 方括号\nstd::optional\n结构化绑定\narray values { 11, 22, 33};\nauto [x, y, z] { values };\n必须auto\n重写方法后加入override关键字\nC++语法的课程文档"},"cpp_folder/学习资料":{"title":"学习资料","links":[],"tags":["example-tag"],"content":"The “C++ learning suggestion macro” : u/IyeOnline (reddit.com)\nwww.learncpp.com\nwww.studyplan.dev/cpp\nwww.hackingcpp.com\nSystems Programming in C++ - \t\t\t\t\t\t\t\t\t\t\t\t\tLehrstuhl für Datenbanksysteme"},"cpp_folder/定义与声明":{"title":"定义与声明","links":[],"tags":["example-tag"],"content":"ODR\none definition rule\n一个模版，类型，函数，对象在一个翻译单元只能有一个定义\n在一个程序中（的一个特定scope），一个函数和对象的定义只能有一个，否则链接出错；允许模版，类型和内联函数/变量出现多个相同的定义\n类定义中的函数定义是implicitly inline的，可以被include到多个文件中而不违反ODR\n类定义外的函数定义不implicitly inline\n函数的声明又称prototype\n函数默认实参应该在声明时给出\nStatic members are global variables that live inside the scope region of the class.\n先声明后使用\n定义是更强的声明\n如果只是用来声明指针/引用则可以只声明\n任何对类型的使用都需要看到完整定义，而不只是前向声明\n变量，函数，命名空间，using，类，模版声明\nodr-use需要定义存在\n• The value of a variable declaration is read or written\n• The address of a variable or function declaration is taken\n• A function is called\n• An object of a class declaration is used\nMost declarations are also definitions, with some exceptions such as\n• Any declaration with an extern specifier and no initializer\n• Function declarations without function bodies\n• Declaration of a class name (“forward declaration”)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTypeMeaningExamplesFundamentalA type built into the core C++ languageint, std::nullptr_tCompoundA type built from fundamental typesint&amp;, double*, std::string, FractionUser-definedA class type or enumerated type  (包括标准库定义和实现定义)  (In casual use, typically used to mean program-defined types)std::string, FractionProgram-definedA class type or enumerated type  (Excludes those defined in standard library or implementation)Fraction\n变量声明\nType var;\n推荐用于有构造函数的默认初始化\n有默认构造函数就有这个初始化动作\n全局变量，static变量和线程局部变量一定先零初始化\nType var{};\n推荐用于默认初始化，以及类的静态成员变量\n若有非默认提供的默认构造函数，则对象会先零初始化多了一些开销\n值初始化/直接列表初始化\nauto var = expr\n推荐用于有初值初始化\nauto和表达式类型相同，如auto var = Type{…}\nType var{…}\n推荐用于类的静态成员变量\n直接列表初始化\n接受包括explicit的构造函数和转换构造函数，拒绝有损转换，还会优先使用构造器列表的构造函数，还可进行聚合初始化\nnarrowing conversion只涉及数值类型"},"csapp":{"title":"csapp","links":["c"],"tags":[],"content":"信息的表示和处理\n整数的运算满足乘法结合律和交换律，溢出的结果是一致的\n而浮点运算不满足结合律\n(3.14+1e20)-1e20=0.0\n3.14+(1e20-1e20)=3.14\n虚拟地址空间 字节数组\n十进制下x=2^n n=i+4j i∈[0,3]\n该数的十六进制表示为1(i=0) 2(i=1) 4(i=2) 8(i=3)后j个0\n2048=0x800\n字长w 虚拟地址的范围是0-2\n数据通路的宽度（CPU内部总线的宽度，运算器的位数，通用寄存器的宽度都应该等于）\n字没有什么意义好像 可能是16位\n大端法 最高有效字节在最前面 （正常书写数字规则）\n小端法 最低有效字节在最前面\n较新的微处理器采用双端法两种都能处理\nTransclude of c#异或应用\n练习题2.13\nbis(x,m)=x|m bic(x,m)=x&amp;!m\n移位运算\n左移在后面补0 位移量应该是0~w-1 移位运算是可左结合\n逻辑右移 高位补0\n算术右移 在左边补k个最高有效位的值\n所有编译器几乎都对有符号数进行算术右移，而无符号数必须是逻辑的\n移动k位 当k超过w时 移位k mod w\n加减法运算优先级高于移位运算\n补码编码\n由位级表示计算真值\nB2T_w(\\vec{x})\\dot=-x_{w-1}2^{w-1}+\\sum_{i=0}^{w-2} x_i2^i\nn位补码机器数与真值关系\n[X]_补=2^n+X\\quad(-2^n\\leq X&lt;2^n,\\text{mod}2^n)\n其中[X]补是机器数，X是真值\n对于定点小数，模为2\n补码转无符号\nT2U_w(x)=\\begin{split}\n\\left \\{\n\\begin{array}{}\n    x+2^w  &amp;x&lt;0\\\\\n    x  &amp; x&gt;=0\n\n\\end{array}\n\\right.\n\\end{split}\n无符号转补码\nTMaxw为w位下最大有符号补码数\nU_w2T(u)=\\begin{split}\n\\left \\{\n\\begin{array}{}\n    u  &amp;u&lt;=TMax_w\\\\\n    u-2^w  &amp;u&gt;TMax_w\n\n\\end{array}\n\\right.\n\\end{split}\nC语言中默认为有符号，为了创建无符号常量需要加上后缀字符U或u\n在运算中同时含有有符号和无符号时，会转为无符号的\n\n与负号没啥关系\n位表示扩展\n补码在高位填充最高有效位\nshort转为unsigned时等价于(unsinged)(int)short\n数值截断\n好像就是直接截断\nB2U_k(\\vec{x})=B2U_w(\\vec{x}) mod 2^k\nB2T_k(\\vec{x})=U2T_k(B2U_w(\\vec{x})mod2^k)\n整数运算\n2个w位的数之和最大需要w+1位来表示，被称为字节膨胀(lisp支持)\n无符号加法\n结果被直接截断\n检测溢出的方法：比结果是否大于加数\nx+^u_wy=\\begin{split}\n\\left \\{\n\\begin{array}{}\n    x+y  &amp;x+y&lt;2^w &amp;正常\\\\\n    x+y-2^w  &amp;2^w&lt;=x+y&lt;2^{w+1} &amp;溢出\n\\end{array}\n\\right.\n\\end{split}\n无符号数的加法逆元\n在无符号加法中，0是单位元，每个元素都有加法逆元\n-^u_wx=\\begin{split}\n\\left \\{\n\\begin{array}{}\n    x  &amp;x=0\\\\\n    2^w-x  &amp;x&gt;0\n\\end{array}\n\\right.\n\\end{split}\n补码加法\nx+^t_wy=\\begin{split}\n\\left \\{\n\\begin{array}{}\n    x+y-2^w  &amp;2^{w-1}&lt;=x+y &amp;正溢出\\\\\n    x+y  &amp;-2^{w-1}&lt;=x+y&lt;2^{w-1} &amp;正常\\\\\n    x+y+2^w  &amp;x+y&lt;-2^{w-1} &amp;负溢出\n\\end{array}\n\\right.\n\\end{split}\n补码的加法逆元\n除了TMinw的逆元为自身，其余数x的逆元都为-x\n乘法\n无符号与有符号的乘法的结果的位级表示相同，但只看结果（n位乘n位应是2n位 被截断到n位）不能判断是否发生溢出\n计算补码的非\n取反+1\n0xf的补（反）是0x0 如0xa的补（反）是0x5 故0xfffffffa是6的补码非 即-6的补码表示\n形如Xw-1,Xw-2,…Xk+1,Xk=1,0,0,0…的数，其补码非为Xw-1到Xk+1取反，后面的10…0不变，如1100（-4）和0100（4），0101（5）和1011（-5）\n舍入\n向偶数舍入：如果在某两个数中间，则舍入到偶数(0)，否则根据大小向上或向下\n条件分支\nif(test-expr)\n\tthen-statement\nelse\n\telse-statement\n \n//equal to\n\tt = test-statement\n\tif(!t)\n\t\tgoto false;\n\tthen-statement\n\tgoto done;\nfalse:\n\telse-statement\ndone:\n并不一定等价\nv = test-statement ? then-expr : else-expr\n//equal to\nv = then-expr;\nve = else-expr;\nt = test-expr;\nif(!t) v = ve;\ndo\n\tbody-statement\n\twhile (test-expr);\n//equal to\nloop:\n\tbody-statement\n\tt = test-expr;\n\tif(t)\n\t\tgoto loop;\nwhile (test-expr)\n\tbody-statement\n//ver 1 jump to middle\n\tgoto test;\nloop:\n\tbody-statement\ntest:\n\tt = test-expr;\n\tif (t)\n\t\tgoto loop;\n//ver 2 guarded do\n\tt = test-expr;\n\tif(!t)\n\t\tgoto done;\nloop://do-while\n\tbody-statement\n\tt = test-expr;\n\tif (t)\n\t\tgoto loop;\ndone:\nfor (init-expr; test-expr; update-expr)\n\tbody-statement\n//ver 1\n\tinit-expr;\n\tgoto test;\nloop:\n\tbody-statement\n\tupdate-expr;\ntest:\n\tt = test-expr;\n\tif (t)\n\t\tgoto loop;\n//ver 2\n\tinit-expr;\n\tt = test-expr;\n\tif(!t)\n\t\tgoto done;\nloop://do-while\n\tbody-statement\n\tupdate-expr;\n\tt = test-expr;\n\tif (t)\n\t\tgoto loop;\ndone:\n \n过程调用\n传递控制 调用时设置PC为被调用函数的起始地址，返回时设置为调用函数的地址\n传递数据\n分配和释放内存\n运行时栈\n\n局部数据存放在内存中的情况\n1.最多在寄存器上传递6个整数值，超过的就放在栈帧中\n2.局部变量为数组或结构\n3.对局部变量使用了地址运算符，因此必须要能寻址他\n寄存器使用惯例\n被调用者保存寄存器(%rbx %rbp %r12-15)，被调用函数要保证寄存器的值在返回时与他被调用时保持一致\n调用者保存寄存器(除栈指针)\n数据对齐\n保证某种类型的数据的地址必须是K的倍数\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nK类型1char2short4int,float8long,double,char*\n指针强制类型转换的效果是改变指针运算的伸缩\nchar *p的值为q\n(int *)p+7 = q+28 (int *)(p+7) = q+7\n对抗缓冲区溢出攻击\n栈随机化\n攻击者插入攻击代码需要知道插入代码存放的栈地址\n使得程序运行的栈位置变化 在每次程序运行前在栈上随机分配空间。\nnop sled 在攻击代码前插入很长一段nop，只要猜中序列中的某个地址就能到达攻击代码\n栈破坏检测\n在栈帧中存储canary值，返回时检测是否发生改变"},"csharp":{"title":"csharp","links":[],"tags":["编程语言"],"content":"char[] allMagics = new char[9];\nchar[] allMagics = new char[9]{.....};\n \nint[,] cells = {{1,0,2},{1,2,0},{1,2,1}};\nint[,] squareCrystal = new int[2, 3];\nint[,,] cubeCrystal = new int[2, 3, 4];\nsquareCrystal[0, 2] = 5;\n \nfloat[][] crossCrystal = new float[3][];\ncrossCrystal[0] = new float[3];\ncrossCrystal[1] = new float[4];\nint[][] cells = {new int[]{1,0,2,0},\n\t\t\t\t new int[]{1,2,0},\n\t\t\t\t new int[]{1,2},\n\t\t\t\t new int[]{1}};\ncells[1][0] = 1;\n \nstring[] languages = {&quot;C#&quot;,&quot;COBOL&quot;,&quot;JAVA&quot;,&quot;C++&quot;};\n \nstring[] languages;\nlanguages = new string[]{&quot;C#&quot;,&quot;COBOL&quot;,&quot;JAVA&quot;,&quot;C++&quot;};\nSystem.Array.Sort(array)\nSystem.Array.BinarySearch(array,target)\nSystem.Array.Reverse(array)\nSystem.ArrayClear(array,start index,length)将一块区域设置为默认值\nbool[,,] cells = new bool[2,3,3];\ncells.GetLength(0);//长度 2\ncells.Rank//维度 3\n字符串，支持+拼接其他类型\n字符串前使用@，表明转义序列不被处理，并且能逐字解释所有空白字符。\n字符串前使用$，并将表达式嵌入大括号中\n也可以在$前使用@\nstring转换成其他类型\nstring text = &quot;9.11E-31&quot;;\nfloat kgElectronmass = float.Parse(text);\n其他类型转换成string\nbool isMiddle = true;\nstring text = isMiddle.ToString();\nSystem.Convert类型转换\nenum Gender{\n\tMale, Female, Other\n}\nGender gender = Gender.Female;\nstruct中默认private，可以在结构体里定义方法\nstruct是值类型\n原始类型和引用类型\n引用类型按值传递和引用传递\n引用传递可以修改引用类型本身（指针？）指向的地址，按值传递只能读取地址修改堆上的内容\n标识符\n字母 下划线\n数字不能在首位\n@只能首位\n格式字符串\nWrite和Writeline中使用\nConsole.WriteLine(&quot;Two sample integers are {0} and {1}.&quot;, 3, 6);\n{0}称为替代标记 值可以被多次使用\n引用出界发生运行时错误\n{index, alignment:format}\nalignment左右对齐\nformat格式字段 由格式说明符和精度说明符组成\n字符串插值\nC#6.0\nConsole.WriteLine($&quot;Two sample integers are {var1} and {var2}.&quot;);\n数值类型不具有布尔意义\n类声明结束无分号\n字段初始化\nclass MyClass{\n\tint F1;//使用默认值\n\tint F2 = 25;//使用初始化值\n}\n初始化值编译时需能确定\n为类对象数据分配内存\nnew TypeName()\n类成员默认private\n局部常量必须初始化，初始化值能编译时决定\nC#7.0可以在一个函数内声明另一个函数，只能在该方法内调用\n值参数\n在栈中为形参分配空间，复制实参的值给形参\n引用参数\n在调用中也要使用ref修饰，实参必须是变量，在用作实参前被赋值\n不分配内存，起别名\n输出参数\n在调用中也要使用out修饰，实参必须是变量\n不分配内存，起别名\n方法内部需先给其赋值才能访问它\n返回前必须赋值\nC#7.0不需要预先声明变量作out参数\n参数数组\n只能有一个参数数组，必须在最后\n声明\nvoid ListInts( params int[] inVals )\n调用\nListInts( 10, 20 ,30 );\n \nint[] intArray = {1, 2, 3};\nListInts( intArray );\n如果没有实参，创建零个或一个元素的数组\n别名\nref int y = ref x;\nref int RefToValue(){\n\treturn ref Score;\n}\nref int x = ref xxx.RefToValue();\n要求ref return不能返回空值，常量，枚举成员，类或结构体的属性，指向只读位置的指针\n只能返回原先调用域中的\nref局部变量只能被赋值一次\n命名参数\nint Calc(int a, int b, int c){}\nxxx.Calc(c:2, a:4, b:3);\n与位置参数同时使用时，位置参数必须全部出现在前\n可选参数\n默认值必须在编译时确定，引用类型null\n顺序必须依次为必填参数，可选参数，params参数\n省略不能任意组合，只能省略最后n个参数\n如果要任意省略，需要使用命名参数\nconst\n必须初始化且编译时确定\n成员常量\n编译时被替换 没有存储位置\n没有类实例也能访问 不能声明为static\n属性\n \n属性本身没有存储什么，set访问器有一个隐式值参value\n不能显式调用属性\n属性是函数成员\n可以声明为static\n自动实现属性\npublic int MyValue{\n\tset;get;\n}\n静态构造函数\n只能有一个 不能带有参数 不能有访问修饰符 自动调用\n对象初始化语句\nnew TypeName {};\nnew TypeName() {};//先构造函数\n初始化的值必须是public的\nreadonly\n修饰字段 类似const 但不需要在声明时初始化 不需要编译时决定"},"ddia":{"title":"ddia","links":[],"tags":[],"content":"data system\n包括数据库，流式任务，缓存，索引，批处理\n流式处理:持续发送消息至另一个进程， 处理采用异步方式。\n批处理:定期处理大最的累积数据\n可靠性\n我们无法防止发生任何的故障，但我们可以保证不让局部的故障变成全局系统的失效\n不可靠组件上构建可靠系统"},"git":{"title":"git","links":[],"tags":[],"content":"cd想要创建仓库的位置\ngit init\ngit add &lt;file&gt;\n查看状态\ngit status\n保存 -m可以附加一条信息\ngit commit -m &lt;MESSAGE&gt;\n查看提交记录\ngit log\n查看提交信息 使用提交记录中的id\ngit show &lt;id&gt;\n修改文件后直接commit是无效的（也可以观察到status里面的提示），需要再次将文件add\n回滚 （会自动为其更改的文件执行git add）\ngit checkout &lt;id&gt; &lt;path&gt;\n\nUnstage\ngit reset HEAD &lt;file&gt;\n修改（取代）最新的commit\ngit commit --amend\ngit push origin master\ngit clone [remote-repo-URL]\ngit remote add [remote-repo-name] [remote-repo-URL]\ngit remote -v\ngit pull [remote-repo-name] master\ngit push [remote-repo-name] master"},"index":{"title":"Crypter","links":["操作系统","算法","编译原理","Daily/2023-12-23","IO缓冲"],"tags":[],"content":"你好\n操作系统\n算法\n编译原理\njyy 可执行文件相关笔记\nNeon Genesis\nIO缓冲\n"},"java":{"title":"java","links":[],"tags":["编程语言"],"content":"Walrus a = new Walrus(1000, 8.3);\nstring不属于原始类型（byte, short, int, long, float, double, boolean, char）其余都被称为reference type\n在java中对象的变量是指针 对象声明时开辟64bit空间存储地址 需要用new来为对象的实际内容开辟空间 复制对象即复制指针\n对象并不是引用传递 而是按值传递引用 创建了一个新的指针指向同一块内存，在c中出现的swap指针函数在java中无法达到目的\n原始类型按值传递\npublic class SLList {\n   private static class IntNode {\n      public int item;\n      public IntNode next;\n      public IntNode(int i, IntNode n) {\n         item = i;\n         next = n;\n      }\n   }\n   private IntNode sentinel;\n   private int size;\n   public SLList() {\n      sentinel = new IntNode(-1, null);\n      size = 0;\n   }\n   public SLList(int x) {\n      size = 1;\n      sentinel = new IntNode(-1, null);\n      sentinel.next = new IntNode(x, null);\n   }\n   public void addFirst(int x) {\n      size += 1; \n      sentinel.next = new IntNode(x, sentinel.next);\n   }\n   public void addLast(int x) {\n      size += 1;\n      IntNode p = sentinel;\n      while (p.next != null) {\n         p = p.next;\n      }\n \n      p.next = new IntNode(x, null);\n   }\n}\n不需要被外部类访问所以使用private 不需要访问SLList的实例 所以使用static\npublic class SLList&lt;BleepBlorp&gt;{...}\nDLList&lt;Double&gt; s1 = new DLList&lt;&gt;(5.3);\nfinal\n对于变量，表示其不会再变成引用别的变量，但是引用的对象内容可以修改\n对于类，表示其不能被继承\n对于方法，表示不能被覆盖\n返回对象\n返回可变对象的引用，应该先克隆 return (Date) hireDay.clone();\n显式字段初始化\n可以直接在类定义中为字段赋值\nclass Employee{\n\tprivate static int nextId;\n\tprivate int id = assignId();\n\tprivate static int assignId(){\n\t\tint r = nextId;\n\t\tnextId++;\n\t\treturn r;\n\t}\n}\nthis/super\n构造函数中调用其他构造函数 必须在最前面\n表示该对象或父类\n静态导入\nimport static java.lang.System.*\n不止导入所有类，还导入静态方法和字段（可以省略System.out中的System）\n数组类型转换\nManager[] managers = new Manager[10];\nEmployee[] staff = managers; // ok\nstaff[0] = new Employee();\nmanagers[0].setBonus() //???\nGeneric\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n原始类型引用类型intIntegerdoubleDoublecharCharacterbooleanBooleanlongLongbyteByteshortShortfloatFloat\nArray 引用\nint[] x = new int[3];\nint[] y = new int[]{1, 2, 3, 4, 5};\nint[] z = {9, 10, 11, 12, 13};\nint l = z.length;\nSystem.arraycopy(b, 0, x, 3, 2);\n原array，原array的复制起始位置，目标array，目标array的黏贴起始位置，复制数量\nint[][] pascalsTriangle = new int[4][];\npascalsTriangle[0] = new int[]{1};\npascalsTriangle[1] = new int[]{1, 1};\npascalsTriangle[2] = new int[]{1, 2, 1};\npascalsTriangle[3] = new int[]{1, 3, 3, 1};\nint[] rowTwo = pascalsTriangle[2];\nrowTwo[1] = -5;\n \nint[][] matrix;\nmatrix = new int[4][];//Create 1 array\nmatrix = new int[4][4];//Create 5 arrays\n \nint[][] pascalAgain = new int[][]{{1}, {1, 1},\n                              \t{1, 2, 1}, {1, 3, 3, 1}};\n \npublic class AList&lt;Glorp&gt; {\n    private Glorp[] items;\n    private int size;\n    public AList() {\n        items = (Glorp []) new Object[8];\n        size = 0;\n    }\n}\n由于泛型数组存储的是对象的引用，要确实地删除对象地引用，保证不loiter 浪费内存\npublic Glorp deleteBack() {\n    Glorp returnItem = getBack();\n    items[size - 1] = null;\n    size -= 1;\n    return returnItem;\n}\nsllist和alist都应属于list，定义接口，接口规定要实现的内容\npublic interface List61B&lt;Item&gt; {\n    void addFirst(Item x);\n    default public void print() {\n        for (int i = 0; i &lt; size(); i += 1) {\n            System.out.print(get(i) + &quot; &quot;);\n        }\n        System.out.println();\n    }\n}\npublic class AList&lt;Item&gt; implements List61B&lt;Item&gt;{...}\ninterface可以存变量，但变量是public static final不能改变\n对于继承方法，函数参数与接口定义完全相同为override，不同为overload\n返回类型override\n允许子类将override方法的返回类型改为原返回类型的子类型\n可选：在override的方法前标注@Override，若方法并不是override则不编译\n上面的print()方法在SLList应当override\n要使类继承另一个类，使用extend关键字\npublic class RotatingSLList&lt;Blorp&gt; extends SLList&lt;Blorp&gt;{\n\tpublic void rotateRight() {\n\t\tBlorp oldBack = removeLast();\n\t\tinsertFront(oldBack);\n\t}\n}\npublic class VengefulSLList&lt;Item&gt; extends SLList&lt;Item&gt; {\n    private SLList&lt;Item&gt; deletedItems;\n    public VengefulSLList() {\n        super();\n    \tdeletedItems = new SLList&lt;Item&gt;();\n    }\n    @Override\n    public Item removeLast() {\n        Item oldBack = super.removeLast();\n        deletedItems.addLast(oldBack);\n        return oldBack;\n    }\n    public void printLostItems() {\n    \tdeletedItems.print();\n    }\n}\njava中 变量是静态绑定的，方法（除static）是静态绑定的\njava中有变量同时拥有有动态类型和静态类型，静态类型不能改变，是声明时的类型，动态类型可以在赋值中改变。\nfoo.bar(x1)编译器会记录foo的静态类型对x1的静态类型的对应函数。如果foo的动态类型overridebar方法，会执行动态类型对应的，否则执行记录的。\n编译器类型检查根据静态类型，将父类赋给子类等行为会导致编译失败\n判断赋值能不能通过编译，可以通过判断是否满足右边is a左边\n强制类型转换\nif (staff instanceof Manager){\n\tboss = (Manager) staff;\n}\nString C = (String) staff;\n在继承链自下而上强制转换时会产生ClassCastException，如果更加错的离谱的会编译错误\ncast 不会造成改变 只是对编译器的\n抽象类\n可包括抽象方法，字段和具体方法\n抽象方法是没有被实现的\n不能创建抽象类的对象，但是可以有抽象类的对象变量引用到他的具体子类对象\n自定义比较的实现思路\nComparable是内建的类，已经对一些自带的类实现比较\n实现比较的类（如Dog）implements Comparable&lt;Dog&gt;中的compareTo(Dog)方法\n调用方调用继承了Comparable接口的对象\nimport java.util.Comparator;\nComparator实现各种不同标准的比较\n实现比较的类（如Dog）中嵌套类NameComparator（static）implementsComparator&lt;Dog&gt;实现compare(Dog,Dog)方法\n将嵌套类设为private，在类中提供返回comparator的static方法 比较器的类型应由Dog.NameComparator改为Comparator&lt;Dog&gt;\ninterface提供了实现callback的能力，通过implement comparable只能实现一种比较，而comparator的多态能提供多种比较\ncomparable将自己与其他比较，comparator将两种作比较\njava提供Collection类\n\n\npackage\nautoboxing和unboxing\nimmutable没有“可发现的”方法改变，如Integer,String,Date\ngeneric method在返回类型前加&lt;&gt;\n&lt;K extends Comparable&lt;K&gt;&gt;\n程序异常时会从调用栈一层层寻找catch，如果没有则程序crash，会打印调用栈\nchecked异常会使得编译失败\ncatch那些checked异常或在方法后面声明throws xxException\nIterable Iterator\n\naccess control基于static类型\n所有object都有toString()方法\n检查是否指向同一，.equals()默认是\n.getClass()"},"leveldb":{"title":"leveldb","links":[],"tags":[],"content":"Slice\n提供了可共用数据段指针的string实现\nArena\n内存管理\n维护了多段内存\n记录了自己使用的内存情况（内存分配+每段内存的头指针大小）"},"libc":{"title":"libc","links":[],"tags":["example-tag"],"content":"C标准历史\nK&amp;R C 并没有标准化的早期\n之后的标准化的版本都属于ISO C或者Standard C系列\nANSI C一般等同于C89\nC95,C99,C11…\nC标准库头文件\nPOSIX\nPOSIX 是标准 C 库的超集，并且 POSIX 在某些方面会参考 C 标准库。如果 C 标准库和 POSIX 之间存在冲突，则以 C 标准库为准。\nPOSIX标准头文件\nC POSIX librarywiki整理的不在C语言标准库之内的POSIX标准的头文件\nPOSIX除了定义C API，还定义了很多别的，比如shell语言等等。\nstandard - What exactly is POSIX? - Unix &amp; Linux Stack Exchange\n可能将来 POSIX 线程（pthreads）会被 C11 的线程库所取代，但目前 C11 的线程库尚未得到广泛部署。因此，如果你需要代码的移植性，当前应优先使用 POSIX 线程。如果移植性不是问题，并且你可以使用 C11 的线程库，那么你可以考虑使用 C11 的线程库。"},"make":{"title":"make","links":[],"tags":[],"content":"&lt;target&gt; : &lt;prerequisites&gt; \n[tab]  &lt;commands&gt;\ntarget可以是文件名代表生成对象，或者是自定义操作名\n.PHONY声明一个名称为伪目标（操作），防止与文件重名\nprerequisites代表依赖关系\n.RECIPEPREFIX可以修改tab标记为别的键\ncommands默认在不同的shell执行（影响export这种）\n解决方法分号分隔命令或者.ONESHELL:\ncommands中的命令会被打印，可以在命令前加@制止"},"python":{"title":"python","links":[],"tags":["编程语言"],"content":"逻辑运算符\nx and y 如果 x 为 False，返回 x ，否则返回 y 。\nx or y    如果 x 是 True，返回 x ，否则返回 y 。\n在错误信息中，最近调用的函数在最下方。\n计算嵌套表达式\n计算operator和operend\nlambda表达式\nlambda &lt;parameters&gt;: &lt;return expression&gt;\n先从左到右计算所有表达式，再赋值\nx = 10\ny = x\nx = 20\nx, y = y + 1, x - 1 #x=11 y=19\n先在local frame中找该名字，再在global frame中找\n\nfrom operator import mul\ndef square(square):\n\treturn mul(square, square)\nsquare(-2)\npython -i ex.py //用intepreter运行\npython -m doctest -v ex.py\nprint(print(1), print(2)) //print的返回值是None\n&#039;&#039;&#039;\n1\n2\nNone None\n&#039;&#039;&#039;\npython支持多个返回值\ndocstring, doctest\nfrom operator import floordiv, mod\ndef divide_exact(n, d):\n\t&quot;&quot;&quot;Return the quotient and remainder of dividing N by D.\n\t&gt;&gt;&gt;q, r = divide_exact(2013, 10)\n\t&gt;&gt;&gt;q\n\t201\n\t&gt;&gt;&gt;r\n\t2\n\t&quot;&quot;&quot;\n\treturn floordiv(n, d), mod(n, d)\nquotient, remainder = divide_exact(2013, 10)\n \nassert 2 &gt; 3, &#039;That is false&#039;\n环境 嵌套\n\n当函数被定义时：\n创建一个function value: func &lt;name&gt;(&lt;formal parameters&gt;) [parent=&lt;parents&gt;] Its parent is the current frame. Bind to the function value in the current frame\n当函数被调用时：\n\nAdd a local frame, titled with the &lt;name&gt; of the function being called.\nCopy the parent of the function to the local frame: [parent=&lt;label&gt;]\nBind the &lt;formal parameters&gt; to the arguments in the local frame.\nExecute the body of the function in the environment that starts with the local frame\n\nlambda的parent是它所在的frame\n装饰器\nfrom ucb import trace\n \n@trace\ndef fib(n): \ndef zero(f):\n    return lambda x: x\n \n \ndef successor(n):\n    return lambda f: lambda x: f(n(f)(x))\n \ndef one(f):\n    return lambda x: f(x)\n \ndef two(f):\n    return lambda x: f(f(x))\n \ndef church_to_int(n):\n    &quot;&quot;&quot;Convert the Church numeral n to a Python integer.\n \n    &gt;&gt;&gt; church_to_int(zero)\n    0\n    &gt;&gt;&gt; church_to_int(one)\n    1\n    &gt;&gt;&gt; church_to_int(two)\n    2\n    &gt;&gt;&gt; church_to_int(three)\n    3\n    &quot;&quot;&quot;\n    return n(lambda x: x + 1)(0)\n \ndef add_church(m, n):\n    &quot;&quot;&quot;Return the Church numeral for m + n, for Church numerals m and n.\n \n    &gt;&gt;&gt; church_to_int(add_church(two, three))\n    5\n    &quot;&quot;&quot;\n    return lambda f: lambda x: n(f)(m(f)(x))\n \n \ndef mul_church(m, n):\n    &quot;&quot;&quot;Return the Church numeral for m * n, for Church numerals m and n.\n \n    &gt;&gt;&gt; four = successor(three)\n    &gt;&gt;&gt; church_to_int(mul_church(two, three))\n    6\n    &gt;&gt;&gt; church_to_int(mul_church(three, four))\n    12\n    &quot;&quot;&quot;\n    return lambda f: m(n(f))\n \n \ndef pow_church(m, n):\n    &quot;&quot;&quot;Return the Church numeral m ** n, for Church numerals m and n.\n \n    &gt;&gt;&gt; church_to_int(pow_church(two, three))\n    8\n    &gt;&gt;&gt; church_to_int(pow_church(three, two))\n    9\n    &quot;&quot;&quot;\n    return n(m)\n递归\n执行顺序\n不重不漏的分解原问题\nList\ndigits = [1, 8, 2, 8]\ngetitem(digits, 3)\n&gt;&gt;&gt; len(digits)\n4\n&gt;&gt;&gt; [2, 7] + digits * 2\n[2, 7, 1, 8, 2, 8, 1, 8, 2, 8]\n&gt;&gt;&gt; 1 in digits\nTrue\n&gt;&gt;&gt; 5 not in digits\n&gt;&gt;&gt; not(5 in digits)\n&gt;&gt;&gt; [1, 8] in digits #属于关系\nFalse\n \n[&lt;expression&gt; for &lt;element&gt; in &lt;sequence&gt; if &lt;conditional&gt;]\n[x for x in range(10) if 10 % x == 0]\nthe negative index -i is equivalent to the positive index len(lst)-i\nList slicing\nTo create a copy of part or all of a list, we can use list slicing. The syntax to slice a list lst is: lst[&lt;start index&gt;:&lt;end index&gt;:&lt;step size&gt;].\nThis expression evaluates to a new list containing the elements of lst:\n\nStarting at and including the element at &lt;start index&gt;.\nUp to but not including the element at &lt;end index&gt;.\nWith &lt;step size&gt; as the difference between indices of elements to include.\n\nIf the start, end, or step size are not explicitly specified, Python has default values for them. A negative step size indicates that we are stepping backwards through a list when including elements.\n&gt;&gt;&gt; lst[:3]   # Start index defaults to 0\n[6, 5, 4]\n&gt;&gt;&gt; lst[3:]   # End index defaults to len(lst)\n[3, 2, 1, 0]\n&gt;&gt;&gt; lst[::-1]   # Make a reversed copy of the entire list\n[0, 1, 2, 3, 4, 5, 6]\n&gt;&gt;&gt; lst[::2]  # Skip every other; step size defaults to 1 otherwise\n[6, 4, 2, 0]\nfor\nfor element in s:\n \npairs = [[1, 2], [2, 2], [3, 2], [4, 4]]\nfor x, y in pairs:\nrange\n&gt;&gt;&gt; list(range(-2, 2))\n[-2, -1, 0, 1]\n&gt;&gt;&gt; list(range(4))\n[0, 1, 2, 3]\n \nfor i in range(n):\n\n方括号内的内容可省略\nsum(iterable[, start])\nsum([[1, 2],[3, 4]], [])\n \nmax(iterable[,key=func])\nmin(iterable[,key=func])\nall(iterable)\nexec(&#039;curry = lambda f: lambda x: lambda y: f(x, y)&#039;)\ncurry(add)(3)(4)\nString\n单引号和双引号等价\n三引号可以跨行\nstring的元素仍然是string\nDictionary\n{&lt;key exp&gt;:&lt;value exp&gt; for &lt;name&gt; in &lt;iter exp&gt; if &lt;filter exp&gt;}\ntuple\n元组 不可变 用逗号分隔的\n内含可变元素可变\nidentity is\nIdentity is evaluates to True if both and evaluate to the same object Equality ==\nevaluates to True if both and evaluate to equal values Identical objects are always equal values\n函数默认参数为mutable时 不会被类似初始化重新赋值\nSome files are plain text and can be read into Python as either:\nOne string containing the whole contents of the file: open(‘/some/file.txt’).read()\nA list of strings, each containing one line: open(‘/some/file.txt’).readlines()\nUseful string methods for processing the contents of a file:\n.strip() returns a string without whitespace (spaces, tabs, etc.) on the ends\n.split() returns a list of strings that were separated by whitespace\n.replace(a, b) returns a string with all instances of string a replaced by string b\nA container can provide an iterator that provides access to its elements in order\niter(iterable): Return an iterator over the elements of an iterable value\nnext(iterator): Return the next element in an iterator\nlist(t) 所有剩余元素的list\niterator可变\n可以用for遍历\nmap(func, iterable) 返回一个iterator\nfilter(func, iterable)返回下一个为真的func(x)\nzip(first_iter, second_iter)\nreversed(sequence)\nlist/tuple/sorted(iterable)\nThe built-in zip function returns an iterator over co-indexed tuples.\nIf one iterable is longer than the other, zip only iterates over matches and skips extras.\nMore than two iterables can be passed to zip."},"分组背包":{"title":"分组背包","links":[],"tags":["算法"],"content":"集合：\n只从前i组物品当中选，且总体积不超过j的情况下的所有选法\n属性：\n所有选法价值的最大值。\n状态计算：\n集合划分为，第i组物品中不选或选了第k个\n从而状态转移方程为：f[i][j] = max(f[i-1][j], f[i-1][j-v[i][k]] + w[i][k])\n三重循环：物品 体积 决策"},"动态规划":{"title":"动态规划","links":["01背包","完全背包","多重背包","分组背包"],"tags":["算法"],"content":"动态规划\n拓扑序\n背包问题\n01背包\n01背包\n完全背包\n完全背包\n多重背包\n多重背包\n分组背包\n分组背包\n二维费用背包\n集合：只从前i个物品中选，花费1不超过j，花费2不超过k的选法\n状态计算：f[i][j][k] = max(f[i-1][j][k], f[i-1][j-v1[i]][k-v2[i]] + w[i][k])\n三种不同划分的比较\n以选法为例，最大值最小值同理\n集合：恰好是k的选法\nf[0]=1,f[k≠0]不存在，此处为0\n集合：至少是k的选法\nf[0]=1,f[k≠0]不存在，此处为0，且k为负数时合法，视为0\n集合：不超过k的选法\nf[k]=1\n线性DP\n数字三角形：从顶点出发到i,j的最大路径和\n方格取数：所有从顶点出发走到(i1,k-i1)(i2,k-i2)的路径\n按照两次路径的来自方向可分为四类\n最长上升子序列\n集合：所有以第i个数结尾的上升子序列\n怪盗基德的滑翔翼：\n所有上升子序列和下降子序列\n最长公共子序列\n集合：所有在第一个序列的前i个字母中，第二个序列的前j个字母中出现的子序列\n按照第i，j个字母是否出现可分为四类\n其中，i不出现j出现这一情况可用f[i-1,j]表示，虽然这个表示并不保证j一定出现，但不影响结果，i出现j不出现同理\ni，j都不出现被包含于上述两种，i，j都出现时（即要求相等）时有f[i-1][j-1]+1\n从而状态转移方程为：f[i][j] = max(f[i-1][j],f[i][j-1],f[i-1][j-1]+1)\n最长公共上升子序列\n集合：所有在第一个序列的前i个字母中，第二个序列的前j个字母中出现，且以b[j]结尾的公共上升子序列\n按a[i]是否出现分为两类，a[i]不出现时即为f[i-1,j]\na[i]出现时(a[i]=b[j])，按照上一个元素为k=b[1...j-1]分为若干类，为f[i-1,k]+1\n区间DP\n石子合并\n集合：将第i堆石子到第j堆石子合并成一堆石子的合并方式\nf[i][j] = min(f[i,k]f[k+1,j]+s[i,j])\n环形石子合并\n可将题目看作在相邻的石子中连边，一共连n-1条边，根据“缺口”位置在石子合并的基础上再多一重循环 O(n^4)\n要求的是n条长度为n的链上的最小值，可以发现将链重复两边，可以在这条长度为2n的链上找到所有上述的链\n状态压缩DP\n蒙特里安的梦想\n只枚举横向摆放的情况\nf[i,j]对应第i列，被上一列伸出状况以二进制数j表示\n与f[i-1,k]应满足 j&amp;k=0 j|k不存在连续奇数个零\nf[0,0]=1\n答案为f[m,0]\n最短Hamilton路径\n集合：所有从0走到j，经过的点为二进制表示i的路径\n小国王\n集合：只摆在前i行，摆了j个国王，第i行摆放状态是k的集合\n转移：f[i][j][a]是所有满足a&amp;b==0和a|b没有相邻的1的bf[i-1][j-count(a)][b]的和\n玉米田\n集合：只摆在前i行，第i行摆放状态是j的集合\n转移：f[i][a]是所有满足a&amp;b==0和a，b都没有相邻的1的bf[i-1][j-count(a)][b]的和\n炮兵阵地\n集合：只摆在前i行，第i-1行摆放状态是j，第i行摆放状态是k的集合\n转移：f[i][a][b]是所有满足a,b,c在相同位上不同时有1且a,b相邻3位上至多只有一个1的f[i-1][c][a]+b中1的个数 的最大值\n树形DP\n没有上司的舞会\n集合：所有以u为根的树中选择，选和不选u的方案\n有依赖的背包问题\n集合：所有以u为根的树中选择，体积不超过j的方案\n树的最长路径\ndfs从子节点更新到父节点，以该节点为根且从不同子节点出发的最长和次长的路径，是该节点向下的路径\n树的中心\ndfs从子节点更新到父节点，以该节点为根且从不同子节点出发的最长和次长的路径，是该节点向下的路径\n再dfs从父节点更新到子节点，子节点的向上路径是父节点向上或向下（向下不能是该子节点）的最大路径加上子节点到父节点的路径\n二叉苹果树\n有依赖的背包问题\nf[i][j]以i为根的树中选j条边的最大价值\n战略游戏\n类似没有上司的舞会\n集合：以i为根的树中，点i选或不选的所有选法\nf[i][0]=f[s1][1]+…\nf[i][1]=1+min(f[s1][0],f[s1][1])+…\n皇宫看守\n集合：以i为根的树中，点i状态为j的所有选法\n被父节点看到f[i][0]=Σmin(f[j][1],f[j][2])\n被子节点看到 任选一个子节点为状态2，其余min(f[j][1],f[j][2]) 所有这样的最小值 \n自己f[i][2]=Σmin(f[j][0],f[j][1],f[j][2])+w[i]\n数位DP\n一般用前缀的方式计算，注意自己定义的是0-n中还是1-n中\n计数问题\n计算0-n中每个数字x在每个位上的出现次数（能构造出多少个数在某位上有x）\n将n的数位分为三部分l mid r\n先枚举l部分小于l的数\n当计算0时，l部分须大于等于1，当计算非0时，l部分可以为0。然后r部分可以任取\n再计算r部分时（即枚举l部分等于l的数）（l=0且x=0时不计算，不存在这种有前导0的数），若mid=x，则r部分可以取0-r，若mid&gt;x，则r部分任取\n\n度的数量\n即求0~n中有多少数是b进制表示下只含有k个1，其余皆为0的数\n从高位往下看，若该位大于1，则可以取遍0到全是1的情况（可以直接计算出），直接break，若等于1，则有两种选择，一种该位置为0，在剩下的数中放1（可以直接计算出）。一种该位置为1，剩下的数中能放的1减少。最后记得处理1枚举完的情况\n数字游戏\n求不降数数量\n取0-an-1-1时，用动态规划求出\n取an-1时，保证比上一位不降\n集合：最高位为j，且共有i位的不降数\nf[i][j]=Σf[i-1][k](k&gt;=j)\nWindy数\n注意(0)137不会被计算到f[4][0]，含前导零的情况要额外加一遍\n或者说，设该数共n位，最高位取0的情况（1-99999999（n-1 个九））实际上是Σf[1~n-1][0~9]\n恨七不成妻\nT[i][j][a][b]i位数，最高位为j，该数模7余a，各位数字模7余b\nT[i][j][a][b]由T[i-1][k][a-j*10^(i-1)][b-j]转移\n\\begin{gather}\nS_0&#039;+=S_0\\\\\nv_1.s_0+=v_2.s_0\\\\\nS_1&#039;+=\\overline{kA_1}+\\overline{kA_2}+...+\\overline{kA_{s_0}}=S_0*k*10^n+S_1\\\\\nv_1.s_1+=v_2.s_0*k*10^{i-1}+v_2.s_1\\\\\nS_2&#039;+=\\overline{kA_1}^2+\\overline{kA_2}^2+...+\\overline{kA_{s_0}}^2=S_0*(k*10^n)^2+2*k*10^n*S_1+S_2\\\\\nv_1.s_2+=v_2.s_0*(k*10^{i-1})^2+2*k*10^{i-1}*v_2.s_1+v_2.s_2\n\\end{gather}\n记忆化搜索\n滑雪\n集合：所有从(i,j)开始滑的路径\n状态机模型\n集合：所有从前i个物品中选，状态为j的方案\n大盗阿福\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n结点可转移到偷窃不偷窃不偷窃不偷窃，偷窃\n股票买卖IV\nf[i][j][0]：第i天，已经进行完j次交易\nf[i][j][1]：第i天，正在进行第j次交易\n状态转移方程是：\nf[i][j][0] = max(f[i-1][j][0], f[i-1][j][1]+w[i])\nf[i][j][1] =max(f[i-1][j][1], f[i-1][j-1][0]-w[i])\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n结点可转移到持有不持有，持有不持有不持有，持有\n股票买卖V\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n结点可转移到持有不持有的第一天，持有不持有的第一天不持有的第二天及之后不持有的第二天及之后不持有的第二天及之后，持有\nf[i][0]=max(f[i-1][0],f[i-1][2]-w)\nf[i][1]=f[i-1][0]+w\nf[i][2]=max(f[i-1][1],f[i-1][2])\n设计密码\n集合：密码串的前i个字母的最后j个字母和模板串前j个字母匹配的方案\n转移：f[i+1][u]=f[i][j1]+f[i][j2]+…\n密码串的第i+1个字母选择a~z导致j转移到不同的u\nf[0][0]=1 答案为f[n][0]+…+f[n][m-1]\n单调队列优化\n最大子序和\n将问题分类为以序列中哪个元素为结尾的序列\n引入前缀和后问题即为求s[k]-s[k-j] (1&lt;=j&lt;=m)的最大值，滑动窗口解决\n旅行问题\n环拉成链\n记录每两个相邻点的油量与距离之差，则题意为所有前区间和大于等于0，也即所有长度为环的长度的窗口中区间和最小值大于等于0\n顺时针下ii+n-1中最小为j，需满足s[j]-s[i-1]&gt;=0，逆时针下i-n+1i，需满足s[j]-s[i+1]&gt;=0\n烽火传递\n集合：1-i合法，且点燃第i个烽火台的方案\nf[i]=min(f[j])+w[i] i-m&lt;=j&lt;i\n绿色通道\n二分，寻找满足时间不超过t的最长空题段 的最小值\n最长空题段是上一题中的每多少个烽火台至少有一个烽火台的限制，时间是代价\nf[i]=min(f[j])+w[i] i-limit-1&lt;=j&lt;i\n修剪草坪\n集合：从前i头牛中选的方案\n由于不能连续选k个，根据在哪个牛不选来分类\nf[i]=max(f[i-1],f[i-x-1]+s[i]-s[i-x]) 1&lt;=x&lt;=k i-k&lt;=i-x&lt;i\n代表不选i-x牛，选i-x到i中的牛\n单调队列计算使f[i-x-1]-s[i-x]最大的i-x\n考虑x=i时，代表前i头中全选，应视f[i-x-1]为0\n理想的正方形\n对每行求滑动窗口，再对每列求\n斜率优化\n任务安排1，2\n将启动时间对所有后续任务影响特殊处理\n集合：前i个任务的方案\nf[i]=min(f[j]+sumt[i]* (sumc[i]-sumc[j])+s*(sumc[n]-sumc[j]))j&lt;i\n斜率优化\nf[j]=(sumt[i]+s)*sumc[j]+f[i]-sumt[i] *sumc[i]-s *sumc[n]\n对于任意给定的i，视f[j]为y，sumc[j]为x，则斜率与j无关为定值且为非正无穷正数，取不同的x确定不同的f[i]\n通过图像观察可知，只保留“凸包”上的点，找到第一个斜率大于k的点\n在本题中，随着i递增，x递增，在插入的时候可以删除队尾不在凸包上的点，（待查询的）k也递增，因此查询的时候可以删除队头小于查询值的点\n\n任务安排3\n本题中斜率不是单调递增，只能二分查找\n运输小猫\n接到猫的最早时间是t[i]-d[i]，记作a[i]\n人为将猫最早时间排序 接走i~j猫的最早时间为a[j]，等待时间为(j-i+1)*a[j]-s[j]+s[i-1]\nf[j][i] j个饲养员，取前i只小猫的最小花费\nf[j][i]=min(f[j-1][k]+a[i]*(i-k)-s[i]+s[k])\nf[j-1][k]+s[k]=a[i]* k+f[j][i]-a[i]*i+s[i]\n对任意给定i，视f[j-1][k]+s[k]为y，k为x，a[i]递增"},"图图":{"title":"图图","links":[],"tags":[],"content":"光线的表示\n正交和透视投影下光线的出发点和方向\n判定光线与球面的相交\n判定光线与三角形的相交\n判定光线与多边形的相交\n软件流水线 硬件流水线 什么是rasterization pixelwise操作 geometricwise操作"},"多重背包":{"title":"多重背包","links":[],"tags":["算法"],"content":"完全背包加上数量限制\n优化1：类似二进制打包物品 转换成01背包\n优化2：\n\\begin{matrix}\nf[i,j]=max(f[i-1,j-v]+w,f[i-1,j-2v]+2w,...,f[i-1,j-sv]+sw)\\\\\nf[i,j-v]=max(f[i-1,j-2v]+w,f[i-1,j-3v]+2w,...,f[i-1,j-sv]+(s-1)w,f[i-1,j-(s+1)v]+sw)\\\\\nf[i,j-2v]=max(f[i-1,j-3v]+w,f[i-1,j-4v]+2w,...,f[i-1,j-sv]+(s-2)w，f[i-1,j-(s+1)v]+(s-1)w，f[i-1,j-(s+2)v]+sw)\\\\\n\\end{matrix}\n多重背包中求滑动窗口的最大值\n完全背包中求所有前缀的最大值\n滚动数组 因为用到上一层的状态且使用了滑动窗口，所以每次备份上一层的状态"},"完全背包":{"title":"完全背包","links":[],"tags":["算法"],"content":"状态转移方程：\nf[i][j] = max(f[i - 1][j - k * v[i]] + k * w[i])\n由状态转移方程f[i][j]和f[i][j - v[i]]展开并比较它们\nf[i][j - v[i]] = max(f[i - 1][j - v[i] - k * v[i]] + k * w[i])\n后式少了一项f[i-1][j]，并且每项少w[i]\n可以得出简化后的等价状态转移方程f[i][j]=max(f[i - 1][j], f[i][j - v[i]]+w[i])"},"操作系统":{"title":"操作系统","links":[],"tags":["example-tag"],"content":"操作系统导论中的一组概念\n机制：功能的实现\n策略：智能，做出的决定\n进程的组成包括寄存器，其访问的内存（地址空间），程序计数器\nunix中提供的进程API\nfork\n创建新进程，在父进程中返回值为子进程ID，在子进程中返回值为0，子进程创建后从fork返回（开始执行）\nwait\nexec\nexecve\n状态机的重置\n一切进程strace的第一个调用\n环境变量会在此时传入（控制了程序行为 ssh同一台机器 行为会在不同的电脑输出结果） 环境变量会继承父进程\nfork和exec的组合使用例子 shell\n机制\n受限直接执行\n有限制，允许进程间切换（上下文切换 硬件时钟中断 硬件保存；操作系统调度 操作系统保存）\n进程调度\n调度指标 周转时间（性能）完成时间-到达时间\nSJF，STCF\n响应时间（交互）首次运行-到达\nRR 公平\n软件是现实世界需求的投影，而（软件）代码这一投影是有损的，比如一个代表金钱的变量应当有所限制，代码并不能很简单直接的表达这一限制\n调试理论 fault到failure中经历了很长的距离，防御性编程这种方式可以迅速捕获fault\n懒得做sanitizer？\n检测数据冒险（图上的可达问题）和潜在死锁的方式\n信号量\n挺适合表示表示先后关系（前驱图）\n内存虚拟化\n页表 多重页表 页表目录\n操作系统在完成了初始化工作之后感觉就变成了中断处理。（时钟中断， 主动 系统调用等）"},"数据库/并发控制":{"title":"并发控制","links":[],"tags":[],"content":"read-write\n不可重复读\nwrite-read\n脏读\nwrite-write\n丢失更新"},"算法":{"title":"算法","links":["算法","动态规划"],"tags":["算法"],"content":"排序\n二分\n比较好记的染色法\n从一个没有染色的区间开始处理，直至完成染色\n开区间版本实现\nl = -1,r = N;//数组长度N\n// (l,r)是未被染色的区间\n// l是蓝色，r是红色\nwhile(l + 1 != r){//区间不为空\n\tm = (l + r) / 2;\n\tif(isBlue(m)) l = m;\n\telse r = m;\n}\nreturn l or r;\nl&lt;r-1，m=(l + r) / 2总是在(l, r)，区间总是能保证缩小，且缩小最多是正好变成空区间\nl + r &gt; 2l + 1 &gt; 2l\nl + r &lt; 2r - 1 &lt; 2r\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nIsBlue()条件返回第一个&gt;=x&lt;xr最后一个&lt;x&lt;xl第一个&gt;x⇐xr最后一个&lt;x⇐xl\n闭区间版本实现\nl = 0,r = N - 1;//数组长度N\n// [l,r]是未被染色的区间\n// l - 1是蓝色，r + 1是红色\nwhile(l &lt;= r){//区间不为空\n\tm = (l + r) / 2;\n\tif(isBlue(m)) l = m + 1;\n\telse r = m - 1;\n}\nreturn r or l;// ? return l - 1 or r + 1\nm=(l + r) / 2总是在[l, r]，区间总是能保证缩小，且缩小最多是正好变成空区间\n\n整数二分\n边界一定存在，但边界不一定是原问题的解\n浮点二分\n快速排序\nvoid quick_sort(int q[], int l, int r)\n{\n    if (l &gt;= r) return;\n\tint i = l - 1, j = r + 1, x = q[l + r &gt;&gt; 1];\n    while (i &lt; j)\n    {\n        do i ++ ; while (q[i] &lt; x);\n        do j -- ; while (q[j] &gt; x);\n        if (i &lt; j) swap(q[i], q[j]);\n    }\n    quick_sort(q, l, j), quick_sort(q, j + 1, r);\n}\n如何使得x左侧都小于等于 右侧都大于等于\n1.开两个新数组分别存再拷回来 同样是O(N)\n2.双指针\n注意选择以i分治时不能取x[l] j时不能[r] 容易边界问题 反例{1 2}\n中间元素取l+r+1/2和不加1\ni-1 i/j j+1对于i指针 指针停的位置是大于等于x的 之前的是小于等于x的\n快速排序如何变成稳定的 将索引也纳入\n归并排序\nvoid merge_sort(int q[], int l, int r)\n{\n    if (l &gt;= r) return;\n    int mid = l + r &gt;&gt; 1;\n    merge_sort(q, l, mid);\n    merge_sort(q, mid + 1, r);\n \n    int k = 0, i = l, j = mid + 1;\n    while (i &lt;= mid &amp;&amp; j &lt;= r)\n        if (q[i] &lt;= q[j]) tmp[k ++ ] = q[i ++ ];\n        else tmp[k ++ ] = q[j ++ ];\n \n    while (i &lt;= mid) tmp[k ++ ] = q[i ++ ];\n    while (j &lt;= r) tmp[k ++ ] = q[j ++ ];\n \n    for (i = l, j = 0; i &lt;= r; i ++, j ++ ) q[i] = tmp[j];\n}\n高精度加法\n高精度减法\n高精度乘法\n高精度除法\n前缀和\nO(1)区间查询\n一维\n\\begin{matrix}\ns[i]=a[1]+a[2]+...+a[i]\\\\\ns=s[r]-s[l-1]\n\\end{matrix}\n二维\n\\begin{matrix}\ns[i][j]=s[i-1][j]+s[i][j-1]-s[i-1][j-1]+a[i][j]\\\\\ns=s[i2][j2]-s[i1-1][j2]-s[i2][j1-1]+s[i1-1][j1-1]\n\\end{matrix}\n差分\nO(1)区间修改（加减某个数）\n\\begin{matrix}\np[i]=a[i]-a[i-1]\\\\\na[i]=p[i]+a[i-1]=p[1]+p[2]+...+p[i]\n\\end{matrix}\np[i]+c则a[i...n]+c\n因此，为了使区间[L,R]中的所有元素+c，只需p[l]+c p[r+1]-c\n二维\np[i][j]=a[i][j]-a[i-1][j]-a[i][j-1]+a[i-1][j-1]\n因此，为了使区间[L,R]中的所有元素+c，只需p[x1][y1]+c p[x2+1][y]-c p[x1][y2+1]-c p[x2+1][y2+1]+c\n树状数组\nO(logn)单点修改，区间查询\nlowbit\ntree[x]存储[x-lowbit(x)+1,x]中数的和\nx的父节点是x+lowbit(x)\nvoid update(int x,int d){\n\twhile (x&lt;N){\n\t\ttree[x]+=d;\n\t\tx+=lowbit[x];\n\t}\n}\n \nint sum(int x){\n\tint ans = 0;\n\twhile (x&gt;0){\n\t\tans+=tree[x];\n\t\tx-=lowbit[x];\n\t}\n}\n \n将树状数组中保存的值运用差分，即可变为区间修改，单点查询\n//区间修改\nupdate(L,x);\nupdate(R+1,-x);\n \nsum(i) //单点查询\nST算法\nO(1)区间最值查询\ndp[s][k]左端点为k，区间长度为2^k的区间最值\ndp[s][k]=min(dp[s][k-1],dp[s+1&lt;&lt;(k-1)][k-1])\n区间[L,R]的最值为min(dp[L][k], dp[R-(1&lt;&lt;k)+1][k]，k为比区间长度小的最大的2的倍数\n线段树\n区间修改涉及到懒惰修改，tag数组意味着未向子树传递的更新量。\nvoid build(int p,int pl,int pr){\n\tif(pl==pr){\n\t\ttree[p]=a[pl];\n\t\treturn;\n\t}\n\tint mid = (pl + pr) &gt;&gt; 1;\n\tbuild(ls(p),pl,mid);\n\tbuild(rs(p),mid+1,pr);\n\ttree[p] = tree[ls(p)] + tree[rs(p)];//\n}\n \n \n//query(L,R,1,1,n)\nint query(int L,int R,int p,int pl,int pr){\n\tif (l&lt;=pl&amp;&amp;pr&lt;=r){\n\t\treturn tree[p];\n\t}\n\tpush_down(p, pl, pr);\n\tint mid = (pl + pr) &gt;&gt; 1;\n\tint res = 0;\n\tif (L&lt;=mid) res += query(L,R,ls(p),pl,mid);//\n\tif (R&gt;=mid+1) res += query(L,R,rs(p),mid+1,pr);//\n\treturn res;\n}\n \nvoid update(int p,int pl,int pr,int x,int k){\n\tif(pl==x&amp;&amp;pr==x){\n\t\ttree[p]+=k;\n\t\treturn;\n\t}\n\tint mid = (pl + pr) &gt;&gt; 1;\n\tif(x&lt;=mid) update(ls(p),pl,mid,x,k);\n\tif(x&gt;=mid+1) update(rs(p),mid+1,pr,x,k);\n\ttree[p] = tree[ls(p)] + tree[rs(p)];//\n}\n \nvoid update(int L, int R, int p, int pl, int pr, int d){\n\tif (L &lt;= pl &amp;&amp; R &gt;= pr){\n\t\taddtag(p, pl, pr, d);\n\t\treturn;\n\t}\n\tpush_down(p, pl, pr);\n\tint mid = (pl + pr) &gt;&gt; 1;\n\tif (L &lt;= mid) update(L, R, ls(p), pl, mid, d);\n\tif (R &gt;= mid + 1) update(L, R, rs(p), mid + 1, pr, d);\n\ttree[p] = tree[ls(p)] + tree[rs(p)];//\n}\nvoid push_down(int p, int pl, int pr){\n\tif(tag[p]){\n\t\tint mid = (pl + pr) &gt;&gt; 1;\n\t\taddtag(ls(p),pl,mid,tag[p]);\n\t\taddtag(rs(p),mid+1,pr,tag[p]);\n\t\ttag[p]=0;\n\t}\n}\nvoid addtag(int p,int pl, int pr,int d){\n\ttag[p]+=d;\n\ttree[p]+=d*(pr-pl+1);\n}\n双指针\nfor (int i = 0, j = 0; i &lt; n; i ++ ){\n    while (j &lt; i &amp;&amp; check(i, j)) j ++ ;\n    // 具体问题的逻辑\n}\n位运算\nlowbit\n返回二进制表达式中最低位的1所对应的位权。\nx&amp;-x\n离散化\n保序 将值域很大但稀疏的数组映射\n// std::vector&lt;int&gt; a, b; // b 是 a 的一个副本 并用b来存储离散化结果\nstd::sort(a.begin(), a.end());\na.erase(std::unique(a.begin(), a.end()), a.end());\nfor (int i = 0; i &lt; n; ++i)\n  b[i] = std::lower_bound(a.begin(), a.end(), b[i]) - a.begin();\n并查集\n路径压缩 按秩合并O(logn)\nint find(int x){\n\tif(x != p[x]) p[x] = find(p[x]);\n\treturn p[x];\n}\n \nvoid merge_set(int x, int y){\n\tx = find(x);\n\ty = find(y);\n\tif(x != y) p[x] = p[y];\n}\n节点到根的关系 关系具有传递性 可以方便求出节点之间关系\n单调队列/栈\n先加入且性质更差的一定不会被输出\n连通集\n单链表\n插入 删除 遍历 建立\n单链表逆转\n每次将旧链表的头插入到新链表（即已经倒转的链表）的尾端 直至旧链表为空（循环不变式）\n邻接表\n双链表 双向循环链表\n栈\n顺序存储实现\nTop指向栈顶前一个结点（仍存在）\n#include&lt;stdio.h&gt;\n#include&lt;stdlib.h&gt;\n#include&lt;stdbool.h&gt;\n#define ERROR -1\ntypedef int Position;\ntypedef struct SNode* PtrToSNode;\nstruct SNode\n{\n    int* Data;\n    Position Top;\n    int maxCount;\n};\ntypedef PtrToSNode Stack;\nStack CreateStack(int maxCount){\n    Stack S = (Stack)malloc(sizeof(struct SNode));\n    S-&gt;Data = (int *)malloc(maxCount * sizeof(int));\n    S-&gt;Top = -2;\n    S-&gt;maxCount = maxCount;\n    return S;\n}\n \nbool IsFull(Stack S){\n    return S-&gt;Top + 2 == S-&gt;maxCount;\n}\nbool IsEmpty(Stack S){\n    return S-&gt;Top + 2 == 0;\n}\nbool AddQ(Stack S,int x){\n    if(IsFull(S)){\n        printf(&quot;堆栈满\\n&quot;);\n        return false;\n    }\n    else{\n        S-&gt;Top++;\n        S-&gt;Data[S-&gt;Top + 1] = x;\n        return true;\n    }\n}\nint DeleteQ(Stack S){\n    if(IsEmpty(S)){\n        printf(&quot;堆栈空\\n&quot;);\n        return ERROR;\n    }\n    else{\n        S-&gt;Top--;\n        return S-&gt;Data[S-&gt;Top + 2];\n    }\n}\n队列\n顺序存储实现\nFront指向队头的前一个结点（已被删除）\n#include&lt;stdio.h&gt;\n#include&lt;stdlib.h&gt;\n#include&lt;stdbool.h&gt;\n#define ERROR -1\ntypedef int Position;\ntypedef struct QNode* PtrToQNode;\nstruct QNode\n{\n    int* Data;\n    Position Front;\n    int Count;\n    int maxCount;\n};\ntypedef PtrToQNode Queue;\nQueue CreateQueue(int maxCount){\n    Queue Q = (Queue)malloc(sizeof(struct QNode));\n    Q-&gt;Data = (int *)malloc(maxCount * sizeof(int));\n    Q-&gt;Front = Q-&gt;Count = 0;\n    Q-&gt;maxCount = maxCount;\n    return Q;\n}\n \nbool IsFull(Queue Q){\n    return Q-&gt;Count == Q-&gt;maxCount;\n}\nbool IsEmpty(Queue Q){\n    return Q-&gt;Count == 0;\n}\nbool AddQ(Queue Q,int x){\n    if(IsFull(Q)){\n        printf(&quot;队列满\\n&quot;);\n        return false;\n    }\n    else{\n        Q-&gt;Count++;\n        Q-&gt;Data[(Q-&gt;Front + Q-&gt;Count) % Q-&gt;maxCount] = x;\n        return true;\n    }\n}\nint DeleteQ(Queue Q){\n    if(IsEmpty(Q)){\n        printf(&quot;队列空\\n&quot;);\n        return ERROR;\n    }\n    else{\n        Q-&gt;Front = (Q-&gt;Front + 1) % Q-&gt;maxCount;\n        Q-&gt;Count--;\n        return Q-&gt;Data[Q-&gt;Front];\n    }\n}\n前缀函数\nπ[i]表示在子串s[0...i]中最长相等的真前缀和真后缀的长度(真意为 不包括子串自身) i取[0,n-1]\n规定π[0]=0\n计算\n第一个重要观察 相邻的前缀函数值至多增加1\n\\underbrace{\\overbrace{s_0~s_1~s_2}^{~\\pi[i]=3}s_3}_{~\\pi[i+1]=4}~\\dots~\\underbrace{~\\overbrace{s_{i-2}~s_{i-1}~s_i}^{\\pi[i]=3}~s_{i+1}}_{~\\pi[i+1]=4}\n当s[i+1]=s[π[i]]时，π[i+1]=π[i]+1\n第二个重要观察\n\\overbrace{\\underbrace{s_0s_1}_{j}s_2s_3}^{\\pi[i]}\\ldots\\overbrace{s_{i-3}s_{i-2}\\underbrace{s_{i-1}s_i}_{j}}^{\\pi[i]}s_{i+1}\n失配时希望找到仅次于π[i]的长度j继续匹配，初始化j=π[i]，迭代j=π[j-1]\nvector&lt;int&gt; prefix_function(string s) {\n  int n = (int)s.length();\n  vector&lt;int&gt; pi(n);\n  for (int i = 1; i &lt; n; i++) {\n    int j = pi[i - 1];\n    while (j &gt; 0 &amp;&amp; s[i] != s[j]) j = pi[j - 1];\n    if (s[i] == s[j]) j++;\n    pi[i] = j;\n  }\n  return pi;\n}\nKMP\n//求next数组=前缀表-1\nint j = -1;\nne[0] = j;\nfor (int i = 1; i &lt; m; i++) {\n    while (j != -1 &amp;&amp; p[i] != p[j + 1]) j = ne[j];\n    if (p[i] == p[j + 1]) j++;\n    ne[i] = j;\n}\n// 匹配\nfor (int i = 0, j = -1; i &lt; n; i++) {\n    while (j != -1 &amp;&amp; s[i] != p[j + 1]) j = ne[j];\n    if (s[i] == p[j + 1]) j++;\n    if (j == m - 1) {\n        // 匹配成功后的逻辑\n        j = ne[j];\n    }\n}\ni j指针都到底时算法必定结束 i移动m次 而j最多移动m次 O(n)\nnext[i] 表示 前i个字符中使得前k个字符恰等于后k个字符的最大的k. 特别地，k不能取i（此时自己与自己相等无意义了）上面代码里的统一减一\n如何找到字符串中所有前后缀相等的\ni1=next[n] i2=next[i1]…\n字符串循环节n-next[n]\ntrie树\n又称字典树，是一种状态机\n \nstruct trie {\n//N为节点上限数，son为每个节点的指针域（共26个分支），cnt为每个节点的数据域，idx为当前总节点数\n  int nex[N][26], idx, int cnt[N];\n  void insert(char *s, int l) {\n    int p = 0;\n    for (int i = 0; i &lt; l; i++) {\n      int c = s[i] - &#039;a&#039;;\n      if (!nex[p][c]) nex[p][c] = ++idx;\n      p = nex[p][c];\n    }\n    cnt[p]++;\n  }\n \n  int query(char *s, int l) {\n    int p = 0;\n    for (int i = 0; i &lt; l; i++) {\n      int c = s[i] - &#039;a&#039;;\n      if (!nex[p][c]) return 0;\n      p = nex[p][c];\n    }\n    return cnt[p];\n  }\n};\n \n并查集\n堆\n哈希\n字符串哈希\n预处理出所有前缀的哈希\n字符串看作P进制数\n线性表\n顺序存储实现和链式存储实现\n图论\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n算法单源/多源存在负权边时间复杂度朴素Dijkstra单否O(n^2)堆优化D~单否O(mlogn)Bellman-Ford单是O(nm)SPFA单是一般O(m)Floyd多是O(n^3)\nDijkstra\n贪心 每次确定一个到起点距离最近的点 用它更新其他点（到初始点）的距离和前驱 将该点加到集合中 迭代n次\nbellman-ford算法\n循环n次，每次循环遍历所有边更新距离(备份 只使用上一轮循环的结果更新)\n循环k次得到经过不超过k条边的最短距离\n循环n次时若更新则必有经过n条边的最短距离 n条边 n+1个点 若n+1&gt;点的个数则存在环且负环\nspfa\n只有以距离更新变小的点为起点的边的终点距离也会变小，只更新这些点，维护队列且保证队列元素不重复\n维护最短距离对应边数，边数大于等于n时，n+1个点，负环\nspfa中无法到达n号点则不会更新距离，而bellman会\nFloyd\nfor (int k = 1; k &lt;= n; k++){\n    for (int i = 1; i &lt;= n; i++){\n        for (int j = 1; j &lt;= n; j++){\n        \td[i][j] = min(d[i][k] + d[k][j], d[i][j]);\n        }\n    }\n}\nPrim\n朴素O(n^2) 堆优化O(mlogn)\n每次确定一个到集合距离最近的点 用它更新其他点（到集合）的距离和前驱 将该点加到集合中 迭代n次\nKruskal O(mlogm)\n将所有边按照权重排序，枚举边，边不连通则连通\n染色法O(n+m)\n不含奇数（边）环则可二分\n匈牙利算法O(nm),实际远小  难点\n在目前匹配情况下没有搜索到以该点开始的增广路径则加入后面的点也不会有以该点开始的增广路径\n存在增广链是增广当前匹配的充要条件\nbool find(int x){\n    //遍历出边\n    for (int i = h[x]; i != -1;i=ne[i]){\n        int j = e[i];\n        if(!st[j]){\n            st[j] = true;\n            if(match[j]==0||find(match[j])){\n                match[j] = x;\n                return true;\n            }\n        }\n    }\n    return false;\n}\nfor (int i = 1; i &lt;= n1;i++){\n    memset(st, false, sizeof(st));\n    if(find(i)) res++;\n}\n数学\n逆序对\n求逆序对数量\n将数组元素看作树状数组的下标\n1.逆序做法\n将a[i]+1，将sum[i-1]加到结果中\n也就是统计了出现在一个元素之后比它小的元素\n2.正序做法\n将a[i]+1，将已经处理的数的个数-sum[i-1]加到结果中\n也就是统计了出现在一个元素之前比它大的元素\n快速幂\nlong long binpow(long long a, long long b) {\n  long long res = 1;\n  while (b &gt; 0) {\n    if (b &amp; 1) res = res * a;\n    a = a * a;\n    b &gt;&gt;= 1;\n  }\n  return res;\n}\n矩阵快速幂\n此处为2x2矩阵\nstruct Matrix {\n  int a[3][3];\n \n  Matrix() { memset(a, 0, sizeof a); }\n \n  Matrix operator*(const Matrix &amp;b) const {\n    Matrix res;\n    for (int i = 1; i &lt;= 2; ++i)\n      for (int j = 1; j &lt;= 2; ++j)\n        for (int k = 1; k &lt;= 2; ++k)\n          res.a[i][j] += a[i][k] * b.a[k][j];\n    return res;\n  }\n} ans, base;\n \n \nMatrix qpow(Matrix base, int b) {\n  Matrix ans;\n  while (b) {\n    if (b &amp; 1) ans = ans * base;\n    base = base * base;\n    b &gt;&gt;= 1;\n  }\n}\n质数\n试除法\nO(sqrt(n))\n合数的约数成对出现 判断是不是质数只需判断较小的数能否整除n\n而d|n则(n/d)|n,令d⇐(n/d)则d⇐sqrt(n)\n用i⇐x/i判断而不是i*i⇐x（溢出）或i⇐sqrt(x)（慢）\nbool is_prime(int x)\n{\n    if (x &lt; 2) return false;\n    for (int i = 2; i &lt;= x / i; i ++ )\n        if (x % i == 0)\n            return false;\n    return true;\n}\n分解质因数\n一个合数分解而成的质因数最多只包含一个大于sqrt(x)的质因数\n枚举所有小于等于sqrt(x)的数i，将原数中该数的因子i除干净。当枚举到i时,n的因子不包括2到i-1中的数，若i|n,则i的因子不包括2到i-1的数，则i一定是质数\nvoid divide(int x)\n{\n    for (int i = 2; i &lt;= x / i; i ++ )\n        if (x % i == 0)\n        {\n            int s = 0;\n            while (x % i == 0) x /= i, s ++ ;\n            printf(&quot;%d %d\\n&quot;, i, s);\n        }\n    if (x &gt; 1) printf(&quot;%d 1\\n&quot;, x);\n    printf(&quot;\\n&quot;);\n}\nO(sqrt(n))\n朴素筛法\n枚举所有数，将该数的倍数筛掉 同上，当枚举到i时，没有被2到i-1筛掉 不是这些数的倍数 该数为质数\n复杂度O(nlogn)\n埃氏筛法\n枚举所有数，只将所有质数的倍数筛掉 复杂度O(nloglogn)\n质数定理：1-n中有n/lnn个质数\n线性筛法\n将每个数只用它的最小质因数筛掉\n枚举所有数i 若i没有被筛则记录为素数，再对i从小到大枚举质数p[j]（p[j]⇐i）\n若p[j]不|i，则p[j]一定小于i的所有质因子，p[j]也一定是p[j]*i的最小质因子\n若（第一次找到）p[j]|i,则p[j]是i的最小质因子，p[j]也一定是p[j]*i的最小质因子\n对合数x,假设p[j]是x的最小质因子，当枚举到x/p[j]（有x/p[j]&gt;p[j]且x/p[j]的最小质因数大于等于p[j]）时被删除\n每个合数都会被筛，只用最小质因子筛，每个合数一定有最小质因子\nvoid get_primes(int n)\n{\n    for (int i = 2; i &lt;= n; i ++ )\n    {\n        if (!st[i]) primes[cnt ++ ] = i;\n        for (int j = 0; primes[j] &lt;= n / i; j ++ )//保证p[j]*i在n范围内\n        {\n            st[primes[j] * i] = true;\n            if (i % primes[j] == 0) break;\n        }\n    }\n}\n约数个数\nN=P_1^{\\alpha1}P_2^{\\alpha2}...P_k^{\\alpha k}\\\\\nnum=(\\alpha1+1)(\\alpha2+1)...(\\alpha k+1)\n约数之和\nN=P_1^{\\alpha1}P_2^{\\alpha2}...P_k^{\\alpha k}\\\\\nsum=(P_1^0+P_1^1+...P_1^{\\alpha1})(P_2^0+P_2^1+...P_2^{\\alpha2})...(P_k^0+P_k^1+...P_k^{\\alpha k})\n辗转相除法\nint gcd(int a, int b) { return b == 0 ? a : gcd(b, a % b); }\n证明\n已知两个数a和b\n不妨设a&gt;b\n如果b|a，那么b就是二者的最大公约数。 下面讨论不能整除的情况，\n由模的性质，d|a d|b则d|ax+by\n而a mod b=a-kb\n若d|a d|b则d|a mod b,反之若d|b d|a mod b,则d|a\n则有a,b的公约数等价于b,a mod b的公约数，那么最大公约数应该也相同\n有==gcd(a,b)=gcd(b,a mod b)==\n辗转相除到最后发生gcd(a’,b’),而b’|a’（进一步，下一层递归调用为gcd(b’,0)），则b’为a’，b’的最大公约数，一路等价\n欧拉函数\n1-n中与n互质的数的个数\n公式\n\\begin{matrix}\nN=P_1^{\\alpha1}P_2^{\\alpha2}...P_k^{\\alpha k}\\\\\n\\phi(N)=N(1-\\frac{1}{P_1})(1-\\frac{1}{P_2})...(1-\\frac{1}{P_k})\n\\end{matrix}\n容斥原理，先去除单个质因子的倍数，再加上任意两个质因子的组合的倍数，再减去…上述多项式展开系数符合该规律\n筛法求欧拉函数\n在线性筛法中,若i mod p[j]=0,p[j]是i的最小质因子,则有\n\\phi(p[j]*i)=\\phi(i)*p[j]\n若i mod p[j]!== ,p[j]不是i的质因子,则有\n\\phi(p[j]*i)=\\phi(i)*p[j]*(1-\\frac{1}{p[j]})\n欧拉定理 若a与n互质,\na^{\\phi(n)}\\equiv1\\:(mod\\: n)\n费马小定理 质数p a不是p的倍数 则\na^{p-1}\\equiv1\\:(mod\\: n)\n快速幂\nO(logk)\na的k次方模p k以二进制表示，预处理出a的2的0到logk次方的模\na^{2^{log_2k}}=a^{2^{log_2k-1}*2}=(a^{2^{log_2k-1}})^2\n求逆元\n若b与m互质，存在x使得\na/b\\equiv ax\\:(mod\\:m)\n称x为b的模m乘法逆元，存在b的乘法逆元的充要条件是b与m互质\na/b\\equiv ab^{-1}\\:(mod\\:m)\\\\\na\\equiv ab^{-1}b\\:(mod\\:m)\\\\\nbb^{-1}\\equiv1\\:(mod\\:m)\n当m为质数时\nbb^{m-2}\\equiv1\\:(mod\\:m)\n扩展欧几里得算法\n裴蜀定理\n不全为0的整数a,b,存在整数x,y使得ax+by=gcd(a,b)\ngcd(b,a mod b)=gcd(a,0)=a，对于后式取x=1,y=0即为解\nbx+(a mod b)y=a\nay+b(x-(a\\b)y)=a这样得到a，b的一组解\n\\left\\{\n\\begin{aligned}\nx=x_0-\\frac{b}{gcd}k\\\\\ny=y_0+\\frac{a}{gcd}k\n\\end{aligned}\n\\right.\nint exgcd(int a, int b, int&amp; x, int&amp; y)\n{\n    if (!b)\n    {\n        x = 1, y = 0;\n        return a;\n    }\n    int d = exgcd(b, a % b, y, x);\n    y -= a / b * x;\n    return d;\n}\n线性同余方程\nax\\equiv b\\:(mod\\:m)\\\\\n即存在y使得ax=my+b\\\\\nax-my=b\\\\\n给定a,m,b\nb是gcd(a,m)的倍数时可以由裴蜀定理求出\n若b不是,而等式左边是，则矛盾，无解\n中国剩余定理\nm_1,m_2,...,m_k两两互质\\\\\nx\\equiv a_1\\:(mod\\:m_1)\\\\\nx\\equiv a_2\\:(mod\\:m_2)\\\\\n\nx\\equiv a_k\\:(mod\\:m_k)\\\\\nM=m_1m_2...m_k\\\\\nM_i=M/m_i\\\\\nM_i^{-1}表示M_i模m_i的逆\\\\\nx=a_1M_1M_1^{-1}+a_2M_2M_2^{-1}+...+a_kM_kM_k^{-1}\n组合数\n1.数据多 小，使用递推\nC_a^b=C_{a-1}^b+C_{a-1}^{b-1}\n2.数据数量中 大小中，预处理出阶乘\nC_a^b=\\frac{a!}{(a-b)!b!}\n其中分母上的数使用逆元转化为乘法\n逆元的乘积等于乘积的逆元\n3.数据少 大，卢卡斯定理\nC_a^b\\equiv C_{a\\:mod\\:p}^{b\\:mod\\:p}C_{a/p}^{b/p}\\:(mod\\:p)\n容易证明\n(1+x)^p\\equiv1+x^p\\:(mod\\:p)\n将a,b以k进制表示\na=a_kp^k+a_{k-1}p^{k-1}+...+a_0p^0\\\\\nb=b_kp^k+b_{k-1}p^{k-1}+...+b_0p^0\\\\\\\\\n(1+x)^a\\equiv(1+x^{p^0})^{a_0}(1+x^{p^1})^{a_1}...(1+x^{p^k})^{a_k}\\\\\n对比x^b的系数有\nC_a^b\\equiv C_{a_k}^{b_k}C_{a_{k-1}}^{b_{k-1}}...C_{a_0}^{b_0}\n4.数据极大 全部输出\n先将组合数分解质因数，每个质因子出现次数等于a!中出现减去b!和(a-b)!中出现次数\n计算n!中质因子p的次数=a\\p+a\\p^2+a\\p^3+…\n最后高精度乘法\n卡特兰数\n给定n个0和n个1，它们按照某种顺序排成长度为2n的序列，满足任意前缀中0的个数都不少于1的个数的序列的数量为： Cat(n) = C(2n, n) / (n + 1)\n将原问题转化为二维坐标系下0表示向右走,1表示向上走，则要求等价为不经过y=x+1运动到(n,n),总数为C(2n,n)-C(2n,n-1)\n动态规划\n动态规划\n搜索\nbfs→dijkstra 维护队列单调性 出队/入队时确定\n双向广搜 某一个方向搜索队列为空意味着起点终点不连通\nA*\n启发函数\n使用优先队列 保存起点到当前点的距离和当前点的距离到终点的估计距离 需要保证估计值小于等于真实值\n只有终点出队时保证是最小距离\n八数码\n操作不改变逆序对数量奇偶性，充分必要条件是 数量为偶数\n估计函数：当前状态中每个数与目标位置的曼哈顿距离之和\n第K短路\n估价函数：建反图，终点到每个点的距离\n第k次搜到终点\n单词接龙\n记录单词之间最短前后缀长度 相当与单词之间有一条边\n分成互质组\n不互质的数之间连边\nDFS\n剪枝\n优先选择（能使）选择数量少的 可行性剪枝 最优性剪枝 排除等效冗余\n数独\n用九位零一串表示某一行（或列 或九宫格）1-9能否填\n取行 列 九宫格的交集\n迭代加深\n答案在浅层区域 控制搜索区域 O(N)\nIDA*\n估价函数\n\n\n\nWhen you are analyzing an algorithm or code for its computational complexity\nusing Big-O notation, you can ignore the primitive operations that would\ncontribute less-important factors to the run-time. Also, you always take the worst\ncase behavior for Big-O.\n\n长度最小子数组 移除元素 反转链表 删除倒数第n个结点 链表环\n枚举\n全排列\n时间复杂度O(n*n!)\n两种理解方式，落实到代码上一样\n1.依次枚举每一个数放在哪一个位置\n2.依次对于每个位置枚举放哪个数\n全子集\n\n组合枚举\ndef count_partitions(n, m):\n        &quot;&quot;&quot;用1到m的数构成n&quot;&quot;&quot;\n        if n == 0:\n            return 1\n        elif n &lt; 0:\n            return 0\n        elif m == 0:\n            return 0\n        else:\n            return count_partitions(n-m, m) + count_partitions(n, m-1)"},"编译原理":{"title":"编译原理","links":[],"tags":[],"content":"T型\n左右分别是源语言和目标语言，下方是编译器自身实现语言\n目标语言和编译器实现语言都为机器语言，这种编译器可以和自身bootstrap\n可以将A语言实现的A2K编译器和H语言实现的A2H编译器结合得到H语言实现的A2K编译器，称为交叉编译器\n进一步，将A语言实现的A2K再和交叉编译器结合可以得到K语言实现的A2K编译器。至此，通过K语言实现的A2K编译器，成功借助现有编译器将A语言编译到了K语言平台\n一个简单的递归下降\n只支持 只有一种分解情况正确返回的情况\nPredictive Parser\n向后看若干个token，不需要回溯\n需要接受LL(k)语法\nleft-to-right\nleft-most derivation\nk tokens look ahead\n将左因子转换为右因子\n使用parsing table\nfirst sets\n\\mathrm{First}(X)=\\{t\\mid X\\rightarrow^*t\\alpha\\}\\cup\\{\\varepsilon\\mid X\\rightarrow^*\\varepsilon\\}\nX可以是非终结符或终结符\n一些结论：\n1.终结符的first集是自身 First(t)={t}\n2.ε∈First(X)\n当X→ε或者X→A1A2…An并且ε∈First(Ai) 对1到n都成立\n3.First(α)包含于First(X)\n当X→A1A2…Anα并且ε∈First(Ai) 对1到n都成立\n其实也就是说对于任何一个产生式的右侧的第一个符号Y都是有First(Y)包含于First(X)（？）\nT[A,t]=alpha\nfollow sets\n\\mathrm{Follow}(X)=\\{t\\mid S\\rightarrow^*\\beta Xt\\delta\\}\n并不是说A可以推导t，而是说t可以在某个推导中紧跟在A后\n一些结论：\n1.EOF ∈Follow(S)\n2.First(β)-{ε}包含于Follow(X) 对于A→αXβ\n3.Follow(A)包含于Follow(X) 对于A→αXβ ε∈First(β)\n找Follow set应当关注符号在右边的出现（产生）\n正则表达式到NFA\n有几种固定的模式将各种运算符结合起来\nNFA到DFA\n利用空串转移的若干状态都合成为一个新状态\nDFA化简\n一开始划分为接受状态集合和其他状态集合\n观察对于输入，整个状态集合是否产生相同的输出（指输出同属一个集合）\n南大编译原理学习记录\nKnuth在算法分析（计算复杂的时间复杂度？）方面有很大贡献，此外被人忽视的是他在程序语言设计上的贡献，他有一本LR语法分析的论文？\n编译器重点好像在后端阶段，而我们的课程集中在前半阶段（已经成熟了）。\n符号表中存在嵌套关系（函数作用域？）\nclang的读音 不是c lang\ndump（打印内存信息）抽象语法树\nclang -Xclang -ast-dump hello.c\n//不需要该代码可运行\n分词\nclang -fsyntax-only -Xclang -dump-tokens hello.c\nantlr支持非贪婪匹配 优先级匹配（使用的表达式） 整体匹配（不会把小数拆成整数和一个以点开头的小数来识别）\n所以用antlr实现时可能不太需要注意优先级和二义性问题\n语法和语义\nnfa到dfa的转换 不动点\ndfa最小化 hopcroft 划分 死状态\n函数调用图和计算器实现的例子"},"计算机图形学":{"title":"计算机图形学","links":[],"tags":[],"content":"二维变换\n缩放变换\n\\left\\{\n\\begin{aligned}\nx&#039;=u_xx\\\\\ny&#039;=u_yy\n\\end{aligned}\n\\right.\n\\begin{bmatrix}\nx&#039;\\\\y&#039;\n\\end{bmatrix}\n=\n\\begin{bmatrix}\ns&amp;0\\\\0&amp;s\n\\end{bmatrix}\n\\begin{bmatrix}\nx\\\\y\n\\end{bmatrix}\nNon-Uniform\n\\begin{bmatrix}\nx&#039;\\\\y&#039;\n\\end{bmatrix}\n=\n\\begin{bmatrix}\ns_x&amp;0\\\\0&amp;s_y\n\\end{bmatrix}\n\\begin{bmatrix}\nx\\\\y\n\\end{bmatrix}\n镜像变换\n\\left\\{\n\\begin{aligned}\n&amp;x&#039;=-x\\\\\n&amp;y&#039;=y\n\\end{aligned}\n\\right.\n\\begin{bmatrix}\nx&#039;\\\\y&#039;\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n-1&amp;0\\\\0&amp;1\n\\end{bmatrix}\n\\begin{bmatrix}\nx\\\\y\n\\end{bmatrix}\nShear切变\n\n\\begin{bmatrix}\nx&#039;\\\\y&#039;\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n-1&amp;a\\\\0&amp;1\n\\end{bmatrix}\n\\begin{bmatrix}\nx\\\\y\n\\end{bmatrix}\n旋转\n默认绕原点逆时针\nR_\\theta=\n\\begin{bmatrix}\n\\cos\\theta&amp;-\\sin\\theta\\\\\\sin\\theta&amp;\\cos\\theta\n\\end{bmatrix}\\\\\nR_{-\\theta}=R_{\\theta}^T=R_\\theta^{-1}\n线性变换\n\\left\\{\n\\begin{aligned}\n&amp;x&#039;=ax+by\\\\\n&amp;y&#039;=cx+dy\n\\end{aligned}\n\\right.\n\\begin{bmatrix}\nx&#039;\\\\y&#039;\n\\end{bmatrix}\n=\n\\begin{bmatrix}\na&amp;b\\\\c&amp;d\n\\end{bmatrix}\n\\begin{bmatrix}\nx\\\\y\n\\end{bmatrix}\nx&#039;=Mx\n齐次坐标\n平移变换 不是线性变换\n\\left\\{\n\\begin{aligned}\n&amp;x&#039;=x+t_x\\\\\n&amp;y&#039;=x+t_y\n\\end{aligned}\n\\right.\n引入新维度w\n2D point=(x,y,1)^T\\\\2D Vector=(x,y,0)^T\n\\begin{bmatrix}\nx&#039;\\\\y&#039;\\\\w&#039;\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n1&amp;0&amp;t_x\\\\0&amp;1&amp;t_y\\\\0&amp;0&amp;1\n\\end{bmatrix}\n\\begin{bmatrix}\nx\\\\y\\\\1\n\\end{bmatrix}\n=\n\\begin{bmatrix}\nx+t_x\\\\y+t_y\\\\1\n\\end{bmatrix}\n向量具有平移不变性 因而w为0\n并且保证了\n\\begin{align}\nvector+vector&amp;=vector\\\\\npoint-point&amp;=point\\\\\npoint+vector&amp;=point\\\\\npoint+point&amp;=??\\\\\n\\end{align}\n认为在齐次坐标中\n\\begin{pmatrix}x\\\\y\\\\w\\end{pmatrix}表示\\begin{pmatrix}x/w\\\\y/w\\\\1\\end{pmatrix},w\\ne0\n于是两坐标相加得到其中点\n仿射变换（先线性变换后平移）\n\\begin{bmatrix}\nx&#039;\\\\y&#039;\n\\end{bmatrix}\n=\n\\begin{bmatrix}\na&amp;b\\\\c&amp;d\n\\end{bmatrix}\n\\begin{bmatrix}\nx\\\\y\n\\end{bmatrix}\n+\n\\begin{bmatrix}\nt_x\\\\t_y\n\\end{bmatrix}\n\\begin{bmatrix}\nx&#039;\\\\y&#039;\\\\1\n\\end{bmatrix}\n=\n\\begin{bmatrix}\na&amp;b&amp;t_x\\\\c&amp;d&amp;t_y\\\\0&amp;0&amp;1\n\\end{bmatrix}\n\\begin{bmatrix}\nx\\\\y\\\\1\n\\end{bmatrix}\nScale\nS(s_x,s_y)=\n\\begin{bmatrix}\ns_x&amp;0&amp;0\\\\0&amp;s_y&amp;0\\\\0&amp;0&amp;1\n\\end{bmatrix}\nRotation\nR(\\alpha)=\n\\begin{bmatrix}\n\\cos\\alpha&amp;-\\sin\\alpha&amp;0\\\\\\sin\\alpha&amp;\\cos\\alpha&amp;0\\\\0&amp;0&amp;1\n\\end{bmatrix}\nTranslation\nT(t_x,t_y)=\n\\begin{bmatrix}\n1&amp;0&amp;t_x\\\\0&amp;1&amp;t_y\\\\0&amp;0&amp;1\n\\end{bmatrix}\n逆变换 复合变换 分解\n\n三维变换\n3D point=(x,y,z,1)^T\\\\3D Vector=(x,y,z,0)^T\n(x,y,z,w)表示(x/w,y/w,z/w) (w\\ne0)\n\\begin{bmatrix}\nx&#039;\\\\y&#039;\\\\z&#039;\\\\1\n\\end{bmatrix}\n=\n\\begin{bmatrix}\na&amp;b&amp;c&amp;t_x\\\\d&amp;e&amp;f&amp;t_y\\\\g&amp;h&amp;i&amp;t_z\\\\0&amp;0&amp;0&amp;1\n\\end{bmatrix}\n\\begin{bmatrix}\nx\\\\y\\\\z\\\\1\n\\end{bmatrix}\nScale\nS(s_x,s_y,s_Zy)=\n\\begin{bmatrix}\ns_x&amp;0&amp;0&amp;0\\\\0&amp;s_y&amp;0&amp;0\\\\0&amp;0&amp;s_z&amp;0\\\\0&amp;0&amp;0&amp;1\n\\end{bmatrix}\nRotation\nR_x(\\alpha)=\n\\begin{bmatrix}\n1&amp;0&amp;0&amp;0\\\\0&amp;\\cos\\alpha&amp;-\\sin\\alpha&amp;0\\\\0&amp;\\sin\\alpha&amp;\\cos\\alpha&amp;0\\\\0&amp;0&amp;0&amp;1\n\\end{bmatrix}\\\\\nR_y(\\alpha)=\n\\begin{bmatrix}\n\\cos\\alpha&amp;0&amp;\\sin\\alpha&amp;0\\\\0&amp;1&amp;0&amp;0\\\\-\\sin\\alpha&amp;0&amp;\\cos\\alpha&amp;0\\\\0&amp;0&amp;0&amp;1\n\\end{bmatrix}\\\\\nR_z(\\alpha)=\n\\begin{bmatrix}\n\\cos\\alpha&amp;-\\sin\\alpha&amp;0&amp;0\\\\\\sin\\alpha&amp;\\cos\\alpha&amp;0&amp;0\\\\0&amp;0&amp;1&amp;0\\\\0&amp;0&amp;0&amp;1\n\\end{bmatrix}\\\\\nR_{xyz}(\\alpha,\\beta,\\gamma)=R_x(\\alpha)R_y(\\beta)R_z(\\gamma)\n欧拉角\n罗德里格斯旋转公式\n绕着轴n旋转alpha角 轴以原点为起点(叉乘矩阵)\nR(n,\\alpha)=\\cos(\\alpha)I+(1-\\cos(\\alpha))nn^T+\\sin(\\alpha)\\begin{bmatrix}\n0&amp;-n_z&amp;n_y\\\\n_z&amp;0&amp;-n_x\\\\-n_y&amp;n_x&amp;0\n\\end{bmatrix}\nTranslation\nT(t_x,t_y)=\n\\begin{bmatrix}\n1&amp;0&amp;0&amp;t_x\\\\0&amp;1&amp;0&amp;t_y\\\\0&amp;0&amp;1&amp;t_z\\\\0&amp;0&amp;0&amp;1\n\\end{bmatrix}\n观测变换\nmodel transformation和view transformation分别放置物体和相机\n视图view变换 让世界空间下的坐标轴在摄像机空间下表示\n定义相机\n位置 \\vec{e}\\\\看的方向\\hat{g}\\\\向上方向(Up-Direction)\\hat{t}\n使得相机放在原点 向上方向Y 看的方向-Z\n\\begin{matrix}\n用M_{view}将相机调整到该位置\\\\首先平移到原点\\\\再将\\hat{g}旋转到-Z，\\hat{t}旋转到Y，于是x也旋转到了\\hat{g}\\times\\hat{t}\\\\\nM_{view}=R_{view}T_{view}\\\\\nT_{view}=\n\\begin{bmatrix}\n1&amp;0&amp;0&amp;-x_e\\\\0&amp;1&amp;0&amp;-y_e\\\\0&amp;0&amp;0&amp;-z_e\\\\0&amp;0&amp;0&amp;1\n\\end{bmatrix}\\\\\nR_{view}^{-1}=\\begin{bmatrix}\nx_{\\hat{g}\\times\\hat{t}}&amp;x_t&amp;x_{-\\hat{g}}&amp;0\\\\\ny_{\\hat{g}\\times\\hat{t}}&amp;y_t&amp;x_{-\\hat{g}}&amp;0\\\\\nz_{\\hat{g}\\times\\hat{t}}&amp;z_t&amp;x_{-\\hat{g}}&amp;0\\\\\n0&amp;0&amp;0&amp;1\\\\\n\\end{bmatrix}\\\\\n旋转矩阵为正交矩阵\n故R_{view}^{-1}=\\begin{bmatrix}\nx_{\\hat{g}\\times\\hat{t}}&amp;y_{\\hat{g}\\times\\hat{t}}&amp;z_{\\hat{g}\\times\\hat{t}}&amp;0\\\\\nx_t&amp;y_t&amp;z_t&amp;0\\\\\nx_{-\\hat{g}}&amp;y_{-\\hat{g}}&amp;z_{-\\hat{g}}&amp;0\\\\\n0&amp;0&amp;0&amp;1\\\\\n\\end{bmatrix}\n\\end{matrix}\n投影Projection变换\n-正交Orthographic变换(平行线仍平行)\n-透视Perspective变换(不平行，接近人眼效果，近大远小)\n\n\n实现：将一个立方体[left,right]x[bottom,top]x[far,near]（想看到的区域)变换以原点为中心 大小2x2x2的正交立方体\n因为向-Z方向看 ‘f&lt;n’\nM_{ortho}=\n\\begin{bmatrix}\n\\frac{r-l}{2}&amp;0&amp;0&amp;0\\\\0&amp;\\frac{t-b}{2}&amp;0&amp;0\\\\0&amp;0&amp;\\frac{n-f}{2}&amp;0\\\\0&amp;0&amp;0&amp;1\n\\end{bmatrix}\n\\begin{bmatrix}\n1&amp;0&amp;0&amp;-\\frac{l+r}{2}\\\\0&amp;1&amp;0&amp;-\\frac{t+b}{2}\\\\0&amp;0&amp;1&amp;-\\frac{n+f}{2}\\\\0&amp;0&amp;0&amp;1\n\\end{bmatrix}\n\n1.将frustum“挤”成cuboid  2.正交投影\n\n在齐次坐标下\n\\begin{pmatrix}x\\\\y\\\\z\\\\1\\end{pmatrix}\\rightarrow\n\\begin{pmatrix}\\frac{nx}{z}\\\\\\frac{nx}{y}\\\\unknown\\\\1\\end{pmatrix}\n==\\begin{pmatrix}nx\\\\ny\\\\unknown\\\\z\\end{pmatrix}\n由far平面上的点的z不变 near平面的点坐标不变\n\\begin{pmatrix}x\\\\y\\\\n\\\\1\\end{pmatrix}\\rightarrow\n\\begin{pmatrix}\\frac{nx}{z}\\\\\\frac{nx}{y}\\\\n\\\\1\\end{pmatrix}\n==\\begin{pmatrix}nx\\\\ny\\\\n^2\\\\n\\end{pmatrix}\n\\begin{pmatrix}0&amp;0&amp;A&amp;B\\end{pmatrix}\\begin{pmatrix}x\\\\y\\\\n\\\\1\\end{pmatrix}=n^2\\rightarrow An+B=n^2\n\\begin{pmatrix}0\\\\0\\\\f\\\\1\\end{pmatrix}\\rightarrow\n\\begin{pmatrix}0\\\\0\\\\f\\\\1\\end{pmatrix}\n==\\begin{pmatrix}0\\\\0\\\\f^2\\\\f\\end{pmatrix}\nAf+B=f^2\n解得\nA=n+f\\\\B=-nf\nM_{persp\\rightarrow ortho}=\\begin{bmatrix}\nn&amp;0&amp;0&amp;0\\\\\n0&amp;n&amp;0&amp;0\\\\\n0&amp;0&amp;n+f&amp;-nf\\\\\n0&amp;0&amp;1&amp;0\\\\\n\\end{bmatrix}\\\\\nfield-of-view(fovY) aspect ratio\n\n\\tan\\frac{fovY}{2}=\\frac{t}{|n|}\\\\aspect=\\frac{r}{t}\nrasterize光栅化 绘制在屏幕上\n屏幕空间\nM_{viewport}=\\begin{bmatrix}\n\\frac{width}{2}&amp;0&amp;0&amp;\\frac{width}{2}\\\\0&amp;\\frac{height}{2}&amp;0&amp;\\frac{height}{2}\\\\0&amp;0&amp;1&amp;0\\\\0&amp;0&amp;0&amp;1\n\\end{bmatrix}\nrasterizing triangles into pixels\n采样\n\n叉积判断点是否在三角形内\n为了避免每次判断时遍历整个屏幕空间，引入boundingbox\n\n别的包围盒方案\n\n\nAliasing(Jaggies)\nsampling artifacts(errors/mistakes/inaccuracies)\n\n原因：信号变化太快 采样频率太低\n在采样前先滤波/模糊\n傅里叶变换：时域到频域\n\n\nfiltering滤波 抹掉特定频段\n对图片做傅里叶变换 中间低频 四周高频 亮度表示信息量 自然界的图片普遍满足\n\n假设图片在竖直方向和水平方向无穷重复 图片边界剧烈信号变换（高频） 因而产生水平竖直亮线\n\n\n\n\n滤波 平均/卷积\n卷积定理 时域乘积=频域卷积\n\n\n\n高频变多\n更大的卷积核等于更低频\n采样=重复频谱内容\n\n\n采样越快 在频谱上越稀疏\n因而解决方案 增加采样率或者先模糊（低通滤波 去掉高频信息）再采样\n\n\nMSAA\n\n\n\n\nFXAA,TAA\n画家算法\n从后往前画 overwrite in the framebuffer\n深度排序要nlogn的时间复杂度\n\nZ-Buffer\n\n\n（深度越浅颜色越深）\n\nO(n)(assuming constant converage)\n对每个采样点z-buffer\n\nshading着色-apply a material\nBlinn-Phong Reflectance Model\n对任意一个点(Shading Point),足够小都可以视作平面\n\n只考虑光线对这个点的影响，局部性，不产生阴影\n漫反射中有\n由能量守恒\n\n漫反射与观察视角无关\n高光/镜面反射只有观察角度与反射方向接近时可以观察到\n\n\np控制能看到高光的区域大小\n\n环境光照\n\n\nShading Frequencies\n\n逐面/逐顶点/逐像素\n\n\n\n\n如何找到顶点的法线-简单化的假设每个顶点的法向量是其相邻的面的法向量的(面积加权)平均\n\n\n\n如何定义物体表面每个点的性质\n三维物体的表面是一个二维平面\n\n\n找到任意一个三角形(顶点)在纹理上的对应\n因而纹理应有坐标系(u,v)\n\n\n插值问题 已知三角形顶点对应的纹理坐标求内部的对应 平滑\n\n\n三角形的重心的重心坐标是(1/3,1/3,1/3)\n\n\n应当求三维坐标中的中心坐标 而不是投影后再做\n\n\n双线性插值Billinear\n\n\n\n近处锯齿，远处摩尔纹\n近处一个像素覆盖的纹理区域小，远处大\n\n超采样解决\npoint query和range query\n直接得到范围的平均值\nmipmap\n\n\n额外开销1/4+1/16+…=1/3\n\n\n\n在D=log2L层的mipmap上该点对应一个纹素\n\n层与层之间不连续 插值\nTrilinear Interpolation\n\nMipmap局限：Overblur\n各向异性过滤Antisotropic Filtering 对性能要求不高 空间有一定要求\n\n\n\n纹理应用\n环境光贴图environment map 只记录各个方向 不记录深度\n\nspherical environment map记录环境光在球上\n\n再展开\n\n\n\n\n\n\n在局部坐标系下计算，认为法线默认向z轴正方向，在转换为世界坐标系\n\n噪声 山脉\n\n环境光遮蔽\ngeometry\n\n\n容易判定但不容易找出所有的点\n\n相反\n\n\n\n\n\n\n\n\n\n贝塞尔曲线\n\n二次贝塞尔曲线\n分别在b0b1和b1b2上找到划分为t/1-t的点\n\n三次贝塞尔曲线\n\n\nb_0^1(t)=(1-t)b_0+tb_1\\\\\nb_1^1(t)=(1-t)b_1+tb_2\\\\\nb_0^2(t)=(1-t)b_0^1+tb_1^1\\\\\nb_0^2(t)=(1-t)^2b_0+2t(1-t)b_1+t^2b_2\n给定n+1个控制点 n阶贝塞尔曲线\nb^n(t)=\\sum\\limits^n_{j=0}b_jB^n_j(t)\\\\\nB^n_i(t)=\\binom{n}{i}t^i(1-t)^{n-i}\n\n\n\n\n样条\n\n贝塞尔曲面\n\n\n\n曲面细分\n\nLoop（人名）\n\n\n\n引入了两个新的度为3的奇异点 且（2个）非四边形面消失 之后奇异点不再增加\n\n\n\n曲面简化\n\n\n\n采用堆 便于去最小值和更新 希望找到二次度量误差最小的边更新，通过局部最优解来希望得到全局最优解 也就是贪心\n\nshadow mapping\n阴影是能被相机看到不能被光源看到的点\n\n\n\n\n\n\n\n点光源不存在软阴影\nray tracing\n软阴影和光线反弹的情况光栅化无法处理\n离线\n光线的定义\n1.直线传播2.不互相碰撞3.从光源运动到眼睛\n利用光线传播的可逆性(reciprocity)，也可以认为人眼发出光线运动到光源\n\n\n\nrecursive(whitted-style)ray tracing\n\n\n\n确认光线和物体表面的交点\n\n\n解得\nt=\\frac{-b\\pm\\sqrt{b^2-2ac}}{2a}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n不要让树退化成链表 换不同的轴划分\n找中位数 O(N)快速选择算法\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n点光源换成面 对立体角积分\n\n\n\n\n\n蒙特卡洛\n\n\n光线数量指数增加\n\n\n递归出口\n\n弹射次数期望?\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}}