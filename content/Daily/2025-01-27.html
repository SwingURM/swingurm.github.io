<!DOCTYPE html>
<html lang="zh"><head><title>2025-01-27</title><meta charset="utf-8"/><link rel="preconnect" href="https://fonts.googleapis.com"/><link rel="preconnect" href="https://fonts.gstatic.com"/><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=JetBrains Mono&amp;family=Schibsted Grotesk:wght@400;700&amp;family=Noto Serif Simplified Chinese:ital,wght@0,400;0,600;1,400;1,600&amp;display=swap"/><link rel="preconnect" href="https://cdnjs.cloudflare.com" crossorigin="anonymous"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta name="og:site_name" content="🐧 Blog"/><meta property="og:title" content="2025-01-27"/><meta property="og:type" content="website"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:title" content="2025-01-27"/><meta name="twitter:description" content="Mine of Information - Beginner’s Guide to Installing from Source 5.4. Multithreading Problems False Sharing 没有正确性问题，归根结底还是因为访问了不同的内存地址吧 int sum1; int sum2; void thread1(int v[], int v_count) { sum1 = 0; for (int i = 0; i &lt; v_count; i++) sum1 += v[i]; } void thread2(int v[], int v_count) { sum2 = 0; for (int i = 0; i &lt; v_count; i++) sum2 += v[i]; } 1.首先, thread1 将 sum1 读入其缓存。由于该行不存在于其他任何缓存中, thread1 处于独占状态: 2.thread2 现在读取 sum2 。由于 thread1 的缓存行已经在独占状态，这会导致 thread1 的缓存行降级，并且缓存行现在在两个缓存中都处于共享状态： 3.thread1 现在将其更新后的总和写入 sum1 。由于它只在共享状态下拥有该行，因此必须升级该行并在 thread2 的缓存中无效该行： 4.thread2 现在将其更新后的总和写入到 sum2 中。由于 thread1 已在其缓存中失效了该缓存行，因此发生了一致性缺失，并且必须在 thread1 的缓存中失效该行，从而迫使 thread1 执行一致性写回： 5.下一次循环迭代现在开始， thread1 再次读取 sum1 。由于 thread2 刚刚在 thread1 的缓存中失效了缓存行，它会遇到一致性缺失。它还必须在 thread2 的缓存中降级该行，迫使 thread2 执行一致性写回操作： 6.thread2 最终读取了 sum2 。由于它有共享状态的缓存行，因此可以无需一致性活动就进行读取，我们又回到了步骤 2 结束时的情况 3到6昂贵的升级、一致性缺失和一致性写回 lecture-10.1.pdf Execution vs interpretation deepseek生成 传统硬件执行： 经典的CPU通过硬连线路（Hardwired Logic）直接实现取指-解码-执行周期。每条指令的每个步骤（如加法、跳转）都由专用电路处理。这种方式高效但灵活性低，修改指令集需重新设计硬件。 通过微码解释器，硬件专注于高效执行μops，而非直接处理复杂指令。这使得设计更模块化，例如现代CPU可复用相同的ALU（算术逻辑单元）处理多种指令。 软件解释器： 通过软件（如微码，即Microcode）实现指令的解释。复杂指令被分解为更小的微操作（μops），这些μops由底层硬件执行。微码存储在CPU内部的固件中，充当“解释器”，将复杂指令翻译为硬件可直接执行的原子操作。 示例： x86处理器的复杂指令（如字符串操作）会被微码分解为多个μops（如加载、计算、存储），硬件仅需实现这些基础操作。 向后兼容性： 微码允许通过更新固件（而非修改硬件）支持旧指令集。例如，新x86 CPU通过微码升级兼容几十年前的软件，无需重新设计电路。 历史背景（CISC架构）： 20世纪70-80年代，CISC（复杂指令集计算机，如x86）采用微码实现庞大指令集。指令集包含高度抽象的指令（如单条指令完成复杂操作），通过微码解释适配硬件，但牺牲了一定的效率。后来RISC（精简指令集）通过简化指令集和硬连线逻辑提高了性能，但现代CPU（如Intel/AMD）融合了两者：硬件直接执行常见指令，复杂指令仍依赖微码。 执行（硬连线）：高效但缺乏灵活性，适合固定指令集。 解释（微码）：灵活且简化硬件设计，支持复杂指令集和向后兼容。 cache可能会导致写放大 cpu是byte-addressable，而cacheline granularity更大 weak memory order 在strong中 8发生在5之后是不被允许的，观察到写的顺序得一致 锁需要维护状态16-40bytes 获取锁需要系统调用，耗时 coarse-grained locking 高争用下degrade 获取锁的延迟明显增加，即使是共享锁 乐观锁 试图优化读为大多数的情况 由于上述原因，共享锁没有用 • Associate a version with the shared resource • Writers still have to acquire an exclusive lock of some sort • This ensures that only one writer at a time has access to the resource • At the end of its critical section, a writer atomically increases the version • Readers only have to read the version • At the begin of its critical section, a reader atomically reads the current version • At the end of its critical section, a reader validates that the version did not change • Otherwise, a concurrent write occurred and the critical section is restarted writer(optLock) { lockExclusive(optLock.mutex) // begin critical section // modify the shared resource storeAtomic(optLock.version, optLock.version + 1) unlockExclusive(optLock.mutex) // end critical section } reader(optLock) { while(true) { current = loadAtomic(optLock.version); // begin critical section // read the shared resource if (current == loadAtomic(optLock.version)) // validate return; // end critical section } } 读者只需要两个原子load，比共享锁便宜 但是注意，共享资源在我们访问时可能被修改，不能做出consistent state的假设 更复杂的读操作需要更多中间检查 non-blocking 不依赖锁的，使用原子操作 一般是lock-free的同义词，表示至少能有一个线程能make progress lost update和A-B-A问题 CAS没有公平性，不保证某个线程最终能获得锁."/><meta property="og:description" content="Mine of Information - Beginner’s Guide to Installing from Source 5.4. Multithreading Problems False Sharing 没有正确性问题，归根结底还是因为访问了不同的内存地址吧 int sum1; int sum2; void thread1(int v[], int v_count) { sum1 = 0; for (int i = 0; i &lt; v_count; i++) sum1 += v[i]; } void thread2(int v[], int v_count) { sum2 = 0; for (int i = 0; i &lt; v_count; i++) sum2 += v[i]; } 1.首先, thread1 将 sum1 读入其缓存。由于该行不存在于其他任何缓存中, thread1 处于独占状态: 2.thread2 现在读取 sum2 。由于 thread1 的缓存行已经在独占状态，这会导致 thread1 的缓存行降级，并且缓存行现在在两个缓存中都处于共享状态： 3.thread1 现在将其更新后的总和写入 sum1 。由于它只在共享状态下拥有该行，因此必须升级该行并在 thread2 的缓存中无效该行： 4.thread2 现在将其更新后的总和写入到 sum2 中。由于 thread1 已在其缓存中失效了该缓存行，因此发生了一致性缺失，并且必须在 thread1 的缓存中失效该行，从而迫使 thread1 执行一致性写回： 5.下一次循环迭代现在开始， thread1 再次读取 sum1 。由于 thread2 刚刚在 thread1 的缓存中失效了缓存行，它会遇到一致性缺失。它还必须在 thread2 的缓存中降级该行，迫使 thread2 执行一致性写回操作： 6.thread2 最终读取了 sum2 。由于它有共享状态的缓存行，因此可以无需一致性活动就进行读取，我们又回到了步骤 2 结束时的情况 3到6昂贵的升级、一致性缺失和一致性写回 lecture-10.1.pdf Execution vs interpretation deepseek生成 传统硬件执行： 经典的CPU通过硬连线路（Hardwired Logic）直接实现取指-解码-执行周期。每条指令的每个步骤（如加法、跳转）都由专用电路处理。这种方式高效但灵活性低，修改指令集需重新设计硬件。 通过微码解释器，硬件专注于高效执行μops，而非直接处理复杂指令。这使得设计更模块化，例如现代CPU可复用相同的ALU（算术逻辑单元）处理多种指令。 软件解释器： 通过软件（如微码，即Microcode）实现指令的解释。复杂指令被分解为更小的微操作（μops），这些μops由底层硬件执行。微码存储在CPU内部的固件中，充当“解释器”，将复杂指令翻译为硬件可直接执行的原子操作。 示例： x86处理器的复杂指令（如字符串操作）会被微码分解为多个μops（如加载、计算、存储），硬件仅需实现这些基础操作。 向后兼容性： 微码允许通过更新固件（而非修改硬件）支持旧指令集。例如，新x86 CPU通过微码升级兼容几十年前的软件，无需重新设计电路。 历史背景（CISC架构）： 20世纪70-80年代，CISC（复杂指令集计算机，如x86）采用微码实现庞大指令集。指令集包含高度抽象的指令（如单条指令完成复杂操作），通过微码解释适配硬件，但牺牲了一定的效率。后来RISC（精简指令集）通过简化指令集和硬连线逻辑提高了性能，但现代CPU（如Intel/AMD）融合了两者：硬件直接执行常见指令，复杂指令仍依赖微码。 执行（硬连线）：高效但缺乏灵活性，适合固定指令集。 解释（微码）：灵活且简化硬件设计，支持复杂指令集和向后兼容。 cache可能会导致写放大 cpu是byte-addressable，而cacheline granularity更大 weak memory order 在strong中 8发生在5之后是不被允许的，观察到写的顺序得一致 锁需要维护状态16-40bytes 获取锁需要系统调用，耗时 coarse-grained locking 高争用下degrade 获取锁的延迟明显增加，即使是共享锁 乐观锁 试图优化读为大多数的情况 由于上述原因，共享锁没有用 • Associate a version with the shared resource • Writers still have to acquire an exclusive lock of some sort • This ensures that only one writer at a time has access to the resource • At the end of its critical section, a writer atomically increases the version • Readers only have to read the version • At the begin of its critical section, a reader atomically reads the current version • At the end of its critical section, a reader validates that the version did not change • Otherwise, a concurrent write occurred and the critical section is restarted writer(optLock) { lockExclusive(optLock.mutex) // begin critical section // modify the shared resource storeAtomic(optLock.version, optLock.version + 1) unlockExclusive(optLock.mutex) // end critical section } reader(optLock) { while(true) { current = loadAtomic(optLock.version); // begin critical section // read the shared resource if (current == loadAtomic(optLock.version)) // validate return; // end critical section } } 读者只需要两个原子load，比共享锁便宜 但是注意，共享资源在我们访问时可能被修改，不能做出consistent state的假设 更复杂的读操作需要更多中间检查 non-blocking 不依赖锁的，使用原子操作 一般是lock-free的同义词，表示至少能有一个线程能make progress lost update和A-B-A问题 CAS没有公平性，不保证某个线程最终能获得锁."/><meta property="og:image:type" content="image/webp"/><meta property="og:image:alt" content="Mine of Information - Beginner’s Guide to Installing from Source 5.4. Multithreading Problems False Sharing 没有正确性问题，归根结底还是因为访问了不同的内存地址吧 int sum1; int sum2; void thread1(int v[], int v_count) { sum1 = 0; for (int i = 0; i &lt; v_count; i++) sum1 += v[i]; } void thread2(int v[], int v_count) { sum2 = 0; for (int i = 0; i &lt; v_count; i++) sum2 += v[i]; } 1.首先, thread1 将 sum1 读入其缓存。由于该行不存在于其他任何缓存中, thread1 处于独占状态: 2.thread2 现在读取 sum2 。由于 thread1 的缓存行已经在独占状态，这会导致 thread1 的缓存行降级，并且缓存行现在在两个缓存中都处于共享状态： 3.thread1 现在将其更新后的总和写入 sum1 。由于它只在共享状态下拥有该行，因此必须升级该行并在 thread2 的缓存中无效该行： 4.thread2 现在将其更新后的总和写入到 sum2 中。由于 thread1 已在其缓存中失效了该缓存行，因此发生了一致性缺失，并且必须在 thread1 的缓存中失效该行，从而迫使 thread1 执行一致性写回： 5.下一次循环迭代现在开始， thread1 再次读取 sum1 。由于 thread2 刚刚在 thread1 的缓存中失效了缓存行，它会遇到一致性缺失。它还必须在 thread2 的缓存中降级该行，迫使 thread2 执行一致性写回操作： 6.thread2 最终读取了 sum2 。由于它有共享状态的缓存行，因此可以无需一致性活动就进行读取，我们又回到了步骤 2 结束时的情况 3到6昂贵的升级、一致性缺失和一致性写回 lecture-10.1.pdf Execution vs interpretation deepseek生成 传统硬件执行： 经典的CPU通过硬连线路（Hardwired Logic）直接实现取指-解码-执行周期。每条指令的每个步骤（如加法、跳转）都由专用电路处理。这种方式高效但灵活性低，修改指令集需重新设计硬件。 通过微码解释器，硬件专注于高效执行μops，而非直接处理复杂指令。这使得设计更模块化，例如现代CPU可复用相同的ALU（算术逻辑单元）处理多种指令。 软件解释器： 通过软件（如微码，即Microcode）实现指令的解释。复杂指令被分解为更小的微操作（μops），这些μops由底层硬件执行。微码存储在CPU内部的固件中，充当“解释器”，将复杂指令翻译为硬件可直接执行的原子操作。 示例： x86处理器的复杂指令（如字符串操作）会被微码分解为多个μops（如加载、计算、存储），硬件仅需实现这些基础操作。 向后兼容性： 微码允许通过更新固件（而非修改硬件）支持旧指令集。例如，新x86 CPU通过微码升级兼容几十年前的软件，无需重新设计电路。 历史背景（CISC架构）： 20世纪70-80年代，CISC（复杂指令集计算机，如x86）采用微码实现庞大指令集。指令集包含高度抽象的指令（如单条指令完成复杂操作），通过微码解释适配硬件，但牺牲了一定的效率。后来RISC（精简指令集）通过简化指令集和硬连线逻辑提高了性能，但现代CPU（如Intel/AMD）融合了两者：硬件直接执行常见指令，复杂指令仍依赖微码。 执行（硬连线）：高效但缺乏灵活性，适合固定指令集。 解释（微码）：灵活且简化硬件设计，支持复杂指令集和向后兼容。 cache可能会导致写放大 cpu是byte-addressable，而cacheline granularity更大 weak memory order 在strong中 8发生在5之后是不被允许的，观察到写的顺序得一致 锁需要维护状态16-40bytes 获取锁需要系统调用，耗时 coarse-grained locking 高争用下degrade 获取锁的延迟明显增加，即使是共享锁 乐观锁 试图优化读为大多数的情况 由于上述原因，共享锁没有用 • Associate a version with the shared resource • Writers still have to acquire an exclusive lock of some sort • This ensures that only one writer at a time has access to the resource • At the end of its critical section, a writer atomically increases the version • Readers only have to read the version • At the begin of its critical section, a reader atomically reads the current version • At the end of its critical section, a reader validates that the version did not change • Otherwise, a concurrent write occurred and the critical section is restarted writer(optLock) { lockExclusive(optLock.mutex) // begin critical section // modify the shared resource storeAtomic(optLock.version, optLock.version + 1) unlockExclusive(optLock.mutex) // end critical section } reader(optLock) { while(true) { current = loadAtomic(optLock.version); // begin critical section // read the shared resource if (current == loadAtomic(optLock.version)) // validate return; // end critical section } } 读者只需要两个原子load，比共享锁便宜 但是注意，共享资源在我们访问时可能被修改，不能做出consistent state的假设 更复杂的读操作需要更多中间检查 non-blocking 不依赖锁的，使用原子操作 一般是lock-free的同义词，表示至少能有一个线程能make progress lost update和A-B-A问题 CAS没有公平性，不保证某个线程最终能获得锁."/><meta property="og:image:width" content="1200"/><meta property="og:image:height" content="630"/><meta property="og:image:url" content="https://swingurm.github.io/quartz/static/og-image.png"/><meta name="twitter:image" content="https://swingurm.github.io/quartz/static/og-image.png"/><meta property="og:image" content="https://swingurm.github.io/quartz/static/og-image.png"/><meta property="twitter:domain" content="swingurm.github.io/quartz"/><meta property="og:url" content="https://swingurm.github.io/quartz/Daily/2025-01-27"/><meta property="twitter:url" content="https://swingurm.github.io/quartz/Daily/2025-01-27"/><link rel="icon" href="../static/icon.png"/><meta name="description" content="Mine of Information - Beginner’s Guide to Installing from Source 5.4. Multithreading Problems False Sharing 没有正确性问题，归根结底还是因为访问了不同的内存地址吧 int sum1; int sum2; void thread1(int v[], int v_count) { sum1 = 0; for (int i = 0; i &lt; v_count; i++) sum1 += v[i]; } void thread2(int v[], int v_count) { sum2 = 0; for (int i = 0; i &lt; v_count; i++) sum2 += v[i]; } 1.首先, thread1 将 sum1 读入其缓存。由于该行不存在于其他任何缓存中, thread1 处于独占状态: 2.thread2 现在读取 sum2 。由于 thread1 的缓存行已经在独占状态，这会导致 thread1 的缓存行降级，并且缓存行现在在两个缓存中都处于共享状态： 3.thread1 现在将其更新后的总和写入 sum1 。由于它只在共享状态下拥有该行，因此必须升级该行并在 thread2 的缓存中无效该行： 4.thread2 现在将其更新后的总和写入到 sum2 中。由于 thread1 已在其缓存中失效了该缓存行，因此发生了一致性缺失，并且必须在 thread1 的缓存中失效该行，从而迫使 thread1 执行一致性写回： 5.下一次循环迭代现在开始， thread1 再次读取 sum1 。由于 thread2 刚刚在 thread1 的缓存中失效了缓存行，它会遇到一致性缺失。它还必须在 thread2 的缓存中降级该行，迫使 thread2 执行一致性写回操作： 6.thread2 最终读取了 sum2 。由于它有共享状态的缓存行，因此可以无需一致性活动就进行读取，我们又回到了步骤 2 结束时的情况 3到6昂贵的升级、一致性缺失和一致性写回 lecture-10.1.pdf Execution vs interpretation deepseek生成 传统硬件执行： 经典的CPU通过硬连线路（Hardwired Logic）直接实现取指-解码-执行周期。每条指令的每个步骤（如加法、跳转）都由专用电路处理。这种方式高效但灵活性低，修改指令集需重新设计硬件。 通过微码解释器，硬件专注于高效执行μops，而非直接处理复杂指令。这使得设计更模块化，例如现代CPU可复用相同的ALU（算术逻辑单元）处理多种指令。 软件解释器： 通过软件（如微码，即Microcode）实现指令的解释。复杂指令被分解为更小的微操作（μops），这些μops由底层硬件执行。微码存储在CPU内部的固件中，充当“解释器”，将复杂指令翻译为硬件可直接执行的原子操作。 示例： x86处理器的复杂指令（如字符串操作）会被微码分解为多个μops（如加载、计算、存储），硬件仅需实现这些基础操作。 向后兼容性： 微码允许通过更新固件（而非修改硬件）支持旧指令集。例如，新x86 CPU通过微码升级兼容几十年前的软件，无需重新设计电路。 历史背景（CISC架构）： 20世纪70-80年代，CISC（复杂指令集计算机，如x86）采用微码实现庞大指令集。指令集包含高度抽象的指令（如单条指令完成复杂操作），通过微码解释适配硬件，但牺牲了一定的效率。后来RISC（精简指令集）通过简化指令集和硬连线逻辑提高了性能，但现代CPU（如Intel/AMD）融合了两者：硬件直接执行常见指令，复杂指令仍依赖微码。 执行（硬连线）：高效但缺乏灵活性，适合固定指令集。 解释（微码）：灵活且简化硬件设计，支持复杂指令集和向后兼容。 cache可能会导致写放大 cpu是byte-addressable，而cacheline granularity更大 weak memory order 在strong中 8发生在5之后是不被允许的，观察到写的顺序得一致 锁需要维护状态16-40bytes 获取锁需要系统调用，耗时 coarse-grained locking 高争用下degrade 获取锁的延迟明显增加，即使是共享锁 乐观锁 试图优化读为大多数的情况 由于上述原因，共享锁没有用 • Associate a version with the shared resource • Writers still have to acquire an exclusive lock of some sort • This ensures that only one writer at a time has access to the resource • At the end of its critical section, a writer atomically increases the version • Readers only have to read the version • At the begin of its critical section, a reader atomically reads the current version • At the end of its critical section, a reader validates that the version did not change • Otherwise, a concurrent write occurred and the critical section is restarted writer(optLock) { lockExclusive(optLock.mutex) // begin critical section // modify the shared resource storeAtomic(optLock.version, optLock.version + 1) unlockExclusive(optLock.mutex) // end critical section } reader(optLock) { while(true) { current = loadAtomic(optLock.version); // begin critical section // read the shared resource if (current == loadAtomic(optLock.version)) // validate return; // end critical section } } 读者只需要两个原子load，比共享锁便宜 但是注意，共享资源在我们访问时可能被修改，不能做出consistent state的假设 更复杂的读操作需要更多中间检查 non-blocking 不依赖锁的，使用原子操作 一般是lock-free的同义词，表示至少能有一个线程能make progress lost update和A-B-A问题 CAS没有公平性，不保证某个线程最终能获得锁."/><meta name="generator" content="Quartz"/><link href="../index.css" rel="stylesheet" type="text/css" spa-preserve/><link href="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.css" rel="stylesheet" type="text/css" spa-preserve/><script src="../prescript.js" type="application/javascript" spa-preserve></script><script type="application/javascript" spa-preserve>const fetchData = fetch("../static/contentIndex.json").then(data => data.json())</script></head><body data-slug="Daily/2025-01-27"><div id="quartz-root" class="page"><div id="quartz-body"><div class="left sidebar"><h2 class="page-title"><a href="..">🐧 Blog</a></h2><div class="spacer mobile-only"></div><div class="search"><button class="search-button" id="search-button"><p>搜索</p><svg role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 19.9 19.7"><title>Search</title><g class="search-path" fill="none"><path stroke-linecap="square" d="M18.5 18.3l-5.4-5.4"></path><circle cx="8" cy="8" r="7"></circle></g></svg></button><div id="search-container"><div id="search-space"><input autocomplete="off" id="search-bar" name="search" type="text" aria-label="搜索些什么" placeholder="搜索些什么"/><div id="search-layout" data-preview="true"></div></div></div></div><button class="darkmode" id="darkmode"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" id="dayIcon" x="0px" y="0px" viewBox="0 0 35 35" style="enable-background:new 0 0 35 35" xml:space="preserve" aria-label="暗色模式"><title>暗色模式</title><path d="M6,17.5C6,16.672,5.328,16,4.5,16h-3C0.672,16,0,16.672,0,17.5    S0.672,19,1.5,19h3C5.328,19,6,18.328,6,17.5z M7.5,26c-0.414,0-0.789,0.168-1.061,0.439l-2,2C4.168,28.711,4,29.086,4,29.5    C4,30.328,4.671,31,5.5,31c0.414,0,0.789-0.168,1.06-0.44l2-2C8.832,28.289,9,27.914,9,27.5C9,26.672,8.329,26,7.5,26z M17.5,6    C18.329,6,19,5.328,19,4.5v-3C19,0.672,18.329,0,17.5,0S16,0.672,16,1.5v3C16,5.328,16.671,6,17.5,6z M27.5,9    c0.414,0,0.789-0.168,1.06-0.439l2-2C30.832,6.289,31,5.914,31,5.5C31,4.672,30.329,4,29.5,4c-0.414,0-0.789,0.168-1.061,0.44    l-2,2C26.168,6.711,26,7.086,26,7.5C26,8.328,26.671,9,27.5,9z M6.439,8.561C6.711,8.832,7.086,9,7.5,9C8.328,9,9,8.328,9,7.5    c0-0.414-0.168-0.789-0.439-1.061l-2-2C6.289,4.168,5.914,4,5.5,4C4.672,4,4,4.672,4,5.5c0,0.414,0.168,0.789,0.439,1.06    L6.439,8.561z M33.5,16h-3c-0.828,0-1.5,0.672-1.5,1.5s0.672,1.5,1.5,1.5h3c0.828,0,1.5-0.672,1.5-1.5S34.328,16,33.5,16z     M28.561,26.439C28.289,26.168,27.914,26,27.5,26c-0.828,0-1.5,0.672-1.5,1.5c0,0.414,0.168,0.789,0.439,1.06l2,2    C28.711,30.832,29.086,31,29.5,31c0.828,0,1.5-0.672,1.5-1.5c0-0.414-0.168-0.789-0.439-1.061L28.561,26.439z M17.5,29    c-0.829,0-1.5,0.672-1.5,1.5v3c0,0.828,0.671,1.5,1.5,1.5s1.5-0.672,1.5-1.5v-3C19,29.672,18.329,29,17.5,29z M17.5,7    C11.71,7,7,11.71,7,17.5S11.71,28,17.5,28S28,23.29,28,17.5S23.29,7,17.5,7z M17.5,25c-4.136,0-7.5-3.364-7.5-7.5    c0-4.136,3.364-7.5,7.5-7.5c4.136,0,7.5,3.364,7.5,7.5C25,21.636,21.636,25,17.5,25z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" id="nightIcon" x="0px" y="0px" viewBox="0 0 100 100" style="enable-background:new 0 0 100 100" xml:space="preserve" aria-label="亮色模式"><title>亮色模式</title><path d="M96.76,66.458c-0.853-0.852-2.15-1.064-3.23-0.534c-6.063,2.991-12.858,4.571-19.655,4.571  C62.022,70.495,50.88,65.88,42.5,57.5C29.043,44.043,25.658,23.536,34.076,6.47c0.532-1.08,0.318-2.379-0.534-3.23  c-0.851-0.852-2.15-1.064-3.23-0.534c-4.918,2.427-9.375,5.619-13.246,9.491c-9.447,9.447-14.65,22.008-14.65,35.369  c0,13.36,5.203,25.921,14.65,35.368s22.008,14.65,35.368,14.65c13.361,0,25.921-5.203,35.369-14.65  c3.872-3.871,7.064-8.328,9.491-13.246C97.826,68.608,97.611,67.309,96.76,66.458z"></path></svg></button><div class="explorer desktop-only"><button type="button" id="explorer" data-behavior="collapse" data-collapsed="collapsed" data-savestate="true" data-tree="[{&quot;path&quot;:&quot;数据库&quot;,&quot;collapsed&quot;:true},{&quot;path&quot;:&quot;cpp_folder&quot;,&quot;collapsed&quot;:true},{&quot;path&quot;:&quot;Daily&quot;,&quot;collapsed&quot;:true}]" aria-controls="explorer-content" aria-expanded="false"><h2>探索</h2><svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="5 8 14 8" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="fold"><polyline points="6 9 12 15 18 9"></polyline></svg></button><div id="explorer-content"><ul class="overflow" id="explorer-ul"><li><div class="folder-outer open"><ul style="padding-left:0;" class="content" data-folderul><li><div class="folder-container"><svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="5 8 14 8" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="folder-icon"><polyline points="6 9 12 15 18 9"></polyline></svg><div data-folderpath="数据库"><button class="folder-button"><span class="folder-title">数据库</span></button></div></div><div class="folder-outer "><ul style="padding-left:1.4rem;" class="content" data-folderul="数据库"><li><a href="../数据库/并发控制" data-for="数据库/并发控制">并发控制</a></li></ul></div></li><li><div class="folder-container"><svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="5 8 14 8" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="folder-icon"><polyline points="6 9 12 15 18 9"></polyline></svg><div data-folderpath="cpp_folder"><button class="folder-button"><span class="folder-title">cpp_folder</span></button></div></div><div class="folder-outer "><ul style="padding-left:1.4rem;" class="content" data-folderul="cpp_folder"><li><a href="../cpp_folder/定义与声明" data-for="cpp_folder/定义与声明">定义与声明</a></li><li><a href="../cpp_folder/学习资料" data-for="cpp_folder/学习资料">学习资料</a></li></ul></div></li><li><div class="folder-outer "><ul style="padding-left:0;" class="content" data-folderul></ul></div></li><li><div class="folder-container"><svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="5 8 14 8" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="folder-icon"><polyline points="6 9 12 15 18 9"></polyline></svg><div data-folderpath="Daily"><button class="folder-button"><span class="folder-title">Daily</span></button></div></div><div class="folder-outer "><ul style="padding-left:1.4rem;" class="content" data-folderul="Daily"><li><a href="../Daily/2022-10-04" data-for="Daily/2022-10-04">2022-10-04</a></li><li><a href="../Daily/2022-10-09" data-for="Daily/2022-10-09">2022-10-09</a></li><li><a href="../Daily/2023-08-19" data-for="Daily/2023-08-19">2023-08-19</a></li><li><a href="../Daily/2023-08-22" data-for="Daily/2023-08-22">2023-08-22</a></li><li><a href="../Daily/2023-10-15" data-for="Daily/2023-10-15">2023-10-15</a></li><li><a href="../Daily/2023-10-23" data-for="Daily/2023-10-23">2023-10-23</a></li><li><a href="../Daily/2023-10-24" data-for="Daily/2023-10-24">2023-10-24</a></li><li><a href="../Daily/2023-10-25" data-for="Daily/2023-10-25">2023-10-25</a></li><li><a href="../Daily/2023-10-26" data-for="Daily/2023-10-26">2023-10-26</a></li><li><a href="../Daily/2023-10-30" data-for="Daily/2023-10-30">2023-10-30</a></li><li><a href="../Daily/2023-10-31" data-for="Daily/2023-10-31">2023-10-31</a></li><li><a href="../Daily/2023-11-01" data-for="Daily/2023-11-01">2023-11-01</a></li><li><a href="../Daily/2023-11-06" data-for="Daily/2023-11-06">2023-11-06</a></li><li><a href="../Daily/2023-11-08" data-for="Daily/2023-11-08">2023-11-08</a></li><li><a href="../Daily/2023-11-13" data-for="Daily/2023-11-13">2023-11-13</a></li><li><a href="../Daily/2023-11-14" data-for="Daily/2023-11-14">2023-11-14</a></li><li><a href="../Daily/2023-11-19" data-for="Daily/2023-11-19">2023-11-19</a></li><li><a href="../Daily/2023-11-27" data-for="Daily/2023-11-27">2023-11-27</a></li><li><a href="../Daily/2023-11-28" data-for="Daily/2023-11-28">2023-11-28</a></li><li><a href="../Daily/2023-12-01" data-for="Daily/2023-12-01">2023-12-01</a></li><li><a href="../Daily/2023-12-05" data-for="Daily/2023-12-05">2023-12-05</a></li><li><a href="../Daily/2023-12-19" data-for="Daily/2023-12-19">2023-12-19</a></li><li><a href="../Daily/2023-12-20" data-for="Daily/2023-12-20">2023-12-20</a></li><li><a href="../Daily/2023-12-23" data-for="Daily/2023-12-23">2023-12-23</a></li><li><a href="../Daily/2023-12-28" data-for="Daily/2023-12-28">2023-12-28</a></li><li><a href="../Daily/2024-01-06" data-for="Daily/2024-01-06">2024-01-06</a></li><li><a href="../Daily/2024-01-07" data-for="Daily/2024-01-07">2024-01-07</a></li><li><a href="../Daily/2024-01-09" data-for="Daily/2024-01-09">2024-01-09</a></li><li><a href="../Daily/2024-01-18" data-for="Daily/2024-01-18">2024-01-20</a></li><li><a href="../Daily/2024-01-20" data-for="Daily/2024-01-20">2024-01-20</a></li><li><a href="../Daily/2024-02-08" data-for="Daily/2024-02-08">2024-02-08</a></li><li><a href="../Daily/2024-02-10" data-for="Daily/2024-02-10">2024-02-10</a></li><li><a href="../Daily/2024-02-12" data-for="Daily/2024-02-12">2024-02-12</a></li><li><a href="../Daily/2024-02-13" data-for="Daily/2024-02-13">2024-02-13</a></li><li><a href="../Daily/2024-02-15" data-for="Daily/2024-02-15">2024-02-15</a></li><li><a href="../Daily/2024-02-26" data-for="Daily/2024-02-26">2024-02-26</a></li><li><a href="../Daily/2024-03-21" data-for="Daily/2024-03-21">2024-03-21</a></li><li><a href="../Daily/2024-07-24" data-for="Daily/2024-07-24">2024-07-24</a></li><li><a href="../Daily/2024-07-25" data-for="Daily/2024-07-25">2024-07-25</a></li><li><a href="../Daily/2024-07-26" data-for="Daily/2024-07-26">2024-07-26</a></li><li><a href="../Daily/2024-07-30" data-for="Daily/2024-07-30">2024-07-30</a></li><li><a href="../Daily/2024-07-31" data-for="Daily/2024-07-31">2024-07-31</a></li><li><a href="../Daily/2024-08-02" data-for="Daily/2024-08-02">2024-08-02</a></li><li><a href="../Daily/2024-08-12" data-for="Daily/2024-08-12">2024-08-12</a></li><li><a href="../Daily/2024-08-14" data-for="Daily/2024-08-14">2024-08-14</a></li><li><a href="../Daily/2024-08-15" data-for="Daily/2024-08-15">2024-08-15</a></li><li><a href="../Daily/2024-08-16" data-for="Daily/2024-08-16">2024-08-16</a></li><li><a href="../Daily/2024-09-09" data-for="Daily/2024-09-09">2024-09-09</a></li><li><a href="../Daily/2024-09-11" data-for="Daily/2024-09-11">2024-09-11</a></li><li><a href="../Daily/2024-09-13" data-for="Daily/2024-09-13">2024-09-13</a></li><li><a href="../Daily/2024-09-23" data-for="Daily/2024-09-23">2024-09-23</a></li><li><a href="../Daily/2024-10-08" data-for="Daily/2024-10-08">2024-10-08</a></li><li><a href="../Daily/2024-10-13" data-for="Daily/2024-10-13">2024-10-13</a></li><li><a href="../Daily/2024-10-19" data-for="Daily/2024-10-19">2024-10-19</a></li><li><a href="../Daily/2024-11-12" data-for="Daily/2024-11-12">2024-11-12</a></li><li><a href="../Daily/2024-11-13" data-for="Daily/2024-11-13">2024-11-13</a></li><li><a href="../Daily/2024-11-24" data-for="Daily/2024-11-24">2024-11-24</a></li><li><a href="../Daily/2024-12-06" data-for="Daily/2024-12-06">2024-12-06</a></li><li><a href="../Daily/2024-12-10" data-for="Daily/2024-12-10">2024-12-10</a></li><li><a href="../Daily/2024-12-21" data-for="Daily/2024-12-21">2024-12-21</a></li><li><a href="../Daily/2024-12-23" data-for="Daily/2024-12-23">2024-12-23</a></li><li><a href="../Daily/2024-12-29" data-for="Daily/2024-12-29">2024-12-29</a></li><li><a href="../Daily/2025-01-10" data-for="Daily/2025-01-10">2025-01-10</a></li><li><a href="../Daily/2025-01-23" data-for="Daily/2025-01-23">2025-01-23</a></li><li><a href="../Daily/2025-01-27" data-for="Daily/2025-01-27">2025-01-27</a></li><li><a href="../Daily/2025-02-07" data-for="Daily/2025-02-07">2025-02-07</a></li><li><a href="../Daily/2025-02-18" data-for="Daily/2025-02-18">2025-02-18</a></li><li><a href="../Daily/2025-02-27" data-for="Daily/2025-02-27">2025-02-27</a></li><li><a href="../Daily/2025-03-08" data-for="Daily/2025-03-08">2025-03-08</a></li><li><a href="../Daily/2025-03-20" data-for="Daily/2025-03-20">2025-03-20</a></li><li><a href="../Daily/2025-04-02" data-for="Daily/2025-04-02">2025-04-02</a></li><li><a href="../Daily/2025-04-05" data-for="Daily/2025-04-05">2025-04-05</a></li></ul></div></li><li><a href="../01背包" data-for="01背包">01背包</a></li><li><a href="../15-445-实验remake记录" data-for="15-445-实验remake记录">15-445 实验remake记录</a></li><li><a href="../6840" data-for="6840">6840</a></li><li><a href="../编译原理" data-for="编译原理">编译原理</a></li><li><a href="../操作系统" data-for="操作系统">操作系统</a></li><li><a href="../动态规划" data-for="动态规划">动态规划</a></li><li><a href="../多重背包" data-for="多重背包">多重背包</a></li><li><a href="../分组背包" data-for="分组背包">分组背包</a></li><li><a href="../计算机图形学" data-for="计算机图形学">计算机图形学</a></li><li><a href="../算法" data-for="算法">算法</a></li><li><a href="../图图" data-for="图图">图图</a></li><li><a href="../完全背包" data-for="完全背包">完全背包</a></li><li><a href="../bsdiff" data-for="bsdiff">bsdiff</a></li><li><a href="../BST" data-for="BST">BST</a></li><li><a href="../c" data-for="c">c</a></li><li><a href="../CLRS" data-for="CLRS">CLRS</a></li><li><a href="../CMU-15-445" data-for="CMU-15-445">CMU 15-445</a></li><li><a href="../cpp" data-for="cpp">cpp</a></li><li><a href="../csapp" data-for="csapp">csapp</a></li><li><a href="../csharp" data-for="csharp">csharp</a></li><li><a href="../ddia" data-for="ddia">ddia</a></li><li><a href="../git" data-for="git">git</a></li><li><a href="../IAD" data-for="IAD">IAD</a></li><li><a href="../IO缓冲" data-for="IO缓冲">IO缓冲</a></li><li><a href="../java" data-for="java">java</a></li><li><a href="../leveldb" data-for="leveldb">leveldb</a></li><li><a href="../libc" data-for="libc">libc</a></li><li><a href="../make" data-for="make">make</a></li><li><a href="../Obsidian" data-for="Obsidian">Obsidian</a></li><li><a href="../Parallel" data-for="Parallel">Parrallel</a></li><li><a href="../python" data-for="python">python</a></li></ul></div></li><li id="explorer-end"></li></ul></div></div></div><div class="center"><div class="page-header"><div class="popover-hint"><nav class="breadcrumb-container" aria-label="breadcrumbs"><div class="breadcrumb-element"><a href="../">Home</a><p> ❯ </p></div><div class="breadcrumb-element"><a href="../Daily/">Daily</a><p> ❯ </p></div><div class="breadcrumb-element"><a href>2025-01-27</a></div></nav><h1 class="article-title">2025-01-27</h1><p show-comma="true" class="content-meta"><time datetime="2025-01-27T09:45:25.000Z">2025年1月27日</time><span>7分钟阅读</span></p><ul class="tags"><li><a href="../tags/example-tag" class="internal tag-link">example-tag</a></li></ul></div></div><article class="popover-hint"><p><a href="https://moi.vonos.net/linux/beginners-installing-from-source/" class="external">Mine of Information - Beginner’s Guide to Installing from Source<svg aria-hidden="true" class="external-icon" style="max-width:0.8em;max-height:0.8em;" viewBox="0 0 512 512"><path d="M320 0H288V64h32 82.7L201.4 265.4 178.7 288 224 333.3l22.6-22.6L448 109.3V192v32h64V192 32 0H480 320zM32 32H0V64 480v32H32 456h32V480 352 320H424v32 96H64V96h96 32V32H160 32z"></path></svg></a></p>
<p><a href="https://www.nic.uoregon.edu/~khuck/ts/acumem-report/manual_html/multithreading_problems.html" class="external">5.4. Multithreading Problems<svg aria-hidden="true" class="external-icon" style="max-width:0.8em;max-height:0.8em;" viewBox="0 0 512 512"><path d="M320 0H288V64h32 82.7L201.4 265.4 178.7 288 224 333.3l22.6-22.6L448 109.3V192v32h64V192 32 0H480 320zM32 32H0V64 480v32H32 456h32V480 352 320H424v32 96H64V96h96 32V32H160 32z"></path></svg></a></p>
<h4 id="false-sharing">False Sharing<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#false-sharing" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h4>
<p>没有正确性问题，归根结底还是因为访问了不同的内存地址吧</p>
<figure data-rehype-pretty-code-figure><pre tabindex="0" data-language="c" data-theme="github-light github-dark"><code data-language="c" data-theme="github-light github-dark" style="display:grid;"><span data-line><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> sum1;</span></span>
<span data-line><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> sum2;</span></span>
<span data-line> </span>
<span data-line><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> thread1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> v</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">[]</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> v_count</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    sum1 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span data-line><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> v_count; i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        sum1 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+=</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> v</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[i];</span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span data-line> </span>
<span data-line><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> thread2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> v</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">[]</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> v_count</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    sum2 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span data-line><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> v_count; i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        sum2 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+=</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> v</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[i];</span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></figure>
<p>1.首先, <code>thread1</code> 将 <code>sum1</code> 读入其缓存。由于该行不存在于其他任何缓存中, <code>thread1</code> 处于独占状态:
2.<code>thread2</code> 现在读取 <code>sum2</code> 。由于 <code>thread1</code> 的缓存行已经在独占状态，这会导致 <code>thread1</code> 的缓存行降级，并且缓存行现在在两个缓存中都处于共享状态：
3.<code>thread1</code> 现在将其更新后的总和写入 <code>sum1</code> 。由于它只在共享状态下拥有该行，因此必须升级该行并在 <code>thread2</code> 的缓存中无效该行：
4.<code>thread2</code> 现在将其更新后的总和写入到 <code>sum2</code> 中。由于 <code>thread1</code> 已在其缓存中失效了该缓存行，因此发生了一致性缺失，并且必须在 <code>thread1</code> 的缓存中失效该行，从而迫使 <code>thread1</code> 执行一致性写回：
5.下一次循环迭代现在开始， <code>thread1</code> 再次读取 <code>sum1</code> 。由于 <code>thread2</code> 刚刚在 <code>thread1</code> 的缓存中失效了缓存行，它会遇到一致性缺失。它还必须在 <code>thread2</code> 的缓存中降级该行，迫使 <code>thread2</code> 执行一致性写回操作：
6.<code>thread2</code> 最终读取了 <code>sum2</code> 。由于它有共享状态的缓存行，因此可以无需一致性活动就进行读取，我们又回到了步骤 2 结束时的情况</p>
<p>3到6昂贵的升级、一致性缺失和一致性写回</p>
<p><a href="https://db.in.tum.de/teaching/ss23/c++praktikum/slides/lecture-10.1.pdf?lang=en" class="external">lecture-10.1.pdf<svg aria-hidden="true" class="external-icon" style="max-width:0.8em;max-height:0.8em;" viewBox="0 0 512 512"><path d="M320 0H288V64h32 82.7L201.4 265.4 178.7 288 224 333.3l22.6-22.6L448 109.3V192v32h64V192 32 0H480 320zM32 32H0V64 480v32H32 456h32V480 352 320H424v32 96H64V96h96 32V32H160 32z"></path></svg></a></p>
<h3 id="execution-vs-interpretation">Execution vs interpretation<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#execution-vs-interpretation" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h3>
<p>deepseek生成</p>
<p><strong>传统硬件执行</strong>：<br/>
经典的CPU通过硬连线路（Hardwired Logic）直接实现<strong>取指-解码-执行周期</strong>。每条指令的每个步骤（如加法、跳转）都由专用电路处理。这种方式高效但灵活性低，修改指令集需重新设计硬件。
通过微码解释器，硬件专注于高效执行μops，而非直接处理复杂指令。这使得设计更模块化，例如现代CPU可复用相同的ALU（算术逻辑单元）处理多种指令。</p>
<p><strong>软件解释器</strong>：<br/>
通过软件（如<strong>微码</strong>，即Microcode）实现指令的解释。复杂指令被分解为更小的<strong>微操作（μops）</strong>，这些μops由底层硬件执行。微码存储在CPU内部的固件中，充当“解释器”，将复杂指令翻译为硬件可直接执行的原子操作。</p>
<p><strong>示例</strong>：<br/>
x86处理器的复杂指令（如字符串操作）会被微码分解为多个μops（如加载、计算、存储），硬件仅需实现这些基础操作。</p>
<p><strong>向后兼容性</strong>：<br/>
微码允许通过更新固件（而非修改硬件）支持旧指令集。例如，新x86 CPU通过微码升级兼容几十年前的软件，无需重新设计电路。</p>
<ul>
<li>
<p><strong>历史背景（CISC架构）</strong>：<br/>
20世纪70-80年代，CISC（复杂指令集计算机，如x86）采用微码实现庞大指令集。指令集包含高度抽象的指令（如单条指令完成复杂操作），通过微码解释适配硬件，但牺牲了一定的效率。后来RISC（精简指令集）通过简化指令集和硬连线逻辑提高了性能，但现代CPU（如Intel/AMD）融合了两者：硬件直接执行常见指令，复杂指令仍依赖微码。</p>
</li>
<li>
<p><strong>执行（硬连线）</strong>：高效但缺乏灵活性，适合固定指令集。</p>
</li>
<li>
<p><strong>解释（微码）</strong>：灵活且简化硬件设计，支持复杂指令集和向后兼容。</p>
</li>
</ul>
<p>cache可能会导致写放大</p>
<p>cpu是byte-addressable，而cacheline granularity更大</p>
<p><img src="../attachments/截屏2025-01-31-22.21.20.png" width="auto" height="auto" alt/></p>
<p>weak memory order</p>
<p>在strong中 8发生在5之后是不被允许的，观察到写的顺序得一致</p>
<p>锁需要维护状态16-40bytes</p>
<p>获取锁需要系统调用，耗时</p>
<p>coarse-grained locking</p>
<p>高争用下degrade</p>
<p>获取锁的延迟明显增加，即使是共享锁</p>
<h4 id="乐观锁">乐观锁<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#乐观锁" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h4>
<p>试图优化读为大多数的情况</p>
<p>由于上述原因，共享锁没有用</p>
<p>• Associate a version with the shared resource</p>
<p>• Writers still have to acquire an exclusive lock of some sort</p>
<p>• This ensures that only one writer at a time has access to the resource</p>
<p>• At the end of its critical section, a writer atomically increases the version</p>
<p>• Readers only have to read the version</p>
<p>• At the begin of its critical section, a reader atomically reads the current version</p>
<p>• At the end of its critical section, a reader validates that the version did not change</p>
<p>• Otherwise, a concurrent write occurred and the critical section is restarted</p>
<figure data-rehype-pretty-code-figure><pre tabindex="0" data-language="c" data-theme="github-light github-dark"><code data-language="c" data-theme="github-light github-dark" style="display:grid;"><span data-line><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">writer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(optLock) { </span></span>
<span data-line><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">	lockExclusive</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(optLock.mutex)</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // begin critical section </span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">	// modify the shared resource </span></span>
<span data-line><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">	storeAtomic</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(optLock.version, optLock.version </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span data-line><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">	unlockExclusive</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(optLock.mutex)</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // end critical section </span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span data-line><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">reader</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(optLock) { </span></span>
<span data-line><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) { current </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> loadAtomic</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(optLock.version);</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // begin critical section </span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">	// read the shared resource </span></span>
<span data-line><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (current </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> loadAtomic</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(optLock.version))</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // validate </span></span>
<span data-line><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // end critical section </span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	} </span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></figure>
<p>读者只需要两个原子load，比共享锁便宜</p>
<p>但是注意，共享资源在我们访问时可能被修改，不能做出consistent state的假设</p>
<p>更复杂的读操作需要更多中间检查</p>
<h4 id="non-blocking">non-blocking<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#non-blocking" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h4>
<p>不依赖锁的，使用原子操作</p>
<p>一般是lock-free的同义词，表示至少能有一个线程能make progress</p>
<p>lost update和A-B-A问题</p>
<p>CAS没有公平性，不保证某个线程最终能获得锁</p></article><hr/><div class="page-footer"></div></div><div class="right sidebar"><div class="graph"><h3>关系图谱</h3><div class="graph-outer"><div id="graph-container" data-cfg="{&quot;drag&quot;:true,&quot;zoom&quot;:true,&quot;depth&quot;:1,&quot;scale&quot;:1.1,&quot;repelForce&quot;:0.5,&quot;centerForce&quot;:0.3,&quot;linkDistance&quot;:30,&quot;fontSize&quot;:0.6,&quot;opacityScale&quot;:1,&quot;showTags&quot;:true,&quot;removeTags&quot;:[],&quot;focusOnHover&quot;:false}"></div><button id="global-graph-icon" aria-label="Global Graph"><svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 55 55" fill="currentColor" xml:space="preserve"><path d="M49,0c-3.309,0-6,2.691-6,6c0,1.035,0.263,2.009,0.726,2.86l-9.829,9.829C32.542,17.634,30.846,17,29,17
                s-3.542,0.634-4.898,1.688l-7.669-7.669C16.785,10.424,17,9.74,17,9c0-2.206-1.794-4-4-4S9,6.794,9,9s1.794,4,4,4
                c0.74,0,1.424-0.215,2.019-0.567l7.669,7.669C21.634,21.458,21,23.154,21,25s0.634,3.542,1.688,4.897L10.024,42.562
                C8.958,41.595,7.549,41,6,41c-3.309,0-6,2.691-6,6s2.691,6,6,6s6-2.691,6-6c0-1.035-0.263-2.009-0.726-2.86l12.829-12.829
                c1.106,0.86,2.44,1.436,3.898,1.619v10.16c-2.833,0.478-5,2.942-5,5.91c0,3.309,2.691,6,6,6s6-2.691,6-6c0-2.967-2.167-5.431-5-5.91
                v-10.16c1.458-0.183,2.792-0.759,3.898-1.619l7.669,7.669C41.215,39.576,41,40.26,41,41c0,2.206,1.794,4,4,4s4-1.794,4-4
                s-1.794-4-4-4c-0.74,0-1.424,0.215-2.019,0.567l-7.669-7.669C36.366,28.542,37,26.846,37,25s-0.634-3.542-1.688-4.897l9.665-9.665
                C46.042,11.405,47.451,12,49,12c3.309,0,6-2.691,6-6S52.309,0,49,0z M11,9c0-1.103,0.897-2,2-2s2,0.897,2,2s-0.897,2-2,2
                S11,10.103,11,9z M6,51c-2.206,0-4-1.794-4-4s1.794-4,4-4s4,1.794,4,4S8.206,51,6,51z M33,49c0,2.206-1.794,4-4,4s-4-1.794-4-4
                s1.794-4,4-4S33,46.794,33,49z M29,31c-3.309,0-6-2.691-6-6s2.691-6,6-6s6,2.691,6,6S32.309,31,29,31z M47,41c0,1.103-0.897,2-2,2
                s-2-0.897-2-2s0.897-2,2-2S47,39.897,47,41z M49,10c-2.206,0-4-1.794-4-4s1.794-4,4-4s4,1.794,4,4S51.206,10,49,10z"></path></svg></button></div><div id="global-graph-outer"><div id="global-graph-container" data-cfg="{&quot;drag&quot;:true,&quot;zoom&quot;:true,&quot;depth&quot;:-1,&quot;scale&quot;:0.9,&quot;repelForce&quot;:0.5,&quot;centerForce&quot;:0.3,&quot;linkDistance&quot;:30,&quot;fontSize&quot;:0.6,&quot;opacityScale&quot;:1,&quot;showTags&quot;:true,&quot;removeTags&quot;:[],&quot;focusOnHover&quot;:true}"></div></div></div></div><footer class><p>Created with <a href="https://quartz.jzhao.xyz/">Quartz v4.4.0</a> © 2025</p><ul><li><a href="https://github.com/jackyzha0/quartz">GitHub</a></li><li><a href="https://discord.gg/cRFFHYye7t">Discord Community</a></li></ul></footer></div></div></body><script type="application/javascript">function c(){let t=this.parentElement;t.classList.toggle("is-collapsed");let l=t.classList.contains("is-collapsed")?this.scrollHeight:t.scrollHeight;t.style.maxHeight=l+"px";let o=t,e=t.parentElement;for(;e;){if(!e.classList.contains("callout"))return;let n=e.classList.contains("is-collapsed")?e.scrollHeight:e.scrollHeight+o.scrollHeight;e.style.maxHeight=n+"px",o=e,e=e.parentElement}}function i(){let t=document.getElementsByClassName("callout is-collapsible");for(let s of t){let l=s.firstElementChild;if(l){l.addEventListener("click",c),window.addCleanup(()=>l.removeEventListener("click",c));let e=s.classList.contains("is-collapsed")?l.scrollHeight:s.scrollHeight;s.style.maxHeight=e+"px"}}}document.addEventListener("nav",i);window.addEventListener("resize",i);
</script><script src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/contrib/copy-tex.min.js" type="application/javascript"></script><script src="../postscript.js" type="module"></script></html>